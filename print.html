<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="utf-8">
        <title>Void Linux Handbook</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/print.css" media="print">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
        </script>
		<!-- Work around some values being stored in localStorage wrapped in quotes -->
		<script type="text/javascript">
			try {
				var sidebar = localStorage.getItem('mdbook-sidebar');

				if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
					localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
				}
			} catch (e) { }
		</script>

		<header>
			<nav id="void-nav">
				<ul>
					<li><a id="skip-to-content" tabindex="1" href="#main">Skip to content</a></li>
					<li>
						<button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
							<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
								<path d="M1 3v2h18V3zm0 8h18V9H1zm0 6h18v-2H1z"/>
							</svg>
						</button>
					</li>
					<li>
						<button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
							<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
								<path d="M7.5 13c3.04 0 5.5-2.46 5.5-5.5S10.54 2 7.5 2 2 4.46 2 7.5 4.46 13 7.5 13zm4.55.46C10.79 14.43 9.21 15 7.5 15 3.36 15 0 11.64 0 7.5S3.36 0 7.5 0C11.64 0 15 3.36 15 7.5c0 1.71-.57 3.29-1.54 4.55l6.49 6.49-1.41 1.41-6.49-6.49z"/>
							</svg>
						</button>
					</li>
                                        <noscript>
                                          <li class="js-unavailable">Search functionality requires JavaScript</li>
                                        </noscript>
				</ul>
				<ul id="nav-right">
					<li><a href="https://www.voidlinux.org">Home</a></li>
					<li><a href="https://www.voidlinux.org/news/">News</a></li>
					<li><a href="https://www.voidlinux.org/download/">Download</a></li>
					<li><a href="https://www.voidlinux.org/packages/">Packages</a></li>
					<li><a href="https://docs.voidlinux.org">Documentation</a></li>
					<li><a href="https://man.voidlinux.org/">Manual Pages</a></li>
					<li><a href="https://github.com/void-linux">GitHub</a></li>
				</ul>
			</nav>
		</header>

		<div id="content">

			<!-- Hide / unhide sidebar before it is displayed -->
			<script type="text/javascript">
				var html = document.querySelector('html');
				var sidebar = 'hidden';
				if (document.body.clientWidth >= 1080) {
					try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
					sidebar = sidebar || 'visible';
				}
				html.classList.remove('sidebar-visible');
				html.classList.add("sidebar-" + sidebar);
			</script>

			<nav id="sidebar" aria-label="Table of contents">
				<ol class="chapter"><li class="chapter-item expanded "><a href="about/index.html"><strong aria-hidden="true">1.</strong> 关于</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="about/history.html"><strong aria-hidden="true">1.1.</strong> 历史</a></li><li class="chapter-item expanded "><a href="about/about-this-handbook.html"><strong aria-hidden="true">1.2.</strong> 关于本手册</a></li><li class="chapter-item expanded "><a href="about/infradocs.html"><strong aria-hidden="true">1.3.</strong> InfraDocs</a></li></ol></li><li class="chapter-item expanded "><a href="installation/index.html"><strong aria-hidden="true">2.</strong> 安装</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation/live-images/index.html"><strong aria-hidden="true">2.1.</strong> Live 安装程序</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation/live-images/prep.html"><strong aria-hidden="true">2.1.1.</strong> 准备安装介质</a></li><li class="chapter-item expanded "><a href="installation/live-images/partitions.html"><strong aria-hidden="true">2.1.2.</strong> 分区说明</a></li><li class="chapter-item expanded "><a href="installation/live-images/guide.html"><strong aria-hidden="true">2.1.3.</strong> 安装指南</a></li></ol></li><li class="chapter-item expanded "><a href="installation/guides/index.html"><strong aria-hidden="true">2.2.</strong> 进阶安装指南</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation/guides/chroot.html"><strong aria-hidden="true">2.2.1.</strong> 通过 chroot 安装 (x86/x86_64/aarch64)</a></li><li class="chapter-item expanded "><a href="installation/guides/fde.html"><strong aria-hidden="true">2.2.2.</strong> 全盘加密</a></li><li class="chapter-item expanded "><a href="installation/guides/zfs.html"><strong aria-hidden="true">2.2.3.</strong> 全盘 ZFS</a></li><li class="chapter-item expanded "><a href="installation/guides/arm-devices/index.html"><strong aria-hidden="true">2.2.4.</strong> ARM 设备</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation/guides/arm-devices/platforms.html"><strong aria-hidden="true">2.2.4.1.</strong> 所支持的平台</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="installation/musl.html"><strong aria-hidden="true">2.3.</strong> musl</a></li></ol></li><li class="chapter-item expanded "><a href="config/index.html"><strong aria-hidden="true">3.</strong> 配置</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/package-documentation/index.html"><strong aria-hidden="true">3.1.</strong> 软件文档</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/package-documentation/man.html"><strong aria-hidden="true">3.1.1.</strong> 手册页</a></li></ol></li><li class="chapter-item expanded "><a href="config/firmware.html"><strong aria-hidden="true">3.2.</strong> 驱动</a></li><li class="chapter-item expanded "><a href="config/locales.html"><strong aria-hidden="true">3.3.</strong> 本地化与翻译</a></li><li class="chapter-item expanded "><a href="config/users-and-groups.html"><strong aria-hidden="true">3.4.</strong> 用户和用户组</a></li><li class="chapter-item expanded "><a href="config/services/index.html"><strong aria-hidden="true">3.5.</strong> 服务与守护进程 - runit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/services/user-services.html"><strong aria-hidden="true">3.5.1.</strong> 每个用户的服务</a></li><li class="chapter-item expanded "><a href="config/services/logging.html"><strong aria-hidden="true">3.5.2.</strong> 日志</a></li></ol></li><li class="chapter-item expanded "><a href="config/rc-files.html"><strong aria-hidden="true">3.6.</strong> rc.conf, rc.local 还有 rc.shutdown</a></li><li class="chapter-item expanded "><a href="config/cron.html"><strong aria-hidden="true">3.7.</strong> Cron</a></li><li class="chapter-item expanded "><a href="config/ssd.html"><strong aria-hidden="true">3.8.</strong> 固态硬盘</a></li><li class="chapter-item expanded "><a href="config/security/index.html"><strong aria-hidden="true">3.9.</strong> 安全</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/security/apparmor.html"><strong aria-hidden="true">3.9.1.</strong> AppArmor</a></li></ol></li><li class="chapter-item expanded "><a href="config/date-time.html"><strong aria-hidden="true">3.10.</strong> 日期和时间</a></li><li class="chapter-item expanded "><a href="config/kernel.html"><strong aria-hidden="true">3.11.</strong> 内核</a></li><li class="chapter-item expanded "><a href="config/power-management.html"><strong aria-hidden="true">3.12.</strong> 电源管理</a></li><li class="chapter-item expanded "><a href="config/network/index.html"><strong aria-hidden="true">3.13.</strong> 网络</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/network/firewalls.html"><strong aria-hidden="true">3.13.1.</strong> 防火墙</a></li><li class="chapter-item expanded "><a href="config/network/wpa_supplicant.html"><strong aria-hidden="true">3.13.2.</strong> wpa_supplicant</a></li><li class="chapter-item expanded "><a href="config/network/iwd.html"><strong aria-hidden="true">3.13.3.</strong> IWD</a></li><li class="chapter-item expanded "><a href="config/network/networkmanager.html"><strong aria-hidden="true">3.13.4.</strong> NetworkManager</a></li><li class="chapter-item expanded "><a href="config/network/connman.html"><strong aria-hidden="true">3.13.5.</strong> ConnMan</a></li></ol></li><li class="chapter-item expanded "><a href="config/network-filesystems.html"><strong aria-hidden="true">3.14.</strong> 网络文件系统</a></li><li class="chapter-item expanded "><a href="config/session-management.html"><strong aria-hidden="true">3.15.</strong> Session 和 Seat 管理</a></li><li class="chapter-item expanded "><a href="config/graphical-session/index.html"><strong aria-hidden="true">3.16.</strong> 图形 Session</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/graphical-session/graphics-drivers/index.html"><strong aria-hidden="true">3.16.1.</strong> 图形设备</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/graphical-session/graphics-drivers/amd.html"><strong aria-hidden="true">3.16.1.1.</strong> AMD or ATI</a></li><li class="chapter-item expanded "><a href="config/graphical-session/graphics-drivers/intel.html"><strong aria-hidden="true">3.16.1.2.</strong> Intel</a></li><li class="chapter-item expanded "><a href="config/graphical-session/graphics-drivers/nvidia.html"><strong aria-hidden="true">3.16.1.3.</strong> NVIDIA</a></li><li class="chapter-item expanded "><a href="config/graphical-session/graphics-drivers/optimus.html"><strong aria-hidden="true">3.16.1.4.</strong> NVIDIA Optimus</a></li></ol></li><li class="chapter-item expanded "><a href="config/graphical-session/xorg.html"><strong aria-hidden="true">3.16.2.</strong> Xorg</a></li><li class="chapter-item expanded "><a href="config/graphical-session/wayland.html"><strong aria-hidden="true">3.16.3.</strong> Wayland</a></li><li class="chapter-item expanded "><a href="config/graphical-session/fonts.html"><strong aria-hidden="true">3.16.4.</strong> 字体</a></li><li class="chapter-item expanded "><a href="config/graphical-session/icons.html"><strong aria-hidden="true">3.16.5.</strong> 图标</a></li><li class="chapter-item expanded "><a href="config/graphical-session/gnome.html"><strong aria-hidden="true">3.16.6.</strong> GNOME</a></li><li class="chapter-item expanded "><a href="config/graphical-session/kde.html"><strong aria-hidden="true">3.16.7.</strong> KDE</a></li></ol></li><li class="chapter-item expanded "><a href="config/media/index.html"><strong aria-hidden="true">3.17.</strong> 多媒体</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/media/alsa.html"><strong aria-hidden="true">3.17.1.</strong> ALSA</a></li><li class="chapter-item expanded "><a href="config/media/pipewire.html"><strong aria-hidden="true">3.17.2.</strong> PipeWire</a></li><li class="chapter-item expanded "><a href="config/media/pulseaudio.html"><strong aria-hidden="true">3.17.3.</strong> PulseAudio</a></li><li class="chapter-item expanded "><a href="config/media/sndio.html"><strong aria-hidden="true">3.17.4.</strong> sndio</a></li></ol></li><li class="chapter-item expanded "><a href="config/bluetooth.html"><strong aria-hidden="true">3.18.</strong> 蓝牙</a></li><li class="chapter-item expanded "><a href="config/texlive.html"><strong aria-hidden="true">3.19.</strong> TeX Live</a></li><li class="chapter-item expanded "><a href="config/external-applications.html"><strong aria-hidden="true">3.20.</strong> 更多程序</a></li><li class="chapter-item expanded "><a href="config/print/index.html"><strong aria-hidden="true">3.21.</strong> 打印</a></li><li class="chapter-item expanded "><a href="config/containers-and-vms/index.html"><strong aria-hidden="true">3.22.</strong> 容器与虚拟化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/containers-and-vms/chroot.html"><strong aria-hidden="true">3.22.1.</strong> Chroots and Containers</a></li><li class="chapter-item expanded "><a href="config/containers-and-vms/libvirt.html"><strong aria-hidden="true">3.22.2.</strong> libvirt</a></li><li class="chapter-item expanded "><a href="config/containers-and-vms/lxc.html"><strong aria-hidden="true">3.22.3.</strong> LXC</a></li></ol></li><li class="chapter-item expanded "><a href="config/openpgp.html"><strong aria-hidden="true">3.23.</strong> OpenPGP</a></li></ol></li><li class="chapter-item expanded "><a href="xbps/index.html"><strong aria-hidden="true">4.</strong> XBPS 软件管理器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="xbps/advanced-usage.html"><strong aria-hidden="true">4.1.</strong> 高级用法</a></li><li class="chapter-item expanded "><a href="xbps/repositories/index.html"><strong aria-hidden="true">4.2.</strong> 软件源</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="xbps/repositories/mirrors/index.html"><strong aria-hidden="true">4.2.1.</strong> 镜像</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="xbps/repositories/mirrors/changing.html"><strong aria-hidden="true">4.2.1.1.</strong> 更换镜像</a></li><li class="chapter-item expanded "><a href="xbps/repositories/mirrors/tor.html"><strong aria-hidden="true">4.2.1.2.</strong> 使用 Tor 镜像</a></li></ol></li><li class="chapter-item expanded "><a href="xbps/repositories/restricted.html"><strong aria-hidden="true">4.2.2.</strong> 受限制的软件</a></li><li class="chapter-item expanded "><a href="xbps/repositories/custom.html"><strong aria-hidden="true">4.2.3.</strong> 自定义的软件源</a></li><li class="chapter-item expanded "><a href="xbps/repositories/signing.html"><strong aria-hidden="true">4.2.4.</strong> 签名软件源</a></li></ol></li><li class="chapter-item expanded "><a href="xbps/troubleshooting/index.html"><strong aria-hidden="true">4.3.</strong> XBPS 的故障排除</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="xbps/troubleshooting/common-issues.html"><strong aria-hidden="true">4.3.1.</strong> 常见问题</a></li><li class="chapter-item expanded "><a href="xbps/troubleshooting/static.html"><strong aria-hidden="true">4.3.2.</strong> Static XBPS</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="contributing/index.html"><strong aria-hidden="true">5.</strong> 贡献</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contributing/void-docs/index.html"><strong aria-hidden="true">5.1.</strong> 贡献于 void-docs</a></li></ol></li></ol>
			</nav>

			<!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
			<script type="text/javascript">
				document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
	document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
	Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
		link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
	});
			</script>

			<div id="page-wrapper">
				<div id="search-wrapper" class="hidden">
					<form id="searchbar-outer" class="searchbar-outer">
						<input type="search" name="search" id="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
					</form>
					<div id="searchresults-outer" class="searchresults-outer hidden">
						<div id="searchresults-header" class="searchresults-header"></div>
						<ul id="searchresults">
						</ul>
					</div>
				</div>

				<main id="main">
					<h1 id="关于"><a class="header" href="#关于">关于</a></h1>
<p>欢迎来到 Void 手册! 请务必阅读&quot;<a href="about/./about-this-handbook.html">关于本手册</a>&quot; 的部分，以了解如何有效地使用本手册。
本手册的本地部分, 有几种格式,可以通过 <code>void-docs</code> 软件包<a href="about/../xbps/index.html">安装</a>并使用 <a href="https://man.voidlinux.org/void-docs.1">void-docs(1)</a> 访问。</p>
<p>Void 是独立的, <a href="https://en.wikipedia.org/wiki/Rolling_release">滚动</a> Linux 发行版,从头开始开发，不是哪个发行版的分支。注重稳定性大于
<a href="https://en.wikipedia.org/wiki/Bleeding_edge_technology">新的技术</a>. 此外, 还有几个特点使 Void 成为独一无二的存在</p>
<ul>
<li>
<p><a href="https://github.com/void-linux/xbps">XBPS</a> 软件包管理, 它是速度极快, 由 Void 内部开发, XBPS 在更新软件包前会检查兼容性，确保更新不会破坏依赖。</p>
</li>
<li>
<p><a href="https://musl.libc.org/">musl libc</a>, 专注于标准的遵守和正确性，拥有一流的支持。在 musl 系统上，可以构建出一些 glibc 系统上不可能构建出的静态组件。</p>
</li>
<li>
<p><a href="about/../config/services/index.html">runit</a> 用于
<a href="https://man.voidlinux.org/init.8">init(8)</a> 和服务监视器. runit 允许使用 musl 作为 libc，<a href="https://www.freedesktop.org/wiki/Software/systemd/">systemd</a> 无法做到这一点。使用 runit 还使得 Void 的核心系统更精简高效，源代码更简洁。</p>
</li>
</ul>
<p>通常，Void 的稳定性足以应对日常使用。Void 由少数开发者在空闲时间里开发，我们以此为乐，希望我们的工作可以帮助到其他人。</p>
<p>“Void”之名来自 C 语言关键字 void，没有什么特殊含义。</p>
<h2 id="关于其汉化版本"><a class="header" href="#关于其汉化版本">关于其汉化版本</a></h2>
<p>此汉化版本是非官方汉化的，第一部分参考了 <a href="https://github.com/fenprace/void-docs-zh-hans">void-docs-zh-hans</a> ，其他部分参考了 <a href="https://deepl.com">deepl</a> 的翻译对其进行了增删改。</p>
<p>如有什么翻译漏洞请提交 <code>issue</code> 或 <code>fork</code> 之后合并提交。还可以进群交流： <a href="https://t.me/voidlinux_zh">Telegram 群</a>、<a href="https://matrix.to/#/#voidlinux-zh:mozilla.org">Matrix 群</a></p>
<p>其仓库链接是 <a href="https://github.com/voidlinux-zh-association/void-docs-zh-cn/">这里</a> </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="历史"><a class="header" href="#历史">历史</a></h1>
<p>从 Git 日志中 grep 出来的远古知识：</p>
<ul>
<li>2008-09-26：<a href="https://github.com/void-linux/void-packages">void-packages</a> 的第一次 Git 导入</li>
<li>2009-08-17：<a href="https://github.com/void-linux/xbps">xbps</a> 的第一次 Git 导入</li>
<li>2011-06-25：void-packages 的首个 systemd 提交</li>
<li>2013-03-01：首次加入了 <a href="https://musl.libc.org/">musl</a> 工具链</li>
<li>2014-07-14：开始转向 <a href="https://www.libressl.org/">LibreSSL</a></li>
<li>2014-07-28：从 systemd 转向 <a href="http://smarden.org/runit/">runit</a></li>
<li>2015-07-09：完整 aarch64 支持与 <code>linux4.1</code></li>
<li>2018-07-06：为了提高透明度，首次用 <a href="https://github.com/void-linux/void-infrastructure/tree/master/terraform">Terraform 管理 GitHub 权限</a></li>
<li>2021-03-05：开始<a href="https://github.com/void-linux/void-packages/commit/d90dba0ae27c4bb22cbb1722f70e4ed6d599e473">转向</a> <a href="https://www.openssl.org/">OpenSSL</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关于本手册"><a class="header" href="#关于本手册">关于本手册</a></h1>
<p>本手册不是关于如何使用和配置常见 Linux 软件的大而全的指南。本文档的目标是说明如何安装、配置、维护 Void Linux 系统，重点叙述一般 Linux 发行版于 Void 的区别。
点击“放大镜”图标或按下“s”，在本手册中搜索。
要查找配置一般 Linux 系统的提示或技巧，请去参考上游软件的文档。另外，<a href="https://wiki.archlinux.org/">Arch Wiki</a> 提供了相当全面的常见 Linux 软件配置概述，也请灵活运用各种搜索引擎。</p>
<h2 id="阅读-man-手册"><a class="header" href="#阅读-man-手册">阅读 Man 手册</a></h2>
<p>本手册没有巨细无遗的配置指导，但本手册尽可能地提供了相关 <a href="https://man.voidlinux.org/">man 手册页</a>的链接。
运行命令 <code>man man</code> 学习如何使用 man 手册页查看器。编辑 <code>/etc/man.conf</code> 配置 man；详情参考 <a href="https://man.voidlinux.org/man.conf.5">man.conf(5)</a>。
Void 使用 <a href="https://mandoc.bsd.lv/">mandoc</a> 工具组生成 man 手册页。“mdocml”是 mandoc 的曾用名，mandoc 由 <code>mdocml</code> 软件包提供。</p>
<h2 id="命令样例"><a class="header" href="#命令样例">命令样例</a></h2>
<p>本手册中会展示在命令行中运行的代码片段作为例子。这些例子中，以 <code>$</code> 开头的行代表以普通用户运行的命令，以 <code>#</code> 开头的行代表以 <code>root</code> 运行的命令。命令之后可能会紧跟着几行该命令的输出样例。</p>
<h3 id="占位符"><a class="header" href="#占位符">占位符</a></h3>
<p>一些例子会包括占位符，你应该用合适的信息替换占位符，比如：</p>
<pre><code># ln -s /etc/sv/&lt;service_name&gt; /var/service/
</code></pre>
<p>这表示你需要用实际的服务名称替换 <code>&lt;service_name&gt;</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="infradocs"><a class="header" href="#infradocs">InfraDocs</a></h1>
<p><a href="https://infradocs.voidlinux.org/">InfraDocs</a> 是关于 Void 项目系统管理的元手册。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装"><a class="header" href="#安装">安装</a></h1>
<p>本章包括安装 Void 的一般流程。对于特殊的情况，参考<a href="installation/./guides/index.html">《进阶安装》</a>一节</p>
<h2 id="基本系统要求"><a class="header" href="#基本系统要求">基本系统要求</a></h2>
<p>尽管 Void 对硬件的要求很低，我们还是建议在比下述配置更高的系统上安装：</p>
<div class="table-wrapper"><table><thead><tr><th>Architecture</th><th>CPU</th><th>RAM</th><th>Storage</th></tr></thead><tbody>
<tr><td>x86_64-glibc</td><td>x86_64</td><td>96MB</td><td>700MB</td></tr>
<tr><td>x86_64-musl</td><td>x86_64</td><td>96MB</td><td>600MB</td></tr>
<tr><td>i686-glibc</td><td>Pentium 4 (SSE2)</td><td>96MB</td><td>700MB</td></tr>
</tbody></table>
</div>
<p>请注意，xfce 映像安装需要更多资源。 </p>
<p>Void 不支持 i386、i486 或 i586 架构。</p>
<p>在安装 musl Void 前，请阅读本手册的 <a href="installation/./musl.html">musl</a> 一章，以了解软件的不兼容信息。</p>
<p>安装过程不需要连接网络，但还是非常建议在安装过程中连接网络以下载更新。ISO 镜像包含了安装系统所需要的数据，可以在无网络连接时安装。</p>
<h2 id="下载安装镜像"><a class="header" href="#下载安装镜像">下载安装镜像</a></h2>
<p>最近的 live 镜像和 rootfs 压缩包可以从 https://repo-default.voidlinux.org/live/current/ 下载，也可以从<a href="https://docs.voidlinux.org/xbps/repositories/mirrors/index.html">其他镜像</a>下载。以日期排列的历史发布可以在 https://repo-default.voidlinux.org/live/ 找到。</p>
<h2 id="验证镜像"><a class="header" href="#验证镜像">验证镜像</a></h2>
<p>每个镜像发布目录都包含两个用来验证镜像的文件。一个 <code>sha256sum.txt</code> 文件包含了镜像的校验和，可以用来验镜像的完整性。另有一个 <code>sha256sum.sig</code> 文件，用来检查校验和的真实性。</p>
<p>有必要验证镜像的完整性和真实性，因此建议也下载 <code>sha256sum.txt</code> 和 <code>sha256sum.sig</code> 两个文件。</p>
<h3 id="验证镜像完整性"><a class="header" href="#验证镜像完整性">验证镜像完整性</a></h3>
<p>你可以用 <a href="https://man.voidlinux.org/sha256sum.1">sha256sum(1)</a> 和上述的 <code>sha256sum.txt</code> 文件验证下载文件的完整性。下面的命令会检查你已下载镜像的完整性：</p>
<pre><code>$ sha256sum -c --ignore-missing sha256sum.txt
void-live-x86_64-musl-20170220.iso: OK
</code></pre>
<p>以上输出说明镜像没有损坏。</p>
<h3 id="验证数字签名"><a class="header" href="#验证数字签名">验证数字签名</a></h3>
<p>强烈建议在使用镜像前，先验证镜像的签名，确保镜像文件没有被篡改。</p>
<p>目前镜像都由用于发布的 siginfy 密钥签名。如果你已经在使用 Void 系统，你可以从 <code>void-release-keys</code> 软件包获取密钥，XBPS。你还需要 <a href="https://man.voidlinux.org/signify.1">signify(1)</a> 或 <a href="https://man.voidlinux.org/minisign.1">minisign(1)</a> 的拷贝；在 Void 系统上，它们分别由 <code>outils</code> 或 <code>minisign</code> 软件包提供。</p>
<p>在不是 Void Linux 的 Linux 发行版上获取 <code>signify</code>：</p>
<ul>
<li>在 Arch Linux 和基于 Arch 的发行版上，安装 <code>signify</code> 软件包。</li>
<li>在 Debian 和基于 Debian 的发行版上，安装 <code>signify-openbsd</code> 软件包。</li>
<li>为你的的发行版安装<a href="https://repology.org/project/signify-openbsd/versions">这里</a>列出的软件包。</li>
<li>在 macOS 上，用 homebrew 安装 <code>signify-osx</code>。</li>
</ul>
<p><code>minisign</code> 可执行程序一般由同名的软件包提供，即使没有 WSL 或 MinGW 也应该可以在 Windows 上安装。</p>
<p>如果你不在使用 Void Linux，也有必要从<a href="https://github.com/void-linux/void-packages/tree/master/srcpkgs/void-release-keys/files/">我们的 Git 仓库</a>取得相应的签名密钥。</p>
<p>取得了密钥后就可以用 <code>sha256sum.sig</code> 和 <code>sha256sum.txt</code> 文件检验镜像文件。首先你需要验证 <code>sha256sum.txt</code> 文件的正确性。</p>
<p>下面的例子演示了 <code>sha256sum.txt</code> 文件的校验 
对于 20210930 图像。   首先，使用 <code>signify</code>  ： </p>
<pre><code>$ signify -V -p /etc/signify/void-release-20210930.pub -x sha256sum.sig -m sha256sum.txt
Signature Verified
</code></pre>
<p>其次，用 <code>minisign</code>：</p>
<pre><code>$ minisign -V -p /etc/signify/void-release-20210930.pub -x sha256sum.sig -m sha256sum.txt
Signature and comment signature verified
Trusted comment: timestamp:1634597366	file:sha256sum.txt
</code></pre>
<p>最后，你需要检查镜像文件的校验和，于 <code>sha256sum.txt</code> 中的校验和做比较。你可以利用 <a href="https://man.voidlinux.org/md5.1">sha256(1)</a> 工具，此程序依然来自 <code>outils</code> 软件包。下面演示如何验证 20210930 <code>x86_64</code> 镜像：</p>
<pre><code>$ sha256 -C sha256sum.txt void-live-x86_64-20210930.iso
(SHA256) void-live-x86_64-20210930.iso: OK
</code></pre>
<p>另外，如果你无法使用 <code>sha256</code> 工具，你可以计算 SHA256 哈希，比如用 <a href="https://man.voidlinux.org/sha256sum.1">  sha256sum(1)  </a> 计算哈希，然后用 <code>sha256sum.txt</code> 中的值比较：</p>
<pre><code>$ sha256sum void-live-x86_64-20210930.iso
45b75651eb369484e1e63ba803a34e9fe8a13b24695d0bffaf4dfaac44783294  void-live-x86_64-20210930.iso
$ grep void-live-x86_64-20210930.iso sha256sum.txt
SHA256 (void-live-x86_64-20210930.iso) = 45b75651eb369484e1e63ba803a34e9fe8a13b24695d0bffaf4dfaac44783294
</code></pre>
<p>如果验证过程没有产生期望中的“OK”状态，不要使用这个镜像！请警告 Void Linux 团队，附上你取得该镜像的地址和你检验镜像的方法，我们会跟进此事。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="live-安装程序"><a class="header" href="#live-安装程序">Live 安装程序</a></h1>
<p>Void 提供的 live 安装器镜像包括一组基础工具、安装器程序和安装全新 Void 系统需要的软件包。Live 镜像可以用来修复无法引导或正常运行的系统。</p>
<p><code>glibc</code> 和 <code>musl</code> 都有 <code>x86_64</code> 镜像，但只有 <code>glibc</code> 支持 <code>i686</code> 架构。Live 安装程序不支持其他架构，其他架构的用户需要用 rootfs 压缩包安装，或者手动安装。</p>
<h2 id="安装程序镜像"><a class="header" href="#安装程序镜像">安装程序镜像</a></h2>
<p>Void 发布两种镜像：base 镜像和 xfce 桌面镜像，推荐 Linux 新手尝试功能更完善的 xfce 桌面镜像。高手们往往会倾向于用 base 镜像安装系统，只安装他们需要的软件包。</p>
<h3 id="base-镜像"><a class="header" href="#base-镜像">base 镜像</a></h3>
<p>base 镜像提供了能用来安装 Void 系统的，最小化的软件包集合。这些基础软件包仅够用来配置新机器、升级系统和从仓库里安装其他软件包。</p>
<h3 id="xfce-镜像"><a class="header" href="#xfce-镜像">Xfce 镜像</a></h3>
<p>xfce 桌面镜像包括完整的桌面环境、Web 浏览器和自带的基本工具。 与 base 镜像的唯一区别是它增加了软件包和服务。 </p>
<p>包括一下软件:</p>
<ul>
<li><strong>窗口管理器:</strong> xfwm4</li>
<li><strong>文件管理器:</strong> Thunar</li>
<li><strong>Web 浏览器:</strong> Firefox</li>
<li><strong>终端:</strong> xfce4-terminal</li>
<li><strong>文本编辑器:</strong> Mousepad</li>
<li><strong>图片查看器:</strong> Ristretto</li>
<li><strong>其他:</strong> Bulk rename, Orage Globaltime, Orage Calendar, Task Manager, Parole
Media Player, Audio Mixer, MIME type editor, Application finder</li>
</ul>
<p>xfce 映像的安装过程与 base 映像基本相同，除了在安装时你必须选择 <code>Local</code> 作为软件源。 若你选择了 <code>Network</code> 源，安装程序将下载并安装最新版本的 base 系统，live 镜像中将不包含任何其他软件包。</p>
<h2 id="无障碍支持"><a class="header" href="#无障碍支持">无障碍支持</a></h2>
<p>所有的Void安装程序图像都支持控制台的屏幕阅读器 <a href="https://man.voidlinux.org/espeakup.8">espeakup</a> 还有控制台盲文显示驱动 <a href="https://man.voidlinux.org/brltty.1">brltty</a>。这些服务可以在启动时通过按启动程序菜单中的 <code>s</code> 来启用无障碍支持。在基于 UEFI 的系统上，GRUB 是引导程序，当菜单可用时，它将播放双音鸣叫。在基于 BIOS 的系统和传统/兼容模式的 UEFI 系统上，SYSLINUX 是引导程序，不播放钟声。SYSLINUX 还需要在按下 <code>s</code> 后按下回车键。热键 <code>r</code> 也会在支持无障碍的情况下启动，但会将实时 ISO 加载到 RAM 中。</p>
<p>在启动到激活了无障碍支持的安装程序镜像后，如果检测到有多个声卡，一个简短的音频菜单允许选择用于屏幕阅读器的声卡。当听到所需声卡的提示音时，按回车键来选择它。</p>
<p>如果在安装程序中选择了 <code>Local</code> 安装源，<code>espeakup</code> 和 <code>brltty</code> 也将被安装，并且如果在 Live 环境中启用，也将在安装的系统上启用。</p>
<p>xfce 安装镜像也支持图形化的读屏器 <code>orca</code> 。这可以通过按 <code>Win + R</code> 并输入 <code>orca -r</code> 来启用。如果选择了 <code>Local</code> 安装源，Orca 也将在安装到系统上。</p>
<h2 id="内核-command-line-参数"><a class="header" href="#内核-command-line-参数">内核 Command-line 参数</a></h2>
<p>Void 安装程序镜像支持几个内核 command-line 参数，这些参数可以改变 Live 系统的行为。参见<a href="https://github.com/void-linux/void-mklive#kernel-command-line-parameters">the void-mklive README for a full list</a> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="准备安装介质"><a class="header" href="#准备安装介质">准备安装介质</a></h1>
<p><a href="installation/live-images/../index.html#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F">下载安装镜像</a>后，必须将镜像写入可引导的媒介，比如 U 盘、SD 卡或者 CD/DVD。</p>
<h2 id="在-linux-上创建可引导-u-盘或-sd-卡"><a class="header" href="#在-linux-上创建可引导-u-盘或-sd-卡">在 Linux 上创建可引导 U 盘或 SD 卡</a></h2>
<h3 id="确认设备"><a class="header" href="#确认设备">确认设备</a></h3>
<p>在写入镜像前，先确认你要写入的设备。你可以用 <a href="https://man.voidlinux.org/man8/fdisk.8">fdisk(8)</a>。插入存储设备后，用下面的命令识别设备的路径：</p>
<pre><code># fdisk -l
Disk /dev/sda: 7.5 GiB, 8036286464 bytes, 15695872 sectors
Disk model: Your USB Device's Model
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
</code></pre>
<p>上例中，输出显示 USB 设备在 <code>/dev/sda</code>。在 Linux 上，USB 设备的路径一般都是 <code>/dev/sdX</code>（X 是数字），SD 卡一般都是 <code>/dev/mmcblkX</code>，具体路径取决于设备。如果你不确定你设备的路径，你可以用型号和空间大小（上例中是 <code>7.5GiB</code>）来辨识。</p>
<p>确认你要用的设备之后，确保你的设备 <strong>没有</strong> 被挂载，用 <a href="https://man.voidlinux.org/man8/umount.8">umount(8)</a> 卸载设备：</p>
<pre><code># umount /dev/sdX
umount: /dev/sdX: not mounted.
</code></pre>
<h3 id="写入-live-镜像"><a class="header" href="#写入-live-镜像">写入 live 镜像</a></h3>
<p>命令 <a href="https://man.voidlinux.org/man1/dd.1">dd(1)</a>  可以用来将 live 镜像拷贝到存储设备上。用 <code>dd</code>，将 live 镜像写入：</p>
<p><strong>警告！</strong>: 这会删除设备上的所有数据，一定要小心。</p>
<pre><code># dd bs=4M if=/path/to/void-live-ARCH-DATE-VARIANT.iso of=/dev/sdX
90+0 records in
90+0 records out
377487360 bytes (377 MB, 360 MiB) copied, 0.461442 s, 818 MB/s
</code></pre>
<p>在完成写入（或写入失败）之前，<code>dd</code> 不会打印出任何信息。该命令可能需要几分钟或更长时间执行，取决于具体设备。如果你使用 GNU coreutils <code>dd</code>，你可以添加 <code>status=progress</code> 选项，让 <code>dd</code> 在写入过程中输出信息。</p>
<p>最后，在断开与设备连接前，确保数据已完全写入：</p>
<pre><code>$ sync
</code></pre>
<p>写入的数据、写入的文件量、写入速率取决于具体的设备和你选择的 live 镜像。</p>
<h2 id="烧录-cd-或-dvd"><a class="header" href="#烧录-cd-或-dvd">烧录 CD 或 DVD</a></h2>
<p>任何一个光盘烧录应用应该都可以写入 <code>.iso</code> 文件到 CD 或 DVD 上。可以用这些自由软件应用（跨平台支持可能不尽相同）：</p>
<ul>
<li><a href="https://wiki.gnome.org/Apps/Brasero/">Brasero</a></li>
<li><a href="https://userbase.kde.org/K3b">K3B</a></li>
<li><a href="https://docs.xfce.org/apps/xfburn/start">Xfburn</a></li>
</ul>
<p>注意，用 CD 或 DVD 时，live 会话反应会比用 U 盘或硬盘时迟钝一点。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分区说明"><a class="header" href="#分区说明">分区说明</a></h1>
<p>在现代 Linux 发行版上的分区一般都很简单，但 GPT 和 UEFI 引导的引入让事情变得复杂了一点。为你的新系统创建分区表时，你需要一个根文件系统分区、一个交换分区，可能还需要额外一到两个分区用于引导。</p>
<p>注意，如果已经初始化过硬盘了，<code>cfdisk</code> 界面顶部会显示分区布局已经存在：MBR 会显示 <code>Label: dos</code>，GPT 会显示 <code>Label: gpt</code>。如果你想要在运行安装器前删除分区表，用 <code>wipefs(8)</code> 。或者你可以手动运行 <code>cfdisk(8)</code>，加上 <code>-z</code> 选项来使用未初始化的分区布局；<code>cfdisk</code> 会在进入主界面前询问你标签类型。</p>
<p>下面的章节将详述分区配置选项：</p>
<h2 id="bios-系统说明"><a class="header" href="#bios-系统说明">BIOS 系统说明</a></h2>
<p>如果你使用 BIOS 引导系统，建议创建 MBR 分区表。这会导致你最多只能创建 4 个（主）分区。</p>
<p>也可以在 BIOS 系统上用 GPT 分区表，但 GRUB 需要一个特殊的分区以引导系统，该分区必须是硬盘上第一个分区，大小 1MB，类型是 <code>BIOS boot</code>（GUID <code>21686148-6449-6E6F-744E-656564454649</code>）。不要在这个分区里创建任何文件系统，GRUB 会自行安装。</p>
<h2 id="uefi-系统说明"><a class="header" href="#uefi-系统说明">UEFI 系统说明</a></h2>
<p>UEFI 用户建议创建 GPT 分区表，GRUB 也需要一个特殊的分区在 UEFI 系统上引导。分区类型是 <code>EFI System</code>，文件系统是 <code>vfat</code>，并且挂载到 <code>/boot/efi</code>。分区大小可以在 200MB 到 1GB 之间。挂载这个分区后用 live 镜像安装，安装器会自动安装好引导程序。</p>
<h2 id="swap-分区"><a class="header" href="#swap-分区">Swap 分区</a></h2>
<p>严格说，交换分区不是必需的，但建议在小内存的系统上使用交换分区。如果你要使用休眠，交换分区是必需的。下面的表格是建议的交换分区大小。</p>
<div class="table-wrapper"><table><thead><tr><th>系统内存</th><th>建议交换分区大小</th><th>使用休眠时的交换分区大小</th></tr></thead><tbody>
<tr><td>&lt; 2GB</td><td>内存大小 2 的倍</td><td>内存大小的 3 倍</td></tr>
<tr><td>2-8GB</td><td>等于内存大小</td><td>内存大小的 2 倍</td></tr>
<tr><td>8-64GB</td><td>至少 4GB</td><td>内存大小的 1.5 倍</td></tr>
<tr><td>64GB</td><td>至少 4GB</td><td>不建议使用休眠</td></tr>
</tbody></table>
</div>
<h2 id="引导分区可选"><a class="header" href="#引导分区可选">引导分区（可选）</a></h2>
<p>在大部分现代系统上，独立的 <code>/boot</code> 分区不再必要。如果你想要用一个单独的引导分区，注意，Void 默认不会在更新内核后，自动删除旧的内核。另外，一般每个新版本内核都会比旧版本大一点，因此请灵活分配硬盘空间（比如，安装有 Linux 5.x <code>x86_64</code> 内核与 GRUB 的 <code>/boot</code> 需要大约 60MB）。</p>
<h2 id="其他分区"><a class="header" href="#其他分区">其他分区</a></h2>
<p>完全可以只用一个大根分区安装系统，但只要你愿意，你也可以创建其他分区。一个例子是为 <code>/home</code> 目录分出额外的分区，这样你在重装 Void（或其他发行版）时，你可以保留你用户目录中的数据和配置文件</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装指南"><a class="header" href="#安装指南">安装指南</a></h1>
<p><a href="installation/live-images/../index.html#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E5%AA%92%E4%BB%8B">下载</a>好 Void 镜像，<a href="installation/live-images/./prep.html">准备</a>好安装媒介后，就可以开始安装 Void Linux 了。</p>
<p>正式开始安装前，请确定你的机器是用 BIOS 还是 UEFI 引导开机，这会影响你的分区，详情参考<a href="installation/live-images/./partitions.html">分区说明</a>。</p>
<p>安装器脚本不支持这些功能：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Logical_volume_management">LVM</a></li>
<li><a href="https://en.wikipedia.org/wiki/Linux_Unified_Key_Setup">LUKS</a></li>
<li><a href="https://en.wikipedia.org/wiki/ZFS">ZFS</a></li>
</ul>
<h2 id="引导"><a class="header" href="#引导">引导</a></h2>
<p>从你的安装媒介上引导启动，如果你的内存够大，可以在引导界面上选择把整个镜像加载到内存中，这会花费一些时间，但可以加速整个安装过程。</p>
<p>引导好 live 镜像后，以 <code>root</code> 登录，密码是 <code>voidlinux</code>，运行：</p>
<pre><code># void-installer
</code></pre>
<p>下面的章节将详述安装器的每个界面：</p>
<h2 id="键盘"><a class="header" href="#键盘">键盘</a></h2>
<p>选择你键盘的映射；标准的“qwerty”键盘一般使用“us”映射。</p>
<h2 id="网络"><a class="header" href="#网络">网络</a></h2>
<p>选择你的主网络接口，如果你选择不使用 DHCP，你会被要求输入 IP 地址、网关和 DNS 服务器。</p>
<p>如果您选择无线网络接口，系统将提示您提供 SSID、加密类型(<code>wpa</code> 要么 <code>wep</code>), 和密码。果 <code>void-installer</code> 失败要连接到您的网络，您可能需要退出安装程序并进行配置手动使用 <a href="installation/live-images/../../config/network/wpa_supplicant.html">wpa_supplicant</a> 和 <a href="installation/live-images/../../config/network/index.html#dhcpcd">dhcpcd</a> 在继续之前。 </p>
<h2 id="安装源"><a class="header" href="#安装源">安装源</a></h2>
<p>要安装镜像上提供的软件包，选择 <code>Local</code>。或者你也可以选择 <code>Network</code>，来从 Void 仓库下载最新的软件包。</p>
<blockquote>
<p><strong>警告:</strong> 如果你要从 xfce 像上安装桌面环境，你<strong>必须</strong>选择 <code>Local</code> 安装源。</p>
</blockquote>
<h2 id="主机名"><a class="header" href="#主机名">主机名</a></h2>
<p>选择设备的主机名（全部小写，没有空格）。</p>
<h2 id="语言环境"><a class="header" href="#语言环境">语言环境</a></h2>
<p>设置你的地区，只有 glibc 有这个选项，因为 musl 目前不支持地区。</p>
<h2 id="时区"><a class="header" href="#时区">时区</a></h2>
<p>基于标准时区选择你的时区。</p>
<h2 id="root-密码"><a class="header" href="#root-密码">Root 密码</a></h2>
<p>输入并确认你新系统的 <code>root</code> 密码，密码不会在屏幕上显示出来。</p>
<h2 id="用户账户"><a class="header" href="#用户账户">用户账户</a></h2>
<p>选择一个登录账户（默认是 <code>void</code>）并为你的账户起一个描述性的名字。然后输入并确认新用户的密码，接下来你会被要求确认新用户的用户组。默认会将新用户加入 <code>wheel</code> 用户组，并有 <code>sudo</code> 权限。默认用户组和说明请查看<a href="installation/live-images/../../config/users-and-groups.html#default-groups">这里</a>。</p>
<p>登录名有一些限制，在
<a href="https://man.voidlinux.org/useradd.8#CAVEATS">useradd(8)</a>.</p>
<h2 id="引导程序"><a class="header" href="#引导程序">引导程序</a></h2>
<p>安装 Void 时，选择安装引导程序的硬盘，你可以选择 <code>none</code> 跳过这个步骤，然后在安装过程完成后手动安装引导程序。如果你选择自动安装引导程序，你会被要求选择是否要为 GRUB 菜单添加一个图形终端。</p>
<h2 id="分区"><a class="header" href="#分区">分区</a></h2>
<p>然后你需要为你的硬盘分区。Void 不提供预设分区方案，所以你需要用 <a href="https://man.voidlinux.org/cfdisk.8">cfdisk(8)</a> 手动分区。界面会展示硬盘的列表，选择你想要分区的硬盘，安装器会启动 <code>cfdisk</code>。记得在推出分区编辑器前写入分区表。</p>
<p>如果使用 UEFI，建议你选择 GPT 作为分区表，创建一个类型为 <code>EFI System</code> 的分区（通常大小是 200MB-1GB），该分区会被挂载到 <code>/boot/efi</code>。</p>
<p>如果使用 BIOS，建议你选择 MBR 作为分区表。进阶用户可能会想要用 GPT 作为分区表，记得为 GRUB <a href="installation/live-images/./partitions.html#bios%E7%B3%BB%E7%BB%9F%E8%AF%B4%E6%98%8E">创建一个特殊的 BIOS 分区</a></p>
<h2 id="文件系统"><a class="header" href="#文件系统">文件系统</a></h2>
<p>为每个你创建的分区创建文件系统。你会被要求为每个分区选择文件系统、是否创建文件系统和可用的挂载点。完成后选择 <code>Done</code>，返回主菜单。</p>
<p>如果使用 UEFI，创建一个 <code>vfat</code> 文件系统，挂载到 <code>/boot/efi</code>。</p>
<h2 id="检查设定"><a class="header" href="#检查设定">检查设定</a></h2>
<p>在继续之前，最好重审一下你的设定。使用右方向键选择设置按钮，按下 <code>&lt;enter&gt;</code>。程序会展示你的所有选择，以供检查。</p>
<h2 id="安装-1"><a class="header" href="#安装-1">安装</a></h2>
<p>在菜单上选择 <code>Install</code>，开始安装。安装器会创建所有选择的文件系统、安装基础系统软件包、生成 initramfs 并安装 GRUB2 引导器到引导分区。</p>
<p>这些步骤会自动进行，安装结束后你就可以重启进入新 Void Linux 了！</p>
<h2 id="安装之后"><a class="header" href="#安装之后">安装之后</a></h2>
<p>重启到新 Void 后，<a href="installation/live-images/../../xbps/index.html#updating">进行系统更新</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进阶安装指南"><a class="header" href="#进阶安装指南">进阶安装指南</a></h1>
<p>本章包含了特殊或复杂用例下安装过程的指南。</p>
<h2 id="章节内容"><a class="header" href="#章节内容">章节内容</a></h2>
<ul>
<li><a href="installation/guides/./chroot.html">通过 chroot 安装 Void (x86 or x86_64)</a></li>
<li><a href="installation/guides/./fde.html">使用全盘加密安装 Void</a></li>
<li><a href="installation/guides/./zfs.html">在 ZFS 文件系统上安装 Void</a></li>
<li><a href="installation/guides/./arm-devices/index.html">ARM 设备</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="通过-chroot-安装x86--x86_64--aarch64"><a class="header" href="#通过-chroot-安装x86--x86_64--aarch64">通过 chroot 安装（x86 / x86_64 / aarch64）</a></h1>
<p>本指南详述了通过 chroot 在 x86、x86_64 或 aarch64 架构的平台上安装 Void 的过程。您不必很了解用 chroot 安装 Linux 的过程，但您应该对 Linux 操作系统足够熟悉。本指南可以用来指导一个“典型”的 Void 安装过程，使用一块 SATA / IDE / USB 磁盘上的一个分区。每个步骤都可以按需调整，比如开启<a href="installation/guides/./fde.html">全盘加密</a>，使得安装过程不那么“典型”。</p>
<p>Void 提供两种安装方法：<strong>XBPS 方法</strong>在宿主系统上运行<a href="installation/guides/../../xbps/index.html">XBPS 包管理器</a>，安装基础系统；<strong>ROOTFS 方法</strong>通过解压 ROOTFS 压缩包来安装基础系统。</p>
<p><strong>XBPS 方法</strong>要求宿主系统上安装了 XBPS。宿主系统可以是已经安装好的 Void、一个官方 <a href="installation/guides/../live-images/prep.html">live 镜像</a>或是安装了<a href="installation/guides/../../xbps/troubleshooting/static.html">静态连接的 XBPS</a>的任何 Linux。</p>
<p><strong>ROOTFS 方法</strong>只要求宿主系统可以进入 Linux chroot，且安装了 <a href="https://man.voidlinux.org/tar.1">tar(1)</a> 和 <a href="https://man.voidlinux.org/xz.1">xz(1)</a>。如果你要从其他发行版上安装 Void，推荐这个方法。</p>
<h2 id="准备文件系统"><a class="header" href="#准备文件系统">准备文件系统</a></h2>
<p>给<a href="installation/guides/../live-images/partitions.html">硬盘分好区</a>，并用 <a href="https://man.voidlinux.org/mke2fs.8">mke2fs(8)</a>、<a href="https://man.voidlinux.org/mkfs.xfs.8">mkfs.xfs(8)</a>、<a href="https://man.voidlinux.org/mkfs.btrfs.8">mkfs.btrfs(8)</a> 或其他文件系统必须的工具将分区格式化。</p>
<p>也可以用 <a href="https://man.voidlinux.org/mkfs.vfat.8">mkfs.vfat(8)</a> 创建 FAT32 分区。但是由于 FAT 文件系统的种种缺陷，只应该在没有其他选择时创建 FAT 分区（比如 EFI 系统分区）。</p>
<p>Live 镜像上可以使用 <a href="https://man.voidlinux.org/cfdisk.8">cfdisk(8)</a> 和 <a href="https://man.voidlinux.org/fdisk.8">fdisk(8)</a> 分区，但你可能会想用 <a href="https://man.voidlinux.org/gdisk.8">gdisk(8)</a>（在软件包 <code>gptfdisk</code> 中）或 <a href="https://man.voidlinux.org/parted.8">parted(8)</a>。</p>
<p>对于 UEFI 引导系统，一定要创建 EFI 系统分区（ESP）。ESP 的分区类型应该是“EFI System”（代号 <code>EF00</code>），用 <a href="https://man.voidlinux.org/mkfs.vfat.8">mkfs.vfat(8)</a> 格式化为 FAT32 文件系统。</p>
<p>如果你不确定要创建什么分区，创建一个 1GB 的 “EFI System”（代号 <code>EF00</code>）分区，再用剩余的空间创建一个“Linux Filesystem”（代号 <code>8300</code>）分区。</p>
<p>分别把这两个分区格式化为 FAT32 和 ext4：</p>
<pre><code># mkfs.vfat /dev/sda1
# mkfs.ext4 /dev/sda2
</code></pre>
<h3 id="创建新根分区并挂载文件系统"><a class="header" href="#创建新根分区并挂载文件系统">创建新根分区并挂载文件系统</a></h3>
<p>本指南假设新的根文件系统被挂载到 <code>/mnt</code>。你可能会想要将它挂载到其他地方。</p>
<p>如果使用 UEFI，将 EFI 系统分区挂载为 <code>/mnt/boot/efi</code>。</p>
<p>例如，如果将 <code>/dev/sda2</code> 挂载为 <code>/</code>，<code>/dev/sda1</code> 是 EFI 系统分区：</p>
<pre><code># mount /dev/sda2 /mnt/
# mkdir -p /mnt/boot/efi/
# mount /dev/sda1 /mnt/boot/efi/
</code></pre>
<p>用 <a href="https://man.voidlinux.org/mkswap.8">mkswap(8)</a> 按需初始化交换空间。</p>
<h2 id="基础系统安装"><a class="header" href="#基础系统安装">基础系统安装</a></h2>
<p>请选择两种方法之一，跟随对应小节的指导。</p>
<p>如果在 aarch64 平台上安装，除了 <code>base-system</code>，还必须安装一个内核软件包，比如 <code>linux</code> 是 Void 提供的最新稳定版本的内核软件包。</p>
<h3 id="xbps-方法"><a class="header" href="#xbps-方法">XBPS 方法</a></h3>
<p>选择一个<a href="installation/guides/../../xbps/repositories/mirrors/index.html">镜像</a>，根据你想要安装的系统类型,<strong>选择<a href="installation/guides/../../xbps/repositories/index.html#the-main-repository">合适的 URL</a></strong>。方便起见可以将这个 URL 保存为一个 shell 变量。比如，如果是安装一个 glibc 系统：</p>
<pre><code># REPO=https://repo-default.voidlinux.org/current
</code></pre>
<p>同时还需要告诉 XBPS 要安装的系统的架构。可用的选项有 PC 上的 <code>x86_64</code>、<code>x86_64-musl</code>、<code>i686</code> 或者 <code>aarch64</code>。例如：</p>
<pre><code># ARCH=x86_64
</code></pre>
<p>这个架构必须与你当前的操作系统兼容，但不需要完全一致。如果你的宿主是 x86_64 操作系统，上述三种架构（无论 musl 还是 glibc）都可以安装，但 i686 宿主只能安装 i686 版本。</p>
<p>将 RSA 密钥从安装介质复制到要安装系统的目录。</p>
<pre><code># mkdir -p /mnt/var/db/xbps/keys
# cp /var/db/xbps/keys/* /mnt/var/db/xbps/keys/
</code></pre>
<p>用 <a href="https://man.voidlinux.org/xbps-install.1">xbps-install</a> 安装 <code>base-system</code> 元软件包</p>
<pre><code># XBPS_ARCH=$ARCH xbps-install -S -r /mnt -R &quot;$REPO&quot; base-system
</code></pre>
<h3 id="rootfs-方法"><a class="header" href="#rootfs-方法">ROOTFS 方法</a></h3>
<p>根据你要安装的架构，<a href="https://voidlinux.org/download/#download-installable-base-live-images-and-rootfs-tarballs">下载 ROOTFS 压缩包</a>。</p>
<p>解压压缩包到新设置的文件系统：</p>
<pre><code># tar xvf void-&lt;...&gt;-ROOTFS.tar.xz -C /mnt
</code></pre>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<p>除了《安装基础系统（仅限 ROOTFS 方法）》一节，指南剩余的部分都适用于 XBPS 和 ROOTFS 两种方法。</p>
<h3 id="进入-chroot"><a class="header" href="#进入-chroot">进入 Chroot</a></h3>
<p><a href="https://man.voidlinux.org/xchroot.1">xchroot(1)</a>  (来自 <code>xtools</code>) 可以用来设置和进入 chroot。另外，这也可以<a href="installation/guides/../../config/containers-and-vms/chroot.html#manual-method">手动完成</a>.。</p>
<pre><code># xchroot /mnt /bin/bash
</code></pre>
<h3 id="安装基础系统仅限-rootfs-方法"><a class="header" href="#安装基础系统仅限-rootfs-方法">安装基础系统（仅限 ROOTFS 方法）</a></h3>
<p>因为 ROOTFS 镜像是其构建时的快照，其中的软件包一般都有所滞后，而且不包含完整的 <code>base-system</code>，需要更新包管理器并安装 <code>base-system</code>：</p>
<pre><code>[xchroot /mnt] # xbps-install -Su xbps
[xchroot /mnt] # xbps-install -u
[xchroot /mnt] # xbps-install base-system
[xchroot /mnt] # xbps-remove base-voidstrap
</code></pre>
<h3 id="安装配置"><a class="header" href="#安装配置">安装配置</a></h3>
<p><a href="installation/guides/../../config/locales.html">locales</a>.
在 <code>/etc/hostname</code> 中指定 hostname。检查一下 <a href="installation/guides/../../config/rc-files.html#rcconf"><code>/etc/rc.conf</code></a> 中的选项。如果安装 glibc 版本，编辑 <code>/etc/default/libc-locales</code>，按需取消掉 <a href="installation/guides/../../config/locales.html">locale</a> 前的注释</p>
<p><a href="https://man.voidlinux.org/nvi.1">nvi(1)</a> 在 chroot 中可用，但你此时可能希望安装您喜欢的文本编辑器</p>
<p>对于 glibc 构建，使用以下命令生成语言环境文件： </p>
<pre><code>[xchroot /mnt] # xbps-reconfigure -f glibc-locales
</code></pre>
<h3 id="设置-root-密码"><a class="header" href="#设置-root-密码">设置 Root 密码</a></h3>
<p><a href="installation/guides/../../config/users-and-groups.html">设置至少一个超级用户</a>)。其他用户可以稍后配置，但必须设置一个 root 密码，或是设置一个有 <a href="https://man.voidlinux.org/sudo.8">sudo(8)</a> 权限的新账户。</p>
<p>要设置 root 密码，请运行： </p>
<pre><code>[xchroot /mnt] # passwd
</code></pre>
<h3 id="配置-fstab"><a class="header" href="#配置-fstab">配置 fstab</a></h3>
<p>可以通过拷贝 <code>/proc/mounts</code> 文件，从当前已挂载的文件系统，自动生成 <a href="https://man.voidlinux.org/fstab.5">fstab(5)</a> 文件：</p>
<pre><code>[xchroot /mnt] # cp /proc/mounts /etc/fstab
</code></pre>
<p>删掉 <code>/etc/fstab</code> 中代表 <code>proc</code>、<code>sys</code>、<code>devtmpfs</code>、<code>pts</code> 的行。.</p>
<p>分别用对应的 UUID 代替 <code>fstab</code> 中的 <code>/dev/sdXX</code>、<code>/dev/nvmeXnYpZ</code> 等文件系统名称。UUID 可以通过运行 <a href="https://man.voidlinux.org/blkid.8">blkid(8)</a> 找到。用 UUID 定位文件系统，可以确保系统能找到文件系统；有时，同一个文件系统可能会被赋予不同的名称，比如从 USB 引导启动时，此时就很有必要用 UUID 定位文件系统。有时，除非物理增加或移除硬盘，硬盘总能被被赋予相同的名字，此时就没有必要使用 UUID 定位文件系统。但我们建议在 <code>fstab</code> 中，始终用 UUID 代替文件系统的名称定位文件系统。</p>
<p>配置 <a href="https://man.voidlinux.org/fsck.8">fsck(8)</a> 的行为，把 <code>/</code> 一行末尾的 0 改为 <code>1</code>。把其他行末尾的 0 改为 <code>2</code>。</p>
<p>比如，之前例子中的分区方案会产生这样的 <code>fstab</code>：</p>
<pre><code>/dev/sda1       /boot/efi   vfat    rw,relatime,[...]       0 0
/dev/sda2       /           ext4    rw,relatime             0 0
</code></pre>
<p>用 <code>blkid</code> 输出的信息，修改 <code>/etc/fstab</code> 为：</p>
<pre><code>UUID=6914[...]  /boot/efi   vfat    rw,relatime,[...]       0 2
UUID=dc1b[...]  /           ext4    rw,relatime             0 1
</code></pre>
<p>注意，<code>/proc/mounts</code> 的输出结果每列之间只有一个空格。为了方便阅读，示例中的文本经过对齐处理。</p>
<p>增加一行，在内存中挂载 <code>/tmp</code></p>
<pre><code>tmpfs           /tmp        tmpfs   defaults,nosuid,nodev   0 0
</code></pre>
<p>如果要使用交换空间，增加 swap 分区：</p>
<pre><code>UUID=1cb4[...]  swap        swap    rw,noatime,discard      0 0
</code></pre>
<h2 id="安装-grub"><a class="header" href="#安装-grub">安装 GRUB</a></h2>
<p>用 <a href="https://www.gnu.org/software/grub/manual/grub/html_node/Installing-GRUB-using-grub_002dinstall.html">grub-install</a> 在引导磁盘上安装 GRUB。</p>
<p><strong>在 BIOS 电脑上</strong>，安装软件包 <code>grub</code>。然后运行 <code>grub-install /dev/sdX</code>，<code>/dev/sdX</code> 是你要安装 GRUB 的硬盘（不是分区），例如：</p>
<pre><code>[xchroot /mnt] # xbps-install grub
[xchroot /mnt] # grub-install /dev/sda
</code></pre>
<p><strong>在 UEFI 电脑上</strong>，根据你的架构,安装 <code>grub-x86_64-efi</code> 或 <code>grub-i386-efi</code> 或 <code>grub-arm64-efi</code>，然后运行 <code>grub-install</code>，可以指定一个引导器标签（手动选择引导设备时，你的电脑固件可能会使用这个标签）：</p>
<pre><code>[xchroot /mnt] # xbps-install grub-x86_64-efi
[xchroot /mnt] # grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=&quot;Void&quot;
</code></pre>
<h3 id="grub-安装疑难解答"><a class="header" href="#grub-安装疑难解答">GRUB 安装疑难解答</a></h3>
<p>如果不能使用 EFI 变量，执行 <code>grub-install</code> 命令时，增加 <code>--no-nvram</code> 选项。</p>
<h4 id="在可移除介质上安装或不兼容的-uefi-系统"><a class="header" href="#在可移除介质上安装或不兼容的-uefi-系统">在可移除介质上安装或不兼容的 UEFI 系统</a></h4>
<p>并非所有系统都有标准完整的 UEFI 实现。某些情况下，有必要“糊弄”固件，让固件用默认备用地址引导启动。这种情况下，或是在可移除硬盘（比如 USB）上安装系统时，执行 <code>grub-install</code> 命令时，增加 <code>--removable</code> 选项。</p>
<p>另外，用 <a href="https://man.voidlinux.org/mkdir.1">mkdir(1)</a> 创建 <code>/boot/efi/EFI/boot</code> 目录，将安装好的 GRUB 可执行文件拷贝到新创建的目录中，GRUB 可执行文件一般在 <code>/boot/efi/void/grubx64.efi</code>（可执行文件的地址可以用 <a href="https://man.voidlinux.org/efibootmgr.8">efibootmgr(8)</a> 找到）：</p>
<pre><code>[xchroot /mnt] # mkdir -p /boot/efi/EFI/boot
[xchroot /mnt] # cp /boot/efi/EFI/Void/grubx64.efi /boot/efi/EFI/boot/bootx64.efi
</code></pre>
<h2 id="善后"><a class="header" href="#善后">善后</a></h2>
<p>用 <a href="https://man.voidlinux.org/xbps-reconfigure.1">xbps-reconfigure(1)</a> 确保所有安装的软件包都正确配置了：</p>
<pre><code>[xchroot /mnt] # xbps-reconfigure -fa
</code></pre>
<p>这会使 <a href="https://man.voidlinux.org/dracut.8">dracut(8)</a> 生成 initramfs，使 GRUB 生成配置。</p>
<p>至此，安装已经完成。退出 chroot 并重启电脑：</p>
<pre><code>[xchroot /mnt] # exit
# umount -R /mnt
# shutdown -r now
</code></pre>
<p>首次引导进入 Void 系统后，<a href="installation/guides/../../xbps/index.html#updating">更新系统</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全盘加密安装"><a class="header" href="#全盘加密安装">全盘加密安装</a></h1>
<p><strong>警告</strong>: 你的硬盘的信息和其他信息可能不同，所以要确保它是正确的。</p>
<h2 id="分区-1"><a class="header" href="#分区-1">分区</a></h2>
<p>启动 live 镜像并登录</p>
<p>用 <a href="https://man.voidlinux.org/cfdisk">cfdisk</a> 在磁盘上创建一个物理分区，并将其标记为 bootable 。对于一个MBR系统，分区布局应该如下。</p>
<pre><code># fdisk -l /dev/sda
Disk /dev/sda: 48 GiB, 51539607552 bytes, 100663296 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x4d532059

Device     Boot Start       End   Sectors Size Id Type
/dev/sda1  *     2048 100663295 100661248  48G 83 Linux
</code></pre>
<p>UEFI 系统将需要磁盘有一个 GPT 磁盘标签和一个 EFI 系统分区。EFI 系统分区方面所需的大小可能因需求而异，但 100M 对大多数情况来说应该是足够的。对于EFI系统，分区布局如下。</p>
<pre><code># fdisk -l /dev/sda
Disk /dev/sda: 48 GiB, 51539607552 bytes, 100663296 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: EE4F2A1A-8E7F-48CA-B3D0-BD7A01F6D8A0

Device      Start       End   Sectors  Size Type
/dev/sda1    2048    264191    262144  128M EFI System
/dev/sda2  264192 100663262 100399071 47.9G Linux filesystem
</code></pre>
<h2 id="加密卷配置"><a class="header" href="#加密卷配置">加密卷配置</a></h2>
<p><a href="https://man.voidlinux.org/cryptsetup.8">Cryptsetup</a> 默认为 LUKS2 ，但 2.06 之前的 GRUB 版本只支持 LUKS1。</p>
<p>GRUB 只部分支持 LUKS2；具体来讲，只<a href="https://git.savannah.gnu.org/cgit/grub.git/commit/?id=365e0cc3e7e44151c14dd29514c2f870b49f9755">实现</a>了 PBKDF2 的密钥推导功能,，这<em>不是</em> LUKS2 使用的默认 KDF，即 Argon2i(<a href="https://savannah.gnu.org/bugs/?59409">GRUB Bug 59409</a>)。使用Argon2i的LUKS加密分区（以及其他KDF）不能被解密。由于这个原因，本指南只推荐使用LUKS1。</p>
<p>请记住，在EFI系统上，加密的卷将是 <code>/dev/sda2</code> ，因为 <code>/dev/sda1</code> 被EFI分区占用了。</p>
<pre><code># cryptsetup luksFormat --type luks1 /dev/sda1

WARNING!
========
This will overwrite data on /dev/sda1 irrevocably.

Are you sure? (Type uppercase yes): YES
Enter passphrase:
Verify passphrase:
</code></pre>
<p>一旦卷被创建，它就需要打开。用一个合适的名字代替 <code>voidvm</code> 。同样，在EFI系统上加密卷是 <code>/dev/sda2</code>。</p>
<pre><code># cryptsetup luksOpen /dev/sda1 voidvm
Enter passphrase for /dev/sda1:
</code></pre>
<p>一旦 LUKS 容器被打开，使用该分区创建 LVM 卷组。</p>
<pre><code># vgcreate voidvm /dev/mapper/voidvm
  Volume group &quot;voidvm&quot; successfully created
</code></pre>
<p>现在应该有名为 <code>voidvm</code> 的空卷组。</p>
<p>接下来，需要为该卷组创建逻辑卷。在这个例子中，我为 <code>/</code> 选择了 10G，为 <code>swap</code> 选择了 2G，并将其余的分配给 <code>/home</code>。</p>
<pre><code># lvcreate --name root -L 10G voidvm
  Logical volume &quot;root&quot; created.
# lvcreate --name swap -L 2G voidvm
  Logical volume &quot;swap&quot; created.
# lvcreate --name home -l 100%FREE voidvm
  Logical volume &quot;home&quot; created.
</code></pre>
<p>接下来，创建文件系统。下面的例子使用 XFS 作为作者的个人偏好。任何由 <a href="https://www.gnu.org/software/grub/manual/grub/grub.html#Features">GRUB 支持的文件系统</a> 的文件系统都可以工作。</p>
<pre><code># mkfs.xfs -L root /dev/voidvm/root
meta-data=/dev/voidvm/root       isize=512    agcount=4, agsize=655360 blks
...
# mkfs.xfs -L home /dev/voidvm/home
meta-data=/dev/voidvm/home       isize=512    agcount=4, agsize=2359040 blks
...
# mkswap /dev/voidvm/swap
Setting up swapspace version 1, size = 2 GiB (2147479552 bytes)
</code></pre>
<h2 id="安装系统"><a class="header" href="#安装系统">安装系统</a></h2>
<p>接下来，设置 chroot 并安装基本系统。</p>
<pre><code># mount /dev/voidvm/root /mnt
# mkdir -p /mnt/home
# mount /dev/voidvm/home /mnt/home
</code></pre>
<p>在 UEFI 系统中，EFI 系统分区也需要挂载。</p>
<pre><code># mkfs.vfat /dev/sda1
# mkdir -p /mnt/boot/efi
# mount /dev/sda1 /mnt/boot/efi
</code></pre>
<p>将 RSA 密钥从安装介质复制到目标根目录：</p>
<pre><code># mkdir -p /mnt/var/db/xbps/keys
# cp /var/db/xbps/keys/* /mnt/var/db/xbps/keys/
</code></pre>
<p>在我们进入 chroot 完成配置之前，我们进行实际的安装。不要忘记为你要安装的系统类型使用适当的<a href="installation/guides/../../xbps/repositories/index.html">镜像源 URL</a>。</p>
<pre><code># xbps-install -Sy -R https://repo-default.voidlinux.org/current -r /mnt base-system lvm2 cryptsetup grub
[*] Updating `https://repo-default.voidlinux.org/current/x86_64-repodata' ...
x86_64-repodata: 1661KB [avg rate: 2257KB/s]
130 packages will be downloaded:
...
</code></pre>
<p>UEFI 系统的软件包选择略有不同。UEFI 系统的安装命令将如下。</p>
<pre><code># xbps-install -Sy -R https://repo-default.voidlinux.org/current -r /mnt base-system cryptsetup grub-x86_64-efi lvm2
</code></pre>
<p>完成后，我们可以用 <a href="https://man.voidlinux.org/xchroot.1"><code>xchroot(1)</code></a>（来自 <code>xtools</code>）进入chroot，完成配置。另外，也可以<a href="installation/guides/../../config/containers-and-vms/chroot.html#manual-method">手动 chroot</a>。</p>
<pre><code># xchroot /mnt
[xchroot /mnt] # chown root:root /
[xchroot /mnt] # chmod 755 /
[xchroot /mnt] # passwd root
[xchroot /mnt] # echo voidvm &gt; /etc/hostname
</code></pre>
<p>以及，仅适用于 glibc 系统的配置：</p>
<pre><code>[xchroot /mnt] # echo &quot;LANG=en_US.UTF-8&quot; &gt; /etc/locale.conf
[xchroot /mnt] # echo &quot;en_US.UTF-8 UTF-8&quot; &gt;&gt; /etc/default/libc-locales
[xchroot /mnt] # xbps-reconfigure -f glibc-locales
</code></pre>
<h3 id="文件系统配置"><a class="header" href="#文件系统配置">文件系统配置</a></h3>
<p>下一步是编辑 <code>/etc/fstab</code>，这将取决于你如何配置和命名你的文件系统。在这个例子中，该文件是这样的：</p>
<pre><code># &lt;file system&gt;	   &lt;dir&gt; &lt;type&gt;  &lt;options&gt;             &lt;dump&gt;  &lt;pass&gt;
tmpfs             /tmp  tmpfs   defaults,nosuid,nodev 0       0
/dev/voidvm/root  /     xfs     defaults              0       0
/dev/voidvm/home  /home xfs     defaults              0       0
/dev/voidvm/swap  swap  swap    defaults              0       0
</code></pre>
<p>UEFI 系统也有一个 EFI 系统分区的条目。</p>
<pre><code>/dev/sda1	/boot/efi	vfat	defaults	0	0
</code></pre>
<h3 id="grub-配置"><a class="header" href="#grub-配置">GRUB 配置</a></h3>
<p>接下来，配置 GRUB 以解锁文件系统。 添加以下行到 <code>/etc/default/grub</code>:</p>
<pre><code>GRUB_ENABLE_CRYPTODISK=y
</code></pre>
<p>接下来，需要对内核进行配置以找到加密的设备。首先，找到该设备的 UUID。</p>
<pre><code>[xchroot /mnt] # blkid -o value -s UUID /dev/sda1
135f3c06-26a0-437f-a05e-287b036440a4
</code></pre>
<p>编辑 <code>/etc/default/grub</code> 中的 <code>GRUB_CMDLINE_LINUX_DEFAULT=</code> 行，并在其中加入 <code>rd.lvm.vg=voidvm rd.luks.uuid=&lt;UUID&gt;</code>。确保 UUID 与上面 <a href="https://man.voidlinux.org/blkid.8">blkid(8)</a>  命令的输出中发现的 <code>sda1</code> 设备的 UUID 一致。</p>
<h2 id="luks-密钥设置"><a class="header" href="#luks-密钥设置">LUKS 密钥设置</a></h2>
<p>为了避免在启动时输入两次密码，将配置一个密钥，在启动时自动解锁加密的卷。首先，生成一个随机密钥。</p>
<pre><code>[xchroot /mnt] # dd bs=1 count=64 if=/dev/urandom of=/boot/volume.key
64+0 records in
64+0 records out
64 bytes copied, 0.000662757 s, 96.6 kB/s
</code></pre>
<p>接下来，将密钥添加到加密卷中。</p>
<pre><code>[xchroot /mnt] # cryptsetup luksAddKey /dev/sda1 /boot/volume.key
Enter any existing passphrase:
</code></pre>
<p>改变权限以保护生成的密钥。</p>
<pre><code>[xchroot /mnt] # chmod 000 /boot/volume.key
[xchroot /mnt] # chmod -R g-rwx,o-rwx /boot
</code></pre>
<p>这个密钥文件也需要被添加到 <code>/etc/crypttab</code>。同样，在 EFI 系统上这将是 <code>/dev/sda2</code>。</p>
<pre><code>voidvm   /dev/sda1   /boot/volume.key   luks
</code></pre>
<p>然后需要在 initramfs 中包含密钥文件和 <code>crypttab</code>。在 <code>/etc/dracut.conf.d/10-crypt.conf</code> 创建一个新文件，内容如下：</p>
<pre><code>install_items+=&quot; /boot/volume.key /etc/crypttab &quot;
</code></pre>
<h2 id="完成系统安装"><a class="header" href="#完成系统安装">完成系统安装</a></h2>
<p>接下来，将引导程序安装到磁盘上。</p>
<pre><code>[xchroot /mnt] # grub-install /dev/sda
</code></pre>
<p>确保生成一个 initramfs。</p>
<pre><code>[xchroot /mnt] # xbps-reconfigure -fa
</code></pre>
<p>退出 <code>chroot</code>，卸载文件系统，并重新启动系统。</p>
<pre><code>[xchroot /mnt] # exit
# umount -R /mnt
# reboot
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全盘-zfs"><a class="header" href="#全盘-zfs">全盘 ZFS</a></h1>
<p>因为 Void 的安装程序不支持 ZFS，所以有必要通过 chroot 来安装。除了一些关于引导程序和 initramfs 支持的注意事项外，在 ZFS 根文件系统上安装 Void 与其他高级安装没有明显区别。<a href="https://zfsbootmenu.org">ZFSBootMenu</a> 是一个从头开始设计的引导程序，支持直接从 ZFS 池中启动 Linux 发行版。然而，也可以使用传统的引导程序与ZFS根文件系统。</p>
<h2 id="zfsbootmenu"><a class="header" href="#zfsbootmenu">ZFSBootMenu</a></h2>
<p>尽管它可以启动（并且可以在上面运行）各种各样的发行版，但 ZFSBootMenu 官方认为 Void 是一等的发行版。ZFSBootMenu 支持原生的 ZFS 加密，提供方便的恢复环境，可用于克隆先前的快照或在预启动环境中执行高级操作，并支持从任何可被现代 ZFS 驱动程序导入的池中启动。ZFSBootMenu 文档除其他内容外，还提供了几个从头开始安装 Void 系统的<a href="https://docs.zfsbootmenu.org/en/latest/guides/void-linux.html">步骤指南</a>。<a href="https://docs.zfsbootmenu.org/en/latest/guides/void-linux/uefi.html">UEFI 指南</a>描述了现代系统引导 Void 系统的过程。对于传统的 BIOS 系统，<a href="https://docs.zfsbootmenu.org/en/latest/guides/void-linux/syslinux-mbr.html">syslinux 指南</a>提供了类似的说明。</p>
<h2 id="传统引导程序"><a class="header" href="#传统引导程序">传统引导程序</a></h2>
<p>对于那些希望放弃 ZFSBootMenu 的人来说，可以用另一个引导程序来引导 Void 系统。为了避免不必要的复杂性，使用ZFSBootMenu 以外的引导程序的系统应该计划使用单独的 <code>/boot</code>，它位于ext4或xfs文件系统中。</p>
<h3 id="安装媒介"><a class="header" href="#安装媒介">安装媒介</a></h3>
<p>把 Void 安装到 ZFS 根目录下需要一个带有 ZFS 驱动的安装介质。可以从官方构建自定义镜像 <a href="https://github.com/void-linux/void-mklive">void-mklive</a> 提供命令行选项 <code>-p zfs</code> 到 <code>mklive.sh</code> 脚本。对于 <code>x86_64</code> 系统来说，获取一个预先构建的 <a href="https://github.com/leahneukirchen/hrmpf/releases">hrmpf</a> 镜像可能更方便。这些镜像由 Void 团队成员维护，是标准 Void Live 镜像的扩展，包括预编译的ZFS模块和其他有用的工具。</p>
<h3 id="磁盘分区"><a class="header" href="#磁盘分区">磁盘分区</a></h3>
<p>在启动一个支持ZFS的实时镜像后，对你的<a href="installation/guides/../live-images/partitions.html">磁盘进行分区</a>。分区指南中的注意事项也适用于ZFS安装，除了</p>
<ul>
<li>
<p>引导分区应该被认为是必要的，除非你打算使用 <code>gummiboot</code>，它期望您的 EFI 系统分区将安装在 <code>/boot</code>. （这里不讨论这种替代配置。）</p>
</li>
<li>
<p>除了任何 EFI 系统分区、GRUB BIOS 启动分区、swap 分区或启动分区之外，磁盘的其余部分通常应该是一个类型代码为BF00 的单一分区，该分区将专门用于一个 ZFS 池。在单个磁盘上创建单独的 ZFS 池没有任何好处。</p>
</li>
</ul>
<p>根据需要，使用格式化 EFI 系统分区 <a href="https://man.voidlinux.org/mkfs.vfat.8">mkfs.vfat(8)</a> 和引导分区 使用 <a href="https://man.voidlinux.org/mke2fs.8">mke2fs(8)</a> 或 <a href="https://man.voidlinux.org/mkfs.xfs.8">mkfs.xfs(8)</a> 。 初始化任何 swap 空间 使用 <a href="https://man.voidlinux.org">mkswap(8)</a> 。 </p>
<blockquote>
<p>可以将 Linux 交换空间放在 ZFS zvol 上,尽管在高内存压力下可能会有内核锁死的风险。 本指南 在 zvol 上的交换空间问题上不采取任何立场。 然而，如果你想使用悬浮到磁盘（休眠），注意内核不能从存储在zvol上的内存镜像中恢复。 你需要一个专门的交换分区来使用休眠。除了这个注意事项之外，在使用ZFS根目录时，恢复一个暂停的映像不需要特别的考虑。</p>
</blockquote>
<h3 id="创建-zfs-池"><a class="header" href="#创建-zfs-池">创建 ZFS 池</a></h3>
<p>使用 <a href="https://man.voidlinux.org/zpool.8">zpool(8)</a> 在为其创建的分区上创建一个 ZFS 池 <code>/dev/disk/by-id/wwn-0x5000c500deadbeef-part3</code>:</p>
<pre><code># zpool create -f -o ashift=12 \
    -O compression=lz4 \
    -O acltype=posixacl \
    -O xattr=sa \
    -O relatime=on \
    -o autotrim=on \
    -m none zroot /dev/disk/by-id/wwn-0x5000c500deadbeef-part3
</code></pre>
<p>根据需要调整池（<code>-o</code>）和文件系统（<code>-O</code>）选项，并将分区标识符 <code>wwn-0x5000c500deadbeef-part3</code> 替换为要使用的实际分区的标识符。</p>
<blockquote>
<p>当添加磁盘或分区到 ZFS 池时，一般来说，最好通过在 <code>/dev/disk/by-id</code> 或（在UEFI系统上）<code>/dev/disk/by-partuuid</code> 中创建的符号链接来引用它们。这样，即使磁盘命名在某个时候发生变化，ZFS也会识别正确的分区。使用传统的设备节点如 <code>/dev/sda3</code> 可能会导致间歇性的导入失败。</p>
</blockquote>
<p>接下来，用一个临时的、备用的根路径导出并重新导入池子:</p>
<pre><code># zpool export zroot
# zpool import -N -R /mnt zroot
</code></pre>
<h3 id="创建初始文件系统"><a class="header" href="#创建初始文件系统">创建初始文件系统</a></h3>
<p>ZFS 池上的文件系统布局是灵活的。 但是，通常将操作系统根文件系统（“引导环境”）置于 ROOT 父级下：</p>
<pre><code># zfs create -o mountpoint=none zroot/ROOT
# zfs create -o mountpoint=/ -o canmount=noauto zroot/ROOT/void
</code></pre>
<p>在 <code>mountpoint=/</code> 的文件系统上设置 <code>canmount=noauto</code> 是非常有用的，因为它允许创建多个启动环境（这些环境可能是普通 Void 安装的克隆，也可能包含完全独立的发行版），而不用担心ZFS自动挂载会试图挂载一个而不是另一个。</p>
<p>为了将用户数据与操作系统分开，创建一个文件系统来存储主目录:</p>
<pre><code># zfs create -o mountpoint=/home zroot/home
</code></pre>
<p>可以根据需要创建其他文件系统</p>
<h3 id="挂载-zfs-层次结构"><a class="header" href="#挂载-zfs-层次结构">挂载 ZFS 层次结构</a></h3>
<p>所有的 ZFS 文件系统都应该安装在先前重新导入时建立的 <code>/mnt</code> 备用根目录下。在允许 ZFS 自动挂载其他所有的文件系统之前，先挂载纯手动的根文件系统：</p>
<pre><code># zfs mount zroot/ROOT/void
# zfs mount -a
</code></pre>
<p>在这一点上，整个 ZFS 层次结构应该被挂载并准备好安装。为了提高启动时的导入速度，在一个缓存文件中记录当前的池子配置是很有用的，Void 将使用这个文件来避免走遍整个设备层次结构来识别可导入的池子:</p>
<pre><code># mkdir -p /mnt/etc/zfs
# zpool set cachefile=/mnt/etc/zfs/zpool.cache zroot
</code></pre>
<p>在适当的地方挂载非 ZFS 文件系统。例如，如果 <code>/dev/sda2</code> 持有一个 ext4 文件系统，应该被挂载在<code>/boot</code>，而<code>/dev/sda1</code> 是 EFI 系统分区:</p>
<pre><code># mkdir -p /mnt/boot
# mount /dev/sda2 /mnt/boot
# mkdir -p /mnt/boot/efi
# mount /dev/sda1 /mnnt/boot/efi
</code></pre>
<h3 id="安装-2"><a class="header" href="#安装-2">安装</a></h3>
<p>在这一点上，普通的安装可以从标准 chroot 安装指南的 <a href="https://docs.voidlinux.org/installation/guides/chroot.html#base-installation">&quot;Base Installation&quot;
section</a> 部分进行。然而，在按照 <a href="https://docs.voidlinux.org/installation/guides/chroot.html#finalization">&quot;Finalization&quot; instructions</a> 的说明进行安装之前，要确保已经安装了zfs包，并且dracut被配置可以识别ZFS根文件系统：</p>
<pre><code>[xchroot /mnt] # mkdir -p /etc/dracut.conf.d
[xchroot /mnt] # cat &gt; /etc/dracut.conf.d/zol.conf &lt;&lt;EOF
nofsck=&quot;yes&quot;
add_dracutmodules+=&quot; zfs &quot;
omit_dracutmodules+=&quot; btrfs resume &quot;
EOF
[xchroot /mnt] # xbps-install zfs
</code></pre>
<p>最后，按照 &quot;Finalization&quot; instructions 并重新启动进入您的新系统。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arm-设备"><a class="header" href="#arm-设备">ARM 设备</a></h1>
<p>Void Linux 为几种 ARM 设备提供了软件包和镜像。在这些设备上安装 Void 可以通过几种方式进行：</p>
<ul>
<li>
<p><a href="installation/guides/arm-devices/%E9%A2%84%E6%9E%84%E5%BB%BA%E7%9A%84%E9%95%9C%E5%83%8F">预构建的镜像</a>: 可以直接在 SD 卡或其他存储介质上刷镜像，但它给你的分区布局有限，如果你想增加分区的大小，需要手动扩展。</p>
</li>
<li>
<p><a href="installation/guides/arm-devices/index.html#tarball-%E5%AE%89%E8%A3%85">Tarball 安装</a>: PLATFORMFS 和 ROOTFS tarballs，可以提取到先前准备好的分区方案。</p>
</li>
<li>
<p><a href="installation/guides/arm-devices/index.html#chroot-%E5%AE%89%E8%A3%85">Chroot 安装</a>: 遵循 <a href="https://docs.voidlinux.org/installation/guides/chroot.html">chroot 指南</a>中概述的大部分步骤。</p>
</li>
</ul>
<p>本指南还概述了主要针对此类设备的<a href="installation/guides/arm-devices/index.html#%E9%85%8D%E7%BD%AE">配置步骤</a>。</p>
<p>由于本指南中的大多数命令将在外部存储上运行，因此在移除设备之前运行 <a href="https://man.voidlinux.org/sync.1">sync(1)</a> 是很重要的。</p>
<h2 id="安装-3"><a class="header" href="#安装-3">安装</a></h2>
<p>如果你要在 &quot;<a href="installation/guides/arm-devices/./platforms.html">支持的平台</a>&quot; 页面中所涉及的 ARM 设备上安装 Void Linux，请确保彻底阅读其部分。</p>
<h3 id="预构建的镜像"><a class="header" href="#预构建的镜像">预构建的镜像</a></h3>
<p>在<a href="installation/guides/arm-devices/../../index.html">下载并验证镜像</a>后，可以用 <a href="https://man.voidlinux.org/cat.1">cat(1)</a> 、<a href="https://man.voidlinux.org/pv.1">pv(1)</a> 或 <a href="https://man.voidlinux.org/dd.1">dd(1)</a> 将其写入相关的媒体。例如，将其闪存到位于 <code>/dev/mmcblk0</code> 的SD卡上。</p>
<pre><code># dd if=&lt;image&gt;.img of=/dev/mmcblk0 bs=4M status=progress
</code></pre>
<h3 id="自定义分区布置"><a class="header" href="#自定义分区布置">自定义分区布置</a></h3>
<p>定制安装 -- 例如，定制分区布局 -- 需要一个更复杂的过程。两个可用的选项是：</p>
<ul>
<li><a href="installation/guides/arm-devices/index.html#tarball-%E5%AE%89%E8%A3%85">Tarball 安装</a>; 和</li>
<li><a href="installation/guides/arm-devices/index.html#chroot-%E5%AE%89%E8%A3%85">Chroot 安装</a>.</li>
</ul>
<p>要为这些安装方法准备存储，需要对存储介质进行分区，然后将分区挂载到正确的挂载点。</p>
<p>ARM 设备的常用分区方案需要至少两个分区，在使用 MS-DOS 分区表格式化的驱动器上：</p>
<ul>
<li>一个格式化为 <code>FAT32</code>，分区类型为 <code>0c</code>，将挂载在 <code>/boot</code>；</li>
<li>一个可以被格式化为任何 Linux 可以启动的文件系统，例如 ext4，它将被挂载到 <code>/</code> 。如果你使用的是 SD 卡，你可以用 <code>^has_journal</code> 选项创建 ext4 文件系统 - 这可以禁用日志，这可能会增加硬盘的寿命，但代价是数据丢失的可能性更高。</li>
</ul>
<p>有各种各样的工具可用于分区，比如
<a href="https://man.voidlinux.org/cfdisk.8">cfdisk(8)</a>.</p>
<p>为了访问新创建的文件系统，有必要对其进行挂载。本指南假定第二个分区将被挂载在 <code>/mnt</code> 上，但你也可以把它挂载在其他地方。要挂载这些文件系统，你可以使用下面的命令，将设备名称替换为适合你的设置的名称:</p>
<pre><code># mount /dev/mmcblk0p2 /mnt
# mkdir /mnt/boot
# mount /dev/mmcblk0p1 /mnt/boot
</code></pre>
<h4 id="tarball-安装"><a class="header" href="#tarball-安装">Tarball 安装</a></h4>
<p>首先，为你想要的平台<a href="installation/guides/arm-devices/../../index.html">下载并验证</a> PLATFORMFS 或 ROOTFS tarball，并准备好你的存储介质。然后，使用 <a href="https://man.voidlinux.org/tar.1">tar(1)</a> 将 tarball 解压到文件系统中：</p>
<pre><code># tar xvfp &lt;image&gt;.tar.xz -C /mnt
</code></pre>
<h4 id="chroot-安装"><a class="header" href="#chroot-安装">Chroot 安装</a></h4>
<p>也可以进行 chroot 安装，如果使用的是不兼容的架构（如 i686）的计算机，这可能需要 <code>qemu-user-static</code> 软件包与 <code>binfmt-support</code> 或 <code>proot</code> 软件包一起进行。本指南解释了如何使用 <code>qemu-&lt;platform&gt;-static</code> 程序和<a href="https://man.voidlinux.org/proot.1">proot(1)</a> 的 <code>qemu-user-static</code>。</p>
<p>首先，准备好你的存储介质。然后，按照 XBPS chroot 安装或 ROOTFS chroot 安装步骤，使用适当的架构和基础包，其中一些在 &quot;<a href="installation/guides/arm-devices/./platforms.html">支持的平台</a>&quot; 部分列出。</p>
<p>最后，按照 <a href="installation/guides/arm-devices/../chroot.html#%E9%85%8D%E7%BD%AE">chroot 配置步骤</a>进行操作，但不要使用 <a href="https://man.voidlinux.org/chroot.1">chroot(1)</a> 命令<a href="installation/guides/arm-devices/../chroot.html#%E8%BF%9B%E5%85%A5-chroot">进入 chroot</a>，而是使用下面的命令，对于 armv6l 和 armv7l 设备，将 <code>&lt;platform&gt;</code> 替换为 <code>arm</code> ，对于 aarch64 设备，替换为<code>aarch64</code>。</p>
<pre><code># proot -q qemu-&lt;platform&gt;-static -r /mnt -w /
</code></pre>
<h2 id="配置-1"><a class="header" href="#配置-1">配置</a></h2>
<p>需要遵循一些额外的配置步骤，以保证系统的工作。配置一个<a href="installation/guides/arm-devices/../../../config/graphical-session/index.html">图形 session</a>应该正常工作。</p>
<h3 id="登录"><a class="header" href="#登录">登录</a></h3>
<p>对于预先建立的镜像和 tarball 安装，<code>root</code> 用户密码是 <code>voidlinux</code> 。</p>
<h3 id="fstab"><a class="header" href="#fstab">fstab</a></h3>
<p><code>/boot</code> 分区应该被添加到 <code>/etc/fstab</code> 中，并有一个类似于下面的条目。没有这个条目也可以启动，但是在这种情况下更新内核包可能会导致故障，比如无法找到内核模块，而这些模块对于无线连接等功能是必不可少的。如果你没有使用SD卡，用适当的设备路径替换 <code>/dev/mmcblk0p1</code>。</p>
<pre><code>/dev/mmcblk0p1 /boot vfat defaults 0 0
</code></pre>
<h3 id="系统时间"><a class="header" href="#系统时间">系统时间</a></h3>
<p>Void Linux 支持的一些 ARM 设备没有电池供电的实时时钟（RTC），这意味着一旦断电，它们将无法跟踪时间。在浏览网页或使用软件包管理器时，这个问题可能表现为 HTTPS 错误。可以使用 <a href="https://man.voidlinux.org/date.1">date(1)</a> 工具手动设置时间。为了在以后的启动中解决这个问题，请安装并启用一个 <a href="installation/guides/arm-devices/../../../config/date-time.html#ntp">NTP 客户端</a>。此外，还可以安装 <code>fake-hwclock</code> 软件包，它提供了 <code>fake-hwclock</code> 服务。<a href="https://man.voidlinux.org/fake-hwclock.8">fake-hwclock(8)</a> 定期在配置文件中存储当前时间，并在启动时恢复它，从而导致对当前时间更好的初始近似，即使没有网络连接。</p>
<p><strong>警告</strong>: 2020-03-16 之前的镜像可能有一个问题，即默认的 NTP 守护程序 <code>chrony</code> 包的安装不完整，系统将缺少<code>chrony</code> 用户。这可以从 <a href="https://man.voidlinux.org/getent.1">getent(1)</a> 命令的输出中检查出来，如果它不存在，将是空的。</p>
<pre><code>$ getent group chrony
chrony:x:997
</code></pre>
<p>为了解决这个问题，有必要重新配置 <code>chrony</code> 包装使用 
<a href="https://man.voidlinux.org/xbps-reconfigure">xbps-reconfigure(1)</a>.</p>
<h3 id="图形-session"><a class="header" href="#图形-session">图形 session</a></h3>
<p><code>xf86-video-fbturbo</code> 软件包提供了 <code>xf86-video-fbdev</code> 软件包中的 <a href="installation/guides/arm-devices/../../../config/graphical-session/xorg.html#ddx">DDX Xorg 驱动程序</a>的修改版本，该版本针对 ARM 设备进行了优化。这可以用于那些缺乏更多特定驱动程序的设备。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="所支持的平台"><a class="header" href="#所支持的平台">所支持的平台</a></h1>
<h2 id="树莓派"><a class="header" href="#树莓派">树莓派</a></h2>
<p>所有 Raspberry Pi 变种的 <code>rpi-kernel</code> 包都是由 Raspberry Pi 基金会的内核树构建的，它应该可以实现所有主线内核所没有的特殊功能。RPi 内核包也有自己的头文件包，<code>rpi-kernel-headers</code> 。如果你想使用任何 DKMS 包，就应该安装这些包。Void 提供的 <code>rpi-base</code> 元包可以安装相关的 <code>rpi-kernel</code> 和 <code>rpi-firmware</code> 包。这些包一起实现了 Wi-Fi 和蓝牙功能。</p>
<p>传递给内核的 <a href="installation/guides/arm-devices/../../../config/kernel.html#cmdline">command line</a> 参数在 <code>rootfs/boot/cmdline.txt</code> 文件中。一些相关的参数在<a href="https://www.raspberrypi.org/documentation/configuration/cmdline-txt.md">官方文档</a>中有所记载。</p>
<h3 id="支持的机型"><a class="header" href="#支持的机型">支持的机型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>机型</th><th>架构</th></tr></thead><tbody>
<tr><td>1 A, 1 B, 1 A+, 1 B+, Zero, Zero W, Zero WH</td><td>armv6l</td></tr>
<tr><td>2 B</td><td>armv7l</td></tr>
<tr><td>3 B, 3 A+, 3 B+, Zero 2W, 4 B, 400</td><td>aarch64</td></tr>
</tbody></table>
</div>
<blockquote>
<p>可以在 RPi 3 上运行 armv7l 图像，因为 RPi 3 的 CPU 同时支持 Armv8 和 Armv7 指令集。这些图像的区别在于，armv7l 图像提供了一个32位系统，而 arch64 图像提供了一个 64 位系统。</p>
</blockquote>
<h3 id="启用硬件-rng-设备"><a class="header" href="#启用硬件-rng-设备">启用硬件 RNG 设备</a></h3>
<p>默认情况下，<a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator">HWRNG</a> 设备不被系统使用，which may result in the random devices taking long to seed on boot。如果你想启动 sshd 并期望能够立即连接，这可能会很烦人。</p>
<p>为了解决这个问题，请安装 <code>rng-tools</code> 软件包，并<a href="installation/guides/arm-devices/../../../config/services/index.html#enabling-services">启用</a> <code>rngd</code> 服务，它使用 <code>/dev/hwrng</code> 设备作为 <code>/dev/random</code> 的 seed。</p>
<h3 id="图形-session-1"><a class="header" href="#图形-session-1">图形 session</a></h3>
<p><code>mesa-dri</code> 软件包包含了所有 Raspberry Pi 变种的驱动，可以与 <a href="installation/guides/arm-devices/../../../config/graphical-session/xorg.html#modesetting">modesetting Xorg
driver</a> 驱动或 <a href="installation/guides/arm-devices/../../../config/graphical-session/wayland.html">Wayland</a> 一起使用。</p>
<h3 id="硬件"><a class="header" href="#硬件">硬件</a></h3>
<p>更多配置信息可以在 Raspberry Pi 基金会的<a href="https://www.raspberrypi.org/documentation/configuration/">官方文档</a>中找到。<code>raspi-config</code> 工具不适用于 Void Linux，所以通常需要编辑 <code>/boot/config.txt</code> 文件。</p>
<h4 id="声音"><a class="header" href="#声音">声音</a></h4>
<p>要启用声音，请添加 <code>dtparam=audio=on</code> 到 <code>/boot/config.txt</code>. </p>
<h4 id="串口"><a class="header" href="#串口">串口</a></h4>
<p>要启用串口控制台登录，请<a href="installation/guides/arm-devices/../../../config/services/index.html">启用</a> <code>agetty-ttyAMA0</code> 服务。关于允许 root 登录的接口，见 <a href="https://man.voidlinux.org/securetty.5">securetty(5)</a>。关于启动时串口的配置，参考 <code>/boot/cmdline.txt</code> 中的内核命令行 - 特别是 <code>console=ttyAMA0,115200</code> 参数。</p>
<h3 id="i2c"><a class="header" href="#i2c">I2C</a></h3>
<p>为了启用 <a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> ，在 <code>/boot/config.txt</code> 中加入<code>device_tree_param=i2c_arm=on</code>，在 <code>/boot/cmdline.txt</code> 中加入 <code>bcm2708.vc_i2c_override=1</code> 。然后创建一个 <a href="https://man.voidlinux.org/modules-load.8">modules-load(8)</a> <code>.conf</code> 文件，内容如下:</p>
<pre><code>i2c-dev
</code></pre>
<p>最后，安装 <code>i2c-tools</code> 包并使用 <a href="https://man.voidlinux.org/i2cdetect.8">i2cdetect(8)</a> 来验证你的配置。它应该显示:</p>
<pre><code>$ i2cdetect -l
i2c-1i2c          bcm2835 I2C adapter                 I2C adapter
</code></pre>
<h3 id="内存-cgroup"><a class="header" href="#内存-cgroup">内存 cgroup</a></h3>
<p><code>rpi-kernel</code> 软件包的内核<a href="https://github.com/raspberrypi/linux/commit/9b0efcc1ec497b2985c6aaa60cd97f0d2d96d203#diff-f1d702fa7c504a2b38b30ce6bb098744">默认禁用了内存 cgroup</a>。</p>
<p>这破坏了使用容器的工作负载。因此，如果你想在 Raspberry Pi 上使用容器，你需要在 <code>/boot/cmdline.txt</code> 中加入<code>cgroup_enable=memory</code> 来启用内存 cgroups 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="musl"><a class="header" href="#musl">musl</a></h1>
<p><a href="https://musl.libc.org/">musl</a> 是一个致力于轻量、快速、简单、准确的 libc 实现。</p>
<p>Void 官方支持 musl，所有目标平台（除了 i686 的二进制包）都有使用 musl 的版本。另外，所有官方仓库中的兼容软件包不但有 glibc 的版本，还有 musl 链接的二进制文件。</p>
<p>目前，我们提供 musl 的 nonfree 和 debug 子仓库，但不提供 multilib 子仓库。</p>
<h2 id="不兼容的软件"><a class="header" href="#不兼容的软件">不兼容的软件</a></h2>
<p>musl 对标准的兼容克制而有限，许多常用的平台特定的扩展都没有实现，因此，许多软件需要修改才能编译或正常运行。Void 开发者们会为这些软件打增强可移植性 / 正确性的补丁，希望这些补丁能被软件上游接受。</p>
<p>专有软件往往只支持 glibc 系统，部分专有软件可以通过 <a href="installation/../config/external-applications.html#flatpak">flatpak</a> 在 musl 系统上运行。具体而言，<a href="installation/../config/graphical-session/graphics-drivers/nvidia.html">NVIDIA 的私有驱动</a>不支持 musl，评估硬件兼容性时应该考虑到这一点。</p>
<h3 id="glibc-chroot"><a class="header" href="#glibc-chroot">glibc chroot</a></h3>
<p>要求 glibc 的软件可以在 glibc <a href="installation/../config/containers-and-vms/chroot.html">chroot</a> 中运行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置-2"><a class="header" href="#配置-2">配置</a></h1>
<p>本章及其子章节提供有关配置 Void 系统的信息。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="软件包文档"><a class="header" href="#软件包文档">软件包文档</a></h1>
<p>Void Linux 中最常见的文档形式是 <a href="config/package-documentation/./man.html">man 手册页</a>。</p>
<p>许多软件包提供其他格式的文档，比如 HTML。这些文档一般可以在 <code>/usr/share/doc/&lt;package&gt;</code> 目录下找到。</p>
<p>大型的文档可能会被分割为单独的 <code>*-doc</code> 软件包，比如 <code>julia-doc</code>，这在编程语言、数据和大型的软件库中很常见。</p>
<p>除了上游提供的文档，软件包还可能携带由打包者贡献的、针对 Void 的文档，这些文档会被放在 <code>/usr/share/doc/&lt;package&gt;/README.voidlinux</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="手册页"><a class="header" href="#手册页">手册页</a></h1>
<p>许多 Void 软件包都提供了手册（'man'）页。<code>mdocml</code> 软件包包含了 <a href="https://mandoc.bsd.lv/">mandoc</a> Man 手册页工具组。</p>
<p>用 <a href="https://man.voidlinux.org/man.1">man(1)</a>  命令显示手册页：</p>
<pre><code>$ man chroot
</code></pre>
<p>手册页都隶属于下面这些<em>章节</em>：</p>
<ol>
<li>用户命令（程序）</li>
<li>系统调用</li>
<li>库调用</li>
<li>特殊文件（设备）</li>
<li>文件格式与配置文件</li>
<li>游戏</li>
<li>概览、惯例以及杂项</li>
<li>系统管理命令</li>
</ol>
<p>详情参见 <a href="https://man.voidlinux.org/man-pages.7">man-pages(7)</a>。</p>
<p>有些内容不同的手册页拥有相同的名字，它们属于不同的章节。你可以在执行 <code>man</code> 时指定章节：</p>
<pre><code>$ man 1 printf
</code></pre>
<p>用 <a href="https://man.voidlinux.org/man.conf.5">man.conf(5)</a> 配置 <code>man</code>。</p>
<p><code>mandoc</code> 工具组包含了用来搜索手册页的 <a href="https://man.voidlinux.org/apropos.1">apropos(1)</a>。可以用 <a href="https://man.voidlinux.org/makewhatis.8">makewhatis(8)</a> 命令来生成和更新 <code>apropos</code> 的数据库：</p>
<pre><code># makewhatis
$ apropos chroot
chroot(1) - run command or interactive shell with special root directory
xbps-uchroot(1) - XBPS utility to chroot and bind mount with Linux namespaces
xbps-uunshare(1) - XBPS utility to chroot and bind mount with Linux user namespaces
chroot(2) - change root directory
</code></pre>
<p><code>mdocml</code> 软件包提供了每天更新 <code>apropos</code> 数据库的 cron 任务：<code>/etc/cron.daily/makewhatis</code>。要使用这个功能，你需要安装并启用 <a href="config/package-documentation/../cron.html">cron 守护进程</a> 。</p>
<p>Void 默认不会安装开发与 POSIX 手册，但可以通过 <code>man-pages-devel</code> 与 <code>man-pages-posix</code> 软件包获得这些手册。</p>
<h2 id="本地化手册页"><a class="header" href="#本地化手册页">本地化手册页</a></h2>
<p><code>manpages-*</code> 软件包们提供了本地化的 Man 手册页，但使用这些 Man 手册页可能需要一些额外的配置。</p>
<h3 id="用-mdocml"><a class="header" href="#用-mdocml">用 mdocml</a></h3>
<p>如果使用了 <code>mdocml</code>，且设置应该应用于所有用户，那么必须将相关的路径添加到 <a href="https://man.voidlinux.org/man.conf.5">man.conf(5)</a>。例如，德语使用者会把这两行加入配置文件：</p>
<pre><code>/usr/share/man/de
/usr/share/man/de.UTF-8
</code></pre>
<p>另外，各用户可以导出 <code>MANPATH</code> 变量到自己的环境中，详见 <a href="https://man.voidlinux.org/man.1">man(1)</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="驱动"><a class="header" href="#驱动">驱动</a></h1>
<p>Void 在软件库中提供了一些固件包。有些固件只有在你启用了 <a href="config/../xbps/repositories/index.html#nonfree">nonfree</a> 软件库后才能使用。</p>
<h2 id="微码"><a class="header" href="#微码">微码</a></h2>
<p>微码在启动时由 BIOS 加载到 CPU 或 GPU 上，但以后可以由操作系统本身替换。微码的更新可以使 CPU 或 GPU 的行为被修改，以解决某些尚未发现的错误，而不需要更换硬件。</p>
<h3 id="intel"><a class="header" href="#intel">Intel</a></h3>
<p>安装英特尔微代码包，<code>intel-ucode</code>。这个包在非自由软件库中，必须<a href="config/../xbps/repositories/index.html">启用</a>它。安装这个包后，有必要重新生成你的 <a href="config/./kernel.html#kernel-hooks">initramfs</a>。对于后续的更新，微代码将被自动添加到 initramfs 中。</p>
<h3 id="amd"><a class="header" href="#amd">AMD</a></h3>
<p>安装 AMD 软件包，<code>linux-firmware-amd</code>，其中包含 AMD CPU 和 GPU 的微码。AMD CPU 和 GPU 将自动加载微码，不需要进一步配置</p>
<h3 id="确认"><a class="header" href="#确认">确认</a></h3>
<p><code>/proc/cpuinfo</code> 文件在微码下有一些信息，可以用来验证微码的更新。</p>
<h2 id="删除驱动"><a class="header" href="#删除驱动">删除驱动</a></h2>
<p>默认情况下，<code>linuxX.Y</code> 包和 <code>base-system</code> 包会安装一些固件包。没有必要删除未使用的固件包，但如果你想这样做，你可以配置 XBPS 来<a href="config/../xbps/advanced-usage.html#ignoring-packages">忽略</a>这些包，然后删除它们。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="本地化与翻译"><a class="header" href="#本地化与翻译">本地化与翻译</a></h1>
<p>要获取当前启用的语言环境列表，请运行 </p>
<pre><code>$ locale -a
</code></pre>
<h2 id="启用语言环境"><a class="header" href="#启用语言环境">启用语言环境</a></h2>
<p>要启用某个地区性语言，请取消注释或在以下文件中添加相关行
<code>/etc/default/libc-locales</code>和<a href="config/../xbps/index.html">强制重新配置</a>的相关行。
<code>glibc-locales</code>包。</p>
<h2 id="设置系统语言环境"><a class="header" href="#设置系统语言环境">设置系统语言环境</a></h2>
<p>在 <code>/etc/locale.conf</code> 中写 <code>LANG=xxxx</code></p>
<h2 id="应用程序语言环境"><a class="header" href="#应用程序语言环境">应用程序语言环境</a></h2>
<p>一些程序的翻译在一个单独的软件包中，必须安装才能使用它们。你可以在软件包库中<a href="config/../xbps/index.html">搜索</a>所需的语言（如 &quot;德语 &quot;或 &quot;葡萄牙语&quot;），并安装与你使用的应用程序相关的软件包。一个特别相关的情况是在安装 LibreOffice 套件中的单个软件包时，例如 <code>libreoffic-writer</code> ，它需要安装至少一个 <code>libreoffic-i18n-*</code> 软件包才能正常工作。在安装 <code>libreoffice</code> 元包时，会自动安装翻译包。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="用户和用户组"><a class="header" href="#用户和用户组">用户和用户组</a></h1>
<p><a href="https://man.voidlinux.org/useradd.8">useradd(8)</a>, <a href="https://man.voidlinux.org/userdel.8">userdel(8)</a> 和 <a href="https://man.voidlinux.org/usermod.8">usermod(8)</a> 命令分别用来添加、删除和修改用户。passwd(1)命令用来修改密码。</p>
<p><a href="https://man.voidlinux.org/groupadd.8">groupadd(8)</a> 、 <a href="https://man.voidlinux.org/groupdel.8">groupdel(8)</a> 和 <a href="https://man.voidlinux.org/groupmod.8">groupmod(8)</a> 命令分别用来添加、删除和修改组。<a href="https://man.voidlinux.org/groups.1">groups(1)</a> 命令列出一个用户所属的所有组。</p>
<h2 id="默认-shell"><a class="header" href="#默认-shell">默认 shell</a></h2>
<p>用户的默认shell可以用 <a href="https://man.voidlinux.org/chsh.1">chsh(1)</a> 来更改。</p>
<pre><code>$ chsh -s &lt;shell&gt; &lt;user_name&gt;
</code></pre>
<p><code>&lt;shell&gt;</code> 必须是指定的 shell 的路径 <code>/etc/shells</code> 或者输出 <code>chsh -l</code>，它提供了已安装 shell 的列表。</p>
<h2 id="sudo"><a class="header" href="#sudo">sudo</a></h2>
<p><a href="https://man.voidlinux.org/sudo.8">sudo(8)</a> 是默认安装的。但可能没有根据您的需要进行适当配置。如果你想使用它，请配置 sudo。。</p>
<p>以 root 身份使用 <a href="https://man.voidlinux.org/visudo.8">visudo(8)</a>  来编辑 <a href="https://man.voidlinux.org/sudoers.5">sudoers(5)</a> 文件。</p>
<p>请取消注释该行</p>
<pre><code>#%wheel ALL=(ALL) ALL
</code></pre>
<p>然后将用户添加到 <code>wheel</code> 用户组.</p>
<h2 id="默认用户组"><a class="header" href="#默认用户组">默认用户组</a></h2>
<p>Void Linux 默认定义的一些组</p>
<div class="table-wrapper"><table><thead><tr><th>Group</th><th>Description</th></tr></thead><tbody>
<tr><td><code>root</code></td><td>Complete access to the system.</td></tr>
<tr><td><code>bin</code></td><td>Unused - present for historical reasons.</td></tr>
<tr><td><code>sys</code></td><td>Unused - present for historical reasons.</td></tr>
<tr><td><code>kmem</code></td><td>Ability to read from <code>/dev/mem</code> and <code>/dev/port</code>.</td></tr>
<tr><td><code>wheel</code></td><td>Elevated privileges for specific system administration tasks.</td></tr>
<tr><td><code>tty</code></td><td>Access to TTY-like devices:</td></tr>
<tr><td></td><td><code>/dev/tty*</code>, <code>/dev/pts*</code>, <code>/dev/vcs*</code>.</td></tr>
<tr><td><code>tape</code></td><td>Access to tape devices.</td></tr>
<tr><td><code>daemon</code></td><td>System daemons that need to write to files on disk.</td></tr>
<tr><td><code>floppy</code></td><td>Access to floppy drives.</td></tr>
<tr><td><code>disk</code></td><td>Raw access to <code>/dev/sd*</code> and <code>/dev/loop*</code>.</td></tr>
<tr><td><code>lp</code></td><td>Access to printers.</td></tr>
<tr><td><code>dialout</code></td><td>Access to serial ports.</td></tr>
<tr><td><code>audio</code></td><td>Access to audio devices.</td></tr>
<tr><td><code>video</code></td><td>Access to video devices.</td></tr>
<tr><td><code>utmp</code></td><td>Ability to write to <code>/var/run/utmp</code>, <code>/var/log/wtmp</code></td></tr>
<tr><td></td><td>and <code>/var/log/btmp</code>.</td></tr>
<tr><td><code>adm</code></td><td>Unused - present for historical reasons. This group was</td></tr>
<tr><td></td><td>traditionally used for system monitoring, such as viewing</td></tr>
<tr><td></td><td>files in <code>/var/log</code>.</td></tr>
<tr><td><code>cdrom</code></td><td>Access to CD devices.</td></tr>
<tr><td><code>optical</code></td><td>Access to DVD/CD-RW devices.</td></tr>
<tr><td><code>mail</code></td><td>Used by some mail packages, e.g. <code>dma</code>.</td></tr>
<tr><td><code>storage</code></td><td>Access to removable storage devices.</td></tr>
<tr><td><code>scanner</code></td><td>Ability to access scanners.</td></tr>
<tr><td><code>network</code></td><td>Unused - present for historical reasons.</td></tr>
<tr><td><code>kvm</code></td><td>Ability to use KVM for virtual machines, e.g. via QEMU.</td></tr>
<tr><td><code>input</code></td><td>Access to input devices: <code>/dev/mouse*</code>, <code>/dev/event*</code>.</td></tr>
<tr><td><code>plugdev</code></td><td>Access to pluggable devices.</td></tr>
<tr><td><code>nogroup</code></td><td>System daemons that don't need to own any files.</td></tr>
<tr><td><code>usbmon</code></td><td>Access to <code>/dev/usbmon*</code>.</td></tr>
<tr><td><code>users</code></td><td>Ordinary users.</td></tr>
<tr><td><code>xbuilder</code></td><td>To use xbps-uchroot(1) with <code>xbps-src</code>.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="服务和守护进程---runit"><a class="header" href="#服务和守护进程---runit">服务和守护进程 - runit</a></h1>
<p>Void 使用 <a href="https://man.voidlinux.org/runit.8">runit(8)</a> 监督组件来运行系统服务和守护程序。</p>
<p>使用 runit 的一些优势包括：</p>
<ul>
<li>一个小的基础代码，可以更容易地审计错误和安全问题。 </li>
<li>每个服务都被赋予一个干净的进程状态，无论该服务是如何启动或重启：它将以相同的环境、资源限制、开放的文件描述符和控制终端启动。</li>
<li>可靠的服务日志记录工具，只要相关的服务在运行并写入日志，日志服务就会保持运行。</li>
</ul>
<p>如果你不需要一个程序持续运行，但希望它定期运行，你可以考虑使用 <a href="config/services/../cron.html">cron daemon</a></p>
<h2 id="章节内容-1"><a class="header" href="#章节内容-1">章节内容</a></h2>
<ul>
<li><a href="config/services/./user-services.html">每个用户的服务</a></li>
<li><a href="config/services/./logging.html">日志</a></li>
</ul>
<h2 id="服务目录"><a class="header" href="#服务目录">服务目录</a></h2>
<p>每个由 runit 管理的服务都有一个相关的<em>服务目录</em>。</p>
<p>一个服务目录只需要一个文件：一个名为 <code>run</code> 的可执行文件，这是希望在前台执行一个进程。</p>
<p>可选的，一个服务目录可以包含：</p>
<ul>
<li>一个名为 <code>check</code> 的可执行文件，它将被运行以检查服务是否启动和可用；如果 <code>check</code> 退出时为0，则认为它是可用的。</li>
<li>一个名为 <code>finish</code> 的可执行文件，它将在关机/进程停止时运行。</li>
<li>一个 <code>conf</code> 文件；它可以包含环境变量，并在 <code>run</code> 被引用。</li>
<li>一个名为的目录 <code>log</code>; pipe 将从 <code>run</code> 服务目录中的进程到输入的 <code>run</code> 过程中 <code>log</code> 目录。 </li>
</ul>
<p>当一个新的服务被创建时，在第一次运行时将会自动创建一个 <code>supervise</code> 文件夹。</p>
<h3 id="配置服务"><a class="header" href="#配置服务">配置服务</a></h3>
<p>大多数服务可以接受由服务目录中的 <code>conf</code> 文件设置的配置选项。这允许在不修改相关软件包提供的服务目录的情况下对服务进行定制。</p>
<p>检查服务文件以了解如何传递配置参数。少数服务在其 <code>conf</code> 文件中有一个 <code>OPTS=&quot;--value ...&quot;</code> 这样的字段。</p>
<p>要进行更复杂的定制，你应该<a href="config/services/index.html#%E7%BC%96%E8%BE%91%E6%9C%8D%E5%8A%A1">编辑该服务</a>。</p>
<h3 id="编辑服务"><a class="header" href="#编辑服务">编辑服务</a></h3>
<p>要编辑一个服务，首先要将其服务目录复制到一个不同的目录名下。否则， <a href="https://man.voidlinux.org/xbps-install.1">xbps-install(1)</a> 会覆盖服务目录。然后，根据需要编辑新的服务文件。最后，旧的服务应该被停止和禁用，而新的服务应该被启动。</p>
<h2 id="管理服务"><a class="header" href="#管理服务">管理服务</a></h2>
<h3 id="runsvdirs"><a class="header" href="#runsvdirs">Runsvdirs</a></h3>
<p><strong>runsvdir</strong> 是 <code>/etc/runit/runsvdir</code> 中的一个目录，它包含了以服务目录符号链接形式出现的启用的服务。在一个运行中的系统中，当前的 runsvdir 可以通过 <code>/var/service</code> 符号链接访问。</p>
<p><code>runit-void</code> 软件包带有两个 <code>runtvdirs</code> ，<code>single</code>和 <code>default</code>:</p>
<ul>
<li>
<p><code>single</code> 只是运行 <a href="https://man.voidlinux.org/sulogin.8">sulogin(8)</a>和 the
necessary steps to rescue your system. </p>
</li>
<li>
<p><code>default</code> 是运行系统的默认 runsvdir，除非[由内核命令行指定
(#引导不同的 runsvdir)。</p>
</li>
</ul>
<p>可以在 <code>/etc/runit/runsvdir/</code> 中创建额外的 runsvdirs.</p>
<p>参见 <a href="https://man.voidlinux.org/runsvdir.8">runsvdir(8)</a> 和 <a href="https://man.voidlinux.org/runsvchdir.8">runsvchdir(8)</a> 以获得更多信息。 </p>
<h4 id="引导不同的-runsvdir"><a class="header" href="#引导不同的-runsvdir">引导不同的 runsvdir</a></h4>
<p>要启动 <code>default</code> 以外的 runsvdir，可以在<a href="config/services/../kernel.html#cmdline">内核 comand-line</a>中加入所需的 runsvdir 的名称。作为一个例子，在内核命令行中加入 <code>single</code> 将启动 <code>single runsvdir</code>。</p>
<h3 id="基本用法"><a class="header" href="#基本用法">基本用法</a></h3>
<p>启动、停止、重启和获取一个服务的状态。</p>
<pre><code># sv up &lt;services&gt;
# sv down &lt;services&gt;
# sv restart &lt;services&gt;
# sv status &lt;services&gt;
</code></pre>
<p><code>&lt;services&gt;</code> 占位符可以是:</p>
<ul>
<li><code>/var/service/</code> 目录内的服务名称（服务目录名称）。</li>
<li>服务的完整路径。</li>
</ul>
<p>例如，下面的命令显示了一个特定服务和所有启用的服务的状态:</p>
<pre><code># sv status dhcpcd
# sv status /var/service/*
</code></pre>
<p>有关详细信息，请参阅 <a href="https://man.voidlinux.org/sv.8">sv(8)</a> </p>
<h4 id="启用服务"><a class="header" href="#启用服务">启用服务</a></h4>
<p>Void Linux 在 <code>/etc/sv/</code> 中为大多数守护程序提供了服务目录。</p>
<p>要在一个已启动的系统上启用一个服务，在 <code>/var/service/</code> 中创建一个服务目录的符号链接:</p>
<pre><code># ln -s /etc/sv/&lt;service&gt; /var/service/
</code></pre>
<p>如果系统目前没有运行，服务可以直接链接到 <code>default</code> 的 <a href="config/services/index.html#runsvdirs">runsvdir</a>:</p>
<pre><code># ln -s /etc/sv/&lt;service&gt; /etc/runit/runsvdir/default/
</code></pre>
<p>这将自动启动该服务。一旦一个服务被链接，它将总是在启动时启动，并在停止时重新启动，除非被管理员关闭。</p>
<p>为了防止一个服务在启动时启动，同时允许 runit 管理它，在其服务目录下创建一个名为 <code>down</code> 的文件:</p>
<pre><code># touch /etc/sv/&lt;service&gt;/down
</code></pre>
<p><code>down</code> 文件机制也使得禁用默认启用的服务成为可能，例如用于 ttys 1 到 6 的 <a href="https://man.voidlinux.org/agetty.8">agetty(8)</a> 服务。这样，影响这些服务的软件包更新（在这种情况下，<code>runit-void</code> 软件包）就不会重新启用它们。</p>
<h4 id="禁用服务"><a class="header" href="#禁用服务">禁用服务</a></h4>
<p>要禁用一个服务，从正在运行的 runsvdir 中删除符号链接:</p>
<pre><code># rm /var/service/&lt;service&gt;
</code></pre>
<p>或者，例如，从 <code>default</code> 的runsvdir，如果特定的 runsvdir 或系统目前没有运行:</p>
<pre><code># rm /etc/runit/runsvdir/default/&lt;service&gt;
</code></pre>
<h4 id="测试服务"><a class="header" href="#测试服务">测试服务</a></h4>
<p>要检查一个服务在被服务监督员启动时是否正常工作，在完全启用它之前运行一次:</p>
<pre><code># touch /etc/sv/&lt;service&gt;/down
# ln -s /etc/sv/&lt;service&gt; /var/service/
# sv once &lt;service&gt;
</code></pre>
<p>如果一切正常，删除 <code>down</code> 文件以启用服务。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="每个用户的服务"><a class="header" href="#每个用户的服务">每个用户的服务</a></h1>
<p>有时候，拥有针对用户的runit服务是很好的。例如，你可能想以当前用户的身份打开一个ssh隧道，运行一个虚拟机，或者以你的名义运行守护程序。最常见的方法是创建一个系统级服务，以你的用户身份运行<a href="https://man.voidlinux.org/runsvdir.8">runsvdir(8)</a> 。以便启动和监控个人目录中的服务</p>
<p>例如，你可以创建一个名为 <code>/etc/sv/runsvdir-&lt;username&gt;</code> 的服务，其 run` 如下，它应该是可执行的。</p>
<pre><code>#!/bin/sh

export USER=&quot;&lt;username&gt;&quot;
export HOME=&quot;/home/&lt;username&gt;&quot;

groups=&quot;$(id -Gn &quot;$USER&quot; | tr ' ' ':')&quot;
svdir=&quot;$HOME/service&quot;

exec chpst -u &quot;$USER:$groups&quot; runsvdir &quot;$svdir&quot;
</code></pre>
<p>在这个例子中，<a href="https://man.voidlinux.org/chpst.8">chpst(8)</a>  被用来以指定的用户身份启动一个新的 <a href="https://man.voidlinux.org/runsvdir.8">runsvdir(8)</a> 进程。<a href="https://man.voidlinux.org/chpst.8">chpst(8)</a> 不会自己读取组，而是期望用户列出所有由 <code>:</code> 隔的所需组。<code>id</code> 和 <code>tr</code> 管道被用来以 chpst(8) 理解的方式创建一个所有用户组的列表。注意，我们 export 了 <code>$USER</code> 和 <code>$HOME</code>，因为有些用户服务没有它们可能无法工作。</p>
<p>然后，用户可以在 <code>/home/&lt;username&gt;/service</code> 目录中创建新的服务或它们的符号链接。为了使用 <a href="https://man.voidlinux.org/sv.8">sv(8)</a> 命令控制服务，用户可以通过路径指定服务，如果 <code>SVDIR</code> 环境变量被设置为用户的服务目录，也可以通过名称指定服务。这在下面的例子中显示：</p>
<pre><code>$ sv status ~/service/*
run: /home/duncan/service/gpg-agent: (pid 901) 33102s
run: /home/duncan/service/ssh-agent: (pid 900) 33102s
$ SVDIR=~/service sv restart gpg-agent
ok: run: gpg-agent: (pid 19818) 0s
</code></pre>
<p>在你的 shell 配置文件中 export <code>SVDIR=~/service</code> 变量可能比较方便。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="日志"><a class="header" href="#日志">日志</a></h1>
<h2 id="syslog"><a class="header" href="#syslog">Syslog</a></h2>
<p>默认安装没有配备 syslog 守护程序。但是，在 Void 软件库里有 syslog 的实现。</p>
<h3 id="socklog"><a class="header" href="#socklog">Socklog</a></h3>
<p><a href="https://man.voidlinux.org/socklog.8">socklog(8)</a> 是 <a href="https://man.voidlinux.org/runit.8">runit(8)</a> 的作者提供的一个 syslog 实现。如果你不确定要使用哪种系统日志实现，就使用 socklog 。要启用它，请安装 <code>socklog-void</code> 软件包并启用 <code>socklog-unix</code> 和 <code>nanoklogd</code> 服务。确保没有其他的 syslog 守护程序在运行。</p>
<p>日志被保存在 <code>/var/log/socklog/</code> 的子目录中，可以用 <code>svlogtail</code> 来访问它们。</p>
<p>读取日志的权限仅限于 <code>root</code> 和属于 <code>socklog</code> 组的用户。 </p>
<h3 id="其他系统日志守护进程"><a class="header" href="#其他系统日志守护进程">其他系统日志守护进程</a></h3>
<p>Void 软件库还包括用于 <code>rsyslog</code> 和 <code>metalog</code>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rcconf-rclocal-还有-rcshutdown"><a class="header" href="#rcconf-rclocal-还有-rcshutdown">rc.conf, rc.local 还有 rc.shutdown</a></h1>
<p>文件 <code>/etc/rc.conf</code> 、<code>/etc/rc.local</code> 和 <code>/etc/rc.shutdown</code> 可以用来配置 Void 系统的某些部分。<code>rc.conf</code> 通常由 <code>void-installer</code> 配置。</p>
<h2 id="rcconf"><a class="header" href="#rcconf">rc.conf</a></h2>
<p>来源于 runit stage 1 和 3。这个文件可以用来设置变量，包括以下内容：</p>
<h3 id="键盘-1"><a class="header" href="#键盘-1">键盘</a></h3>
<p>指定在Linux控制台使用哪一个键盘类型。可用的键盘类型中列于 <code>/usr/share/kbd/keymaps</code> 如说：</p>
<pre><code>KEYMAP=fr
</code></pre>
<p>有关详细信息，请参阅 <a href="https://man.voidlinux.org/loadkeys.1">loadkeys(1)</a>.</p>
<h3 id="硬件时间"><a class="header" href="#硬件时间">硬件时间</a></h3>
<p>指定硬件时钟是设置为 UTC 还是本地时间。</p>
<p>默认情况下，它被设置为 <code>utc</code>。然而，Windows 将硬件时钟设置为本地时间，所以如果你用 Windows 进行双系统，你需要将Windows配置为使用UTC，或者将这个变量设置为 <code>localtime</code>。</p>
<p>有关详细信息，请参阅 <a href="https://man.voidlinux.org/hwclock.8">hwclock(8)</a>.</p>
<h3 id="字体"><a class="header" href="#字体">字体</a></h3>
<p>指定用于 Linux 控制台的字体。 可用字体列在 <code>/usr/share/kbd/consolefonts</code>。 例如：</p>
<pre><code>FONT=eurlatgr
</code></pre>
<p>有关详细信息，请参阅  <a href="https://man.voidlinux.org/setfont.8">setfont(8)</a>.</p>
<h2 id="rclocal"><a class="header" href="#rclocal">rc.local</a></h2>
<p>源于runit stage 2 。一个shell脚本，可以用来指定在登录前要做的配置。</p>
<h2 id="rcshutdown"><a class="header" href="#rcshutdown">rc.shutdown</a></h2>
<p>源于 runit stage 3。一个 shell 脚本，可以用来指定在关机时要完成的任务。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cron"><a class="header" href="#cron">Cron</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Cron">cron</a> 是按一定时间间隔运行程序的守护进程。运行的程序和时间间隔可以通过 <code>crontab</code> 文件设定，可以用 <a href="https://man.voidlinux.org/crontab.1">crontab(1)</a> 编辑 crontab 文件。以超级用户运行 <code>crontab -e</code> 编辑系统 crontab；否则就是编辑当前用户的 crontab。</p>
<p>Void 预设没有安装 cron 守护进程，但 Void 提供了多种 cron 实现，包括 <a href="https://github.com/cronie-crond/cronie/">cronie</a>、<a href="http://www.jimpryor.net/linux/dcron.html">dcron</a>、<a href="http://fcron.free.fr/">fcron</a>等等。</p>
<p>选择 cron 实现并安装，<a href="config/./services/index.html#enabling-services">启用</a>对应的服务。这些实现都提供了通用的 <code>crond</code> 服务，但使用它并没有什么好处，只会让你的系统设定更加困难。</p>
<p>作为标准 cron 实现的替代，你可以使用 <code>snooze</code> 软件包提供的 <a href="https://man.voidlinux.org/snooze.1">snooze(1)</a>，以及 <code>snooze-hourly</code>、<code>snooze-daily</code>、<code>snooze-weekly</code>、<code>snooze-monthly</code> 服务。这些服务对应 <code>/etc/cron.*</code> 中的目录。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="固态硬盘"><a class="header" href="#固态硬盘">固态硬盘</a></h1>
<p>安装后，您需要为固态驱动器启用 TRIM。 你可以通过运行检查哪些设备允许 TRIM： </p>
<pre><code>$ lsblk --discard
</code></pre>
<p>如果 DISC-GRAN（丢弃颗粒度）和 DISC-MAX（丢弃最大字节数）列非零，这意味着该块设备有 TRIM 支持。如果你的固态硬盘分区没有显示支持 TRIM，请确认你选择了一个支持 TRIM 的文件系统（ext4, Btrfs, F2FS, 等等）。注意，F2FS 需要内核 4.19 或更高版本来支持 TRIM。</p>
<p>要一次性运行 TRIM，你可以手动运行 <a href="https://man.voidlinux.org/fstrim.8"><code>fstrim(8)</code></a> 。例如，如果你的 <code>/</code> 目录在一个 SSD 上。</p>
<pre><code># fstrim /
</code></pre>
<p>要自动运行 TRIM，使用 cron 或在 <code>/etc/fstab</code> 中添加 <code>discard</code> 选项。</p>
<h2 id="使用cron的定期trim"><a class="header" href="#使用cron的定期trim">使用cron的定期TRIM</a></h2>
<p>将以下行添加到 <code>/etc/cron.weekly/fstrim</code>:</p>
<pre><code>#!/bin/sh

fstrim /
</code></pre>
<p>最后，使该脚本可执行：</p>
<pre><code># chmod u+x /etc/cron.weekly/fstrim
</code></pre>
<h2 id="使用-fastab-discard-和-持续-trim"><a class="header" href="#使用-fastab-discard-和-持续-trim">使用 fastab discard 和 持续 trim</a></h2>
<p>你可以使用连续或定期的 TRIM，但如果你的 SSD 不能正确处理 NCQ，则不建议使用连续 TRIM。请参考内核的<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/ata/libata-core.c?h=v5.8&amp;id=bcf876870b95592b52519ed4aafcf9d95999bc9c#n3774">黑名单</a>。</p>
<p>编辑　<code>/etc/fstab</code> ，添加 <code>discard</code> 选项以阻止需要TRIM的设备。</p>
<p>例如，如果 <code>/dev/sda1</code> 是一个 SSD 分区，格式化为 ext4，挂载 在 <code>/</code>: </p>
<pre><code>/dev/sda1  /           ext4  defaults,discard   0  1
</code></pre>
<h2 id="lvm"><a class="header" href="#lvm">LVM</a></h2>
<p>要为 LVM 的命令（<code>lvremove</code>, <code>lvreduce</code>, 等等）启用 TRIM，编辑 <code>/etc/lvm/lvm.conf</code> ，取消对 <code>issue_discards</code> 选项的注释，并将其设置为<code>1</code>。</p>
<pre><code>issue_discards=1
</code></pre>
<h2 id="luks"><a class="header" href="#luks">LUKS</a></h2>
<p><strong>警告</strong>: 在为你的 LUKS 分区启用 discard 之前，请注意<a href="https://wiki.archlinux.org/index.php/Dm-crypt/Specialties#Discard/TRIM_support_for_solid_state_drives_(SSD)">安全问题</a>。</p>
<p>要打开一个加密的 LUKS 设备并允许 discards ，用 <code>--allow-discards</code> 选项打开设备:</p>
<pre><code># cryptsetup luksOpen --allow-discards /dev/sdaX luks
</code></pre>
<h3 id="非-root-设备"><a class="header" href="#非-root-设备">非 root 设备</a></h3>
<p>编辑 <code>/etc/crypttab</code>，为 SSD 上的设备设置 <code>discard</code> 选项。例如，如果你有一个 LUKS 设备，名称为 <code>externaldrive1</code>，设备为 <code>/dev/sdb2</code> ，密码为 <code>none</code> 。</p>
<pre><code>externaldrive1  /dev/sdb2   none    luks,discard
</code></pre>
<h3 id="root-设备"><a class="header" href="#root-设备">Root 设备</a></h3>
<p>如果你的根设备在 LUKS 上，把 <code>rd.luks.allow-discards</code> 添加到 <code>CMDLINE_LINUX_DEFAULT</code>。在 GRUB 的情况下，编辑 <code>/etc/default/grub</code> ：</p>
<pre><code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;rd.luks.allow-discards&quot;
</code></pre>
<h3 id="验证配置"><a class="header" href="#验证配置">验证配置</a></h3>
<p>要验证你是否已为 LUKS 正确配置 TRIM，请运行： </p>
<pre><code># dmsetup table /dev/mapper/crypt_dev --showkeys
</code></pre>
<p>如果此命令输出包含字符串 <code>allow_discards</code>， 在你的 LUKS 设备上成功启用了 TRIM。 </p>
<h2 id="zfs"><a class="header" href="#zfs">ZFS</a></h2>
<p>在 ZFS 池上运行 <code>trim</code> 之前，确保池中的所有设备都支持它：</p>
<pre><code># zpool get all | grep trim
</code></pre>
<p>如果池允许 <code>aurotrim</code> （默认设置为 <code>off</code>），你可以定期或者自动 <code>trim</code> zfs池。要一次性 <code>trim</code> <code>你的 zfs 池的名字</code>：</p>
<pre><code># zpool trim yourpoolname
</code></pre>
<h3 id="定期-trim"><a class="header" href="#定期-trim">定期 TRIM</a></h3>
<p>将以下行添加到 <code>/etc/cron.daily/ztrim</code>:</p>
<pre><code>#!/bin/sh
zpool trim yourpoolname
</code></pre>
<p>最后，使该脚本可执行：</p>
<pre><code># chmod u+x /etc/cron.daily/ztrim
</code></pre>
<h3 id="自动-trim"><a class="header" href="#自动-trim">自动 trim</a></h3>
<p>设置 autotrim  <code>yourpoolname</code>, 请运行:</p>
<pre><code># zpool set autotrim=on yourpoolname
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安全"><a class="header" href="#安全">安全</a></h1>
<p>有几种方法可以使你的安装更安全。本节探讨了其中的一些方法。</p>
<h2 id="章节内容-2"><a class="header" href="#章节内容-2">章节内容</a></h2>
<ul>
<li><a href="config/security/./apparmor.html">AppArmor</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apparmor"><a class="header" href="#apparmor">AppArmor</a></h1>
<p>AppArmor 是一种强制性的访问控制机制（如 SELinux ）。它可以根据预先定义或生成的策略来约束程序。</p>
<p>Void 附带了一些用于多种服务的默认配置文件，例如 <code>dhcpcd</code> 和 <code>wpa_supplicant</code>。 <code>LXC</code> 和 <code>podman</code> 等容器运行时与 AppArmor 可提高容器 payloads 的安全性。 </p>
<p>要在系统上使用 AppArmor，必须： </p>
<ol>
<li>安装 <code>apparmor</code> 软件包。</li>
<li>在内核 commandline 上写 <code>apparmor=1 security=apparmor</code></li>
</ol>
<p>要完成第二步请看 <a href="config/security/./../kernel.html#cmdline">如何更改内核 cmdline</a>.</p>
<p><code>/etc/default/apparmor</code> 中的 <code>APPARMOR</code> 变量控制启动时如何加载配置文件，该值默认设置为 <code>complain</code> ，对应于 AppArmor 模式（<code>disable</code>, <code>complain</code>, <code>enforce</code>）。</p>
<p>AppArmor 工具 <a href="https://man.voidlinux.org/aa-genprof.8">aa-genprof(8)</a> 和 <a href="https://man.voidlinux.org/aa-logprof.8">aa-logprof(8)</a> 需要配置 <a href="config/security/../services/logging.html">syslog</a> 或运行 <a href="https://man.voidlinux.org/auditd.8">auditd(8)</a> 服务。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="日期和时间"><a class="header" href="#日期和时间">日期和时间</a></h1>
<p>查看系统的当前日期和时间信息，以及对其进行更改，请使用 <a href="https://man.voidlinux.org/date.1">date(1)</a>.</p>
<h2 id="时区-1"><a class="header" href="#时区-1">时区</a></h2>
<p>系统默认的时区可以通过将时区文件链接到 <code>/etc/localtime</code> :</p>
<pre><code># ln -sf /usr/share/zoneinfo/&lt;timezone&gt; /etc/localtime
</code></pre>
<blockquote>
<p>注意: 如果在 <code>/etc/rc.conf</code>　中设置了　<code>TIMEZONE</code> 变量, 应该将其删除或注释掉。因为这将覆盖在 <code>ln</code> 中设置的内容。
然后重启.</p>
</blockquote>
<p>要在每个用户的基础上改变时区，可以从你的 shell 的配置文件中导出 <code>TZ</code> 变量。</p>
<pre><code>export TZ=&lt;timezone&gt;
</code></pre>
<p>注意，设置<em>时区</em>并不设置<em>时间</em>（或日期）；相反，它只是指定了与 <a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">UTC</a>  的偏移量，如 <a href="https://man.voidlinux.org/timezone.3">timezone(3)</a> 中所述。</p>
<h2 id="硬件时钟"><a class="header" href="#硬件时钟">硬件时钟</a></h2>
<p>默认情况下，Void 的硬件时钟被存储为 UTC。Windows 默认不使用 UTC，如果你是双系统启动，这将与 Void 冲突。你可以通过在 <code>/etc/rc.conf</code> 中设置 <code>HARDWARECLOCK</code> 变量，将 Windows 改为使用 UTC，或者将 Void Linux 改为使用 <code>localtime</code>:</p>
<pre><code>export HARDWARECLOCK=localtime
</code></pre>
<p>有关详细信息，请参阅 <a href="https://man.voidlinux.org/hwclock.8">hwclock(8)</a>.</p>
<h2 id="ntp"><a class="header" href="#ntp">NTP</a></h2>
<p>为了保持系统时钟的准确性，您可以使用 <a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">网络时间协议</a> (NTP).</p>
<p>Void 为三个 NTP 守护进程提供了包：NTP、OpenNTPD 和 Chrony。 </p>
<p>一旦你安装了一个 NTP 守护进程，你就可以<a href="config/../config/services/index.html#managing-services">启用服务</a>或 <a href="https://man.voidlinux.org/xbps-alternatives.1">xbps-alternatives(1)</a> 管理的 <code>ntpd</code> 服务来为它启用服务。</p>
<h3 id="ntp-1"><a class="header" href="#ntp-1">NTP</a></h3>
<p>NTP 是网络时间协议的官方参考实现。</p>
<p><code>ntp</code> 包提供 NTP 和 <code>isc-ntpd</code> 服务。 </p>
<p>有关详细信息，请访问 <a href="https://www.ntp.org/">the NTP site</a>.</p>
<h3 id="openntpd"><a class="header" href="#openntpd">OpenNTPD</a></h3>
<p>OpenNTPD 专注于提供一个安全、精简的NTP实现，对于大多数的使用情况来说，它 &quot;只是工作&quot;，具有合理的准确性。</p>
<p><code>openntpd</code> 软件包提供 OpenNTPD 和 <code>openntpd</code> 服务。</p>
<p>有关详细信息，请访问 https://www.openntpd.org/.</p>
<h3 id="chrony"><a class="header" href="#chrony">Chrony</a></h3>
<p>Chrony 的设计是为了在各种条件下都能很好地工作；它可以比NTP更快地同步，而且精度更高。</p>
<p>这 <code>chrony</code> 包提供了 Chrony 和 <code>chronyd</code> 服务。 </p>
<p>Chrony网站简要介绍了其<a href="https://chrony.tuxfamily.org/faq.html#_how_does_chrony_compare_to_ntpd">相对于NTP的优势</a>，<a href="https://chrony.tuxfamily.org/comparison.html">以及Chrony 、 NTP 和 OpenNTPD 的详细功能比较</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内核"><a class="header" href="#内核">内核</a></h1>
<h2 id="内核系列"><a class="header" href="#内核系列">内核系列</a></h2>
<p>Void Linux 在默认版本库中提供了许多内核系列。这些被命名为 <code>linux&lt;x&gt;.&lt;y&gt;</code>：例如，<code>linux4.19</code>。你可以通过运行以下命令查询所有可用的内核系列：</p>
<pre><code>$ xbps-query --regex -Rs '^linux[0-9.]+-[0-9._]+'
</code></pre>
<p>默认安装的 <code>linux</code> 元包依赖于其中一个内核包，通常是包含最新的主线内核的包，可以与所有 DKMS 模块一起工作。较新的内核可能在资源库中可用，但不一定被认为稳定到可以作为默认的内核；使用这些内核的风险由你自己承担。如果你希望使用一个较新的内核，并且有需要构建的 DKMS 模块，请安装相关的 <code>linux&lt;x&gt;.&lt;y&gt;-headers</code> 软件包，然后使用 <a href="https://man.voidlinux.org/xbps-reconfigure.1">xbps-reconfigure(1)</a> 重新配置你安装的 <code>linux&lt;x&gt;.&lt;y&gt;</code> 软件包。这将构建 DKMS 模块。</p>
<h2 id="删除旧内核"><a class="header" href="#删除旧内核">删除旧内核</a></h2>
<p>当更新内核时，旧的版本会被留下，以防有必要回滚到旧的版本。随着时间的推移，旧的内核版本会积累起来，消耗磁盘空间，增加 DKMS 模块更新的时间。此外，如果 <code>/boot</code> 是一个独立的分区，并且被旧的内核填满，更新可能会失败，或者导致生成不完整的 initramfs 文件系统，如果它们被启动，会导致内核恐慌(kernel panics)。因此，建议定时地清理旧内核。</p>
<p><code>vkpurge</code> 预先安装在每个 Void Linux 系统上，删除旧内核是通过 <a href="https://man.voidlinux.org/vkpurge.8">vkpurge(8)</a> 工具完成的。这个工具在移除旧内核时运行必要的 hooks。注意，<code>vkpurge</code> 不会删除内核 <em>软件包</em>，只删除特定的 <em>内核</em>。</p>
<h2 id="移除默认的内核系列"><a class="header" href="#移除默认的内核系列">移除默认的内核系列</a></h2>
<p>如果你已经安装了默认之外的系列内核包，并且想移除默认的内核包，你应该安装 <code>linux-base</code> 包，或者在已经安装的情况下将其<a href="https://man.voidlinux.org/xbps-pkgdb.1">标记为手动软件包</a>。在这个过程之后，你可以用 <a href="https://man.voidlinux.org/xbps-remove.1">xbps-remove(1)</a> 删除默认的内核包。可能有必要在 <a href="https://man.voidlinux.org/xbps.d.5">xbps.d(5)</a> 中的 <code>ignorepkg</code> 条目中加入 <code>linux</code> 和 <code>linux-headers</code>，因为基础包可能依赖于它们。</p>
<h2 id="换成其他内核系列"><a class="header" href="#换成其他内核系列">换成其他内核系列</a></h2>
<p>如果你想使用 <code>linux-lts</code> 或 <code>linux-mainline</code> 内核系列而不是默认的 <code>linux</code>，首先安装所需的系列元包（及 <code>linux-lts-headers</code> 或<code>linux-mainline-headers</code> 元包）。然后，你可以将 <code>linux</code> 和 <code>linux-headers</code> 添加到 <a href="https://man.voidlinux.org/xbps.d.5">xbps.d(5)</a> 中的 <code>ignorepkg</code> 条目中，并卸载这些包。</p>
<h2 id="改变默认的-initramfs-生成器"><a class="header" href="#改变默认的-initramfs-生成器">改变默认的 initramfs 生成器</a></h2>
<p>默认情况下，Void Linux 使用 <a href="https://man.voidlinux.org/dracut.8">dracut</a> 为安装的内核准备 initramfs 镜像。替代品如 <a href="https://man.voidlinux.org/mkinitcpio.8">mkinitcpio</a> 是可用的。每个 initramfs 生成器都在 initramfs 组中注册了一个 <a href="https://man.voidlinux.org/xbps-alternatives.1">XBPS alternative</a> ，以链接其<a href="config/kernel.html#%E5%86%85%E6%A0%B8-hooks">内核 hooks</a>，在为特定内核创建或移除 initramfs 镜像时使用。</p>
<p>要用 mkinitcpio <em>等等</em> 替换 dracut，请安装 <code>mkinitcpio</code> 软件包；确认 <code>mkinitcpio</code> 出现在可用的替代品列表中，方法是运行:</p>
<pre><code>$ xbps-alternatives -l -g initramfs
</code></pre>
<p>执行指令</p>
<pre><code># xbps-alternatives -s mkinitcpio
</code></pre>
<p>用 mkinitcpio 提供的钩子替换 dracut 的内核 hooks。在随后的内核更新中（或对 DKMS 包的更新触发了 initramfs 的再生），mkinitcpio 将被用来代替 dracut 来准备 initramfs 镜像。要强迫镜像重新生成，请重新配置你的内核包，运行：</p>
<pre><code># xbps-reconfigure -f linux&lt;x&gt;.&lt;y&gt;
</code></pre>
<p>对于当前安装的每个 <code>linux&lt;x&gt;.&lt;y&gt;</code> 软件包。</p>
<h2 id="cmdline"><a class="header" href="#cmdline">cmdline</a></h2>
<p>内核、初始 RAM 磁盘（initrd）和一些系统程序可以在启动时通过内核命令行参数进行配置。内核理解的参数在 <a href="https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html">kernel-parameters</a>文档和<a href="https://man.voidlinux.org/bootparam.7">bootparam(7)</a> 中解释。dracut 理解的参数可以在<a href="https://man.voidlinux.org/dracut.cmdline.7">dracut.cmdline(7)</a> 中找到。</p>
<p>一旦系统被启动，当前的内核命令行参数可以在 <code>/proc/cmdline</code> 文件中找到。一些系统程序可以根据命令行中传递的参数来改变它们的行为，例如，在<a href="config/./services/index.html#booting-a-different-runsvdir">启动不同的 runtvdir</a> 时就会发生这种情况。</p>
<p>有不同的方法来设置这些参数，下面将解释其中一些方法。</p>
<h3 id="grub"><a class="header" href="#grub">GRUB</a></h3>
<p>内核命令行参数可以通过编辑 <code>/etc/default/grub</code>，改变 <code>GRUB_CMDLINE_LINUX_DEFAULT</code> 变量，然后运行<code>update-grub</code>，通过 GRUB 引导程序添加。</p>
<h3 id="dracut"><a class="header" href="#dracut">dracut</a></h3>
<p>Dracut 提供了一个 <a href="https://man.voidlinux.org/dracut.conf.5"><code>kernel_cmdline</code> 配置选项</a> 和<a href="https://man.voidlinux.org/dracut.8"><code>--kernel-cmdline</code>命令行选项</a>，将直接在 initramfs 镜像中编码命令行参数。当 dracut 被用来创建一个 UEFI 可执行文件时，用这些选项设置的参数将被传递给内核。然而，当产生一个普通的 initramfs 时，这些选项在启动时不会被传递给内核。相反，它们将被写入镜像中的 <code>/etc/cmdline.d</code> 中的一个配置文件。虽然 dracut 解析这个配置来控制它自己的启动时行为，但内核本身不会知道通过这个机制设置的任何东西。</p>
<p>在修改 dracut 配置后，重新生成 initramfs，以确保它包括这些变化。</p>
<h2 id="内核加固"><a class="header" href="#内核加固">内核加固</a></h2>
<p>Void Linux在默认时启用了一些内核安全选项。这最初是由内核命令行参数 <code>slub_debug=P page_poison=1</code> 提供的，但从内核 5.3 系列开始，这些参数被 <code>init_on_alloc</code> 和 <code>init_on_free</code> 取代（见<a href="https://github.com/torvalds/linux/commit/6471384af">此提交</a>）。</p>
<p>Void 的内核在可用的情况下默认启用 <code>init_on_alloc</code> 选项（即 <code>linux5.4</code> 及以上版本）。在大多数情况下，你通常不应该禁用它，因为它对性能的影响相当小（1% 以内）。<code>init_on_free</code> 选项更加昂贵（平均 5% 左右），需要通过在内核命令行传递 <code>init_on_free=1</code> 来手动启用。如果你需要禁用 <code>init_on_alloc</code>，你可以通过传递 <code>init_on_alloc=0</code> 来实现。</p>
<p>有可能你现有的系统仍然启用了旧的选项。它们在较新的内核中仍然有效，但对性能的影响与 <code>init_on_free=1</code> 更为接近。在较老的硬件上，这可能是相当明显的。如果你运行的内核系列早于 5.4，你可以保留它们（或者增加它们），以牺牲速度为代价获得额外的安全性；否则你应该删除它们。</p>
<h2 id="内核模块"><a class="header" href="#内核模块">内核模块</a></h2>
<p>内核模块通常是文件系统或设备驱动程序。</p>
<h3 id="在启动过程中加载内核模块"><a class="header" href="#在启动过程中加载内核模块">在启动过程中加载内核模块</a></h3>
<p>通常情况下，内核会自动加载所需的模块，但有时可能需要明确指定启动时要加载的模块。</p>
<p>为了在启动过程中加载内核模块，需要创建一个像 <code>/etc/modules-load.d/virtio.conf</code> 这样的 <code>.conf</code> 文件，其内容是：</p>
<pre><code># load virtio-net
virtio-net
</code></pre>
<h3 id="把内核模块禁用"><a class="header" href="#把内核模块禁用">把内核模块禁用</a></h3>
<p>将内核模块禁用是一种防止模块被内核加载的方法。有两种不同的方法将内核模块禁用，一种是由 initramfs 加载的模块，另一种是 initramfs 进程结束后加载的模块。由 initramfs 加载的模块必须在 initramfs 配置中禁用。</p>
<p>要将 initramfs 过程后加载的模块列入黑名单，创建一个 <code>.conf</code> 文件，如 <code>/etc/modprobe.d/radeon.conf</code>，其内容为：</p>
<pre><code>blacklist radeon
</code></pre>
<h4 id="在-initramfs-中禁用模块"><a class="header" href="#在-initramfs-中禁用模块">在 initramfs 中禁用模块</a></h4>
<p>在对配置文件进行必要的修改后，需要重新生成 initramfs，以便在下一次启动时使修改生效。</p>
<h5 id="dracut-1"><a class="header" href="#dracut-1">dracut</a></h5>
<p>Dracut 可以通过一个配置文件配置为不包括内核模块。要把模块列入 dracut initramfs 的黑名单，可以创建一个<code>.conf</code> 文件，如 <code>/etc/dracut.conf.d/radeon.conf</code>，其内容如下：</p>
<pre><code>omit_drivers+=&quot; radeon &quot;
</code></pre>
<h5 id="mkinitcpio"><a class="header" href="#mkinitcpio">mkinitcpio</a></h5>
<p>To blacklist modules from being included in a mkinitcpio initramfs a <code>.conf</code>
file needs to be created like <code>/etc/modprobe.d/radeon.conf</code> with the contents:</p>
<p>为了将模块禁用，需要创建一个 <code>.conf</code> 文件，如 <code>/etc/modprobe.d/radeon.conf</code>，以防止模块被包含在 mkinitcpio initramfs 中。</p>
<pre><code>blacklist radeon
</code></pre>
<h2 id="内核-hooks"><a class="header" href="#内核-hooks">内核 hooks</a></h2>
<p>Void Linux 在 <code>/etc/kernel.d/{pre-install,post-install,pre-remove,post-remove}</code> 中为内核 hooks 提供了目录。</p>
<p>这些 hooks 被用来更新像 <code>grub</code>、<code>gummiboot</code> 和 <code>lilo</code> 等引导程序的引导菜单。</p>
<h3 id="安装-hooks"><a class="header" href="#安装-hooks">安装 hooks</a></h3>
<p><code>{pre,post}-install</code> hooks 是由 <a href="https://man.voidlinux.org/xbps-reconfigure.1">xbps-reconfigure(1)</a> 在配置 Linux 内核时执行的，比如构建其 initramfs。这发生在第一次安装或更新内核系列时，但也可以手动运行：</p>
<pre><code># xbps-reconfigure --force linux&lt;x&gt;.&lt;y&gt;
</code></pre>
<p>如果手动运行，它们的作用是将 initramfs 的配置变化应用于下一次启动。</p>
<h3 id="删除-hooks"><a class="header" href="#删除-hooks">删除 hooks</a></h3>
<p><a href="https://man.voidlinux.org/vkpurge.8">vkpurge(8)</a> 在删除旧内核时执行 <code>{pre,post}-remove</code> hooks。</p>
<h2 id="动态内核模块支持-dkms"><a class="header" href="#动态内核模块支持-dkms">动态内核模块支持 (DKMS)</a></h2>
<p>有一些不属于 Linux 源码树的内核模块，在安装时使用 DKMS 和内核 hooks 构建。可用的模块可以通过在软件包库中搜索<code>dkms</code> 来列出。</p>
<p>DKMS 构建日志在 <code>/var/lib/dkms/</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="电源管理"><a class="header" href="#电源管理">电源管理</a></h1>
<h2 id="acpid"><a class="header" href="#acpid">acpid</a></h2>
<p><a href="https://man.voidlinux.org/acpid.8">acpid(8)</a> 的 <code>acpid</code> 服务已经安装，如果Void是从使用 本地源 的 live 镜像中安装的，那么默认情况下会被启用。ACPI 事件由 <code>/etc/acpi/handler.sh</code> 处理，它使用 <a href="https://man.voidlinux.org/zzz.8">zzz(8)</a> 来处理 suspend-to-RAM 事件.</p>
<h2 id="elogind"><a class="header" href="#elogind">elogind</a></h2>
<p><code>elogind</code> 服务是由 <code>elogind</code> 软件包提供的。默认情况下，<a href="https://man.voidlinux.org/elogind.8">elogind(8)</a> 监听并处理与 lid-switch 激活 以及<em>电源</em>、<em>暂停</em>和<em>休眠键</em> 有关的 ACPI 事件。如果 <code>acpid</code> 服务被安装并启用，这将与它发生冲突。要么在启用 elogind 时禁用 acpid ，要么在 <a href="https://man.voidlinux.org/logind.conf.5">logind.conf(5)</a> 中把elogind 配置为忽略 ACPI 事件。有几个配置选项，都以关键字 <code>Handle</code> 开头，应该设置为忽略，以避免与acpid发生干扰。</p>
<h2 id="省电---tlp"><a class="header" href="#省电---tlp">省电 - tlp</a></h2>
<p>笔记本电脑的电池寿命可以通过使用 <a href="https://man.voidlinux.org/tlp.8">tlp(8)</a> 来延长。要使用它，请安装 <code>tlp</code> 软件包，并<a href="config/./services/index.html#enabling-services">启用</a> <code>tlp</code> 服务。详情请参考<a href="https://linrunner.de/tlp/">TLP文档</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络-1"><a class="header" href="#网络-1">网络</a></h1>
<p>Void Linux 中的网络配置可以通过几种方式进行。默认安装时启用了 <a href="https://man.voidlinux.org/dhcpcd.8">dhcpcd(8)</a> 服务。</p>
<h2 id="接口名称"><a class="header" href="#接口名称">接口名称</a></h2>
<p>新版本的 <a href="https://man.voidlinux.org/udev.7">udev(7)</a> 不再使用传统的 Linux 接口命名方案（eth0, eth1, wlan0, ...）。</p>
<p>这种行为可以通过在<a href="https://docs.voidlinux.org/config/kernel.html#cmdline">内核 cmdline</a> 中加入 <code>net.ifnames=0</code> 来恢复。</p>
<h2 id="静态配置"><a class="header" href="#静态配置">静态配置</a></h2>
<p>在启动时配置静态网络的一个简单方法是在 <code>/etc/rc.local</code> 文件中添加必要的 <a href="https://man.voidlinux.org/ip.8">ip(8)</a> 命令：</p>
<pre><code>ip link set dev eth0 up
ip addr add 192.168.1.2/24 brd + dev eth0
ip route add default via 192.168.1.1
</code></pre>
<h2 id="dhcpcd"><a class="header" href="#dhcpcd">dhcpcd</a></h2>
<p>要在所有接口上运行 <a href="https://man.voidlinux.org/dhcpcd.8">dhcpcd(8)</a> ，请启用 <code>dhcpcd</code> 服务。</p>
<p>要想只在一个特定的接口上运行 <code>dhcpcd</code> ，请复制 <code>dhcpcd-eth0</code> 服务，并修改它以匹配你的接口。</p>
<pre><code>$ ip link show
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: enp3s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
        link/ether ff:ff:ff:ff:ff:ff brd ff:ff:ff:f
# cp -R /etc/sv/dhcpcd-eth0 /etc/sv/dhcpcd-enp3s0
# sed -i 's/eth0/enp3s0/' /etc/sv/dhcpcd-enp3s0/run
# ln -s /etc/sv/dhcpcd-enp3s0 /var/service/
</code></pre>
<p>关于配置 dhcpcd 的更多信息，请参考 <a href="https://man.voidlinux.org/dhcpcd.conf.5">dhcpcd.conf(5)</a></p>
<h2 id="无线网络"><a class="header" href="#无线网络">无线网络</a></h2>
<p>在使用无线网络之前，使用 <a href="https://man.voidlinux.org/rfkill.8">rfkill(8)</a>  检查相关接口是否被软禁或硬禁。</p>
<p>Void 提供了几种连接到无线网络的方法：</p>
<ul>
<li><a href="config/network/./wpa_supplicant.html">wpa_supplicant</a></li>
<li><a href="config/network/./iwd.html">iwd</a></li>
<li><a href="config/network/./networkmanager.html">NetworkManager</a></li>
<li><a href="config/network/./connman.html">ConnMan</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="防火墙"><a class="header" href="#防火墙">防火墙</a></h1>
<h2 id="iptables"><a class="header" href="#iptables">iptables</a></h2>
<p>默认情况下，<code>iptables</code> 软件包被安装在基本系统上。它提供了 <a href="https://man.voidlinux.org/iptables.8">iptables(8)/ip6tables(8)</a>。相关服务使用 <code>/etc/iptables/iptables.rules</code> 和 <code>/etc/iptables/ip6tables.ruleset</code> 文件，这些文件必须由系统管理员创建。</p>
<p>在 <code>/etc/iptables</code> 目录下提供了两个规则集的例子：<code>empty.rules</code> 和 <code>simple_firewall.rules</code> 。</p>
<h3 id="在启动时应用规则"><a class="header" href="#在启动时应用规则">在启动时应用规则</a></h3>
<p>要在 runit stage 1应用 iptables 规则，请安装 <code>runit-iptables</code> 软件包。这增加了一个核心服务，恢复了 <code>iptables.rules</code> 和 <code>ip6tables.rulesets</code>。</p>
<p>或者，要在 stage 2 应用这些规则，请在 <code>/etc/rc.local</code> 中添加以下内容：</p>
<pre><code>if [ -e /etc/iptables/iptables.rules ]; then
  iptables-restore /etc/iptables/iptables.rules
fi

if [ -e /etc/iptables/ip6tables.rules ]; then
  ip6tables-restore /etc/iptables/ip6tables.rules
fi
</code></pre>
<p>重新启动后，检查活动的防火墙规则：</p>
<pre><code># iptables -L
# ip6tables -L
</code></pre>
<h3 id="在运行时应用规则"><a class="header" href="#在运行时应用规则">在运行时应用规则</a></h3>
<p><code>iptables</code> 带有两个 runit 服务，<code>iptables</code> 和 <code>ip6tables</code>，用于快速 falsh 或 restore <code>iptables.rules</code> 和 <code>ip6tables.rulesets</code>。一旦这些服务被<a href="config/network/../services/index.html">启用</a>，你可以通过关闭相关服务来刷新规则集，例如:</p>
<pre><code># sv down iptables
</code></pre>
<p>并通过提高相关服务来恢复它们，例如:</p>
<pre><code># sv up ip6tables
</code></pre>
<h2 id="nftables"><a class="header" href="#nftables">nftables</a></h2>
<p><code>nftables</code> 取代了 <code>iptables</code>、<code>ip6tables</code>、<code>arptables</code> 和 <code>ebtables</code>（统称为 <code>xtables</code>）。<a href="https://wiki.nftables.org/wiki-nftables/index.php/Main_Page">nftables wiki</a> 描述了与 <code>iptables</code> 工具集的<a href="https://wiki.nftables.org/wiki-nftables/index.php/Main_differences_with_iptables">主要区别</a>。</p>
<p>要使用 <code>nftables</code>，请安装 <code>nftables</code> 包，它提供了 <a href="https://man.voidlinux.org/nft.8">nft(8)</a>。它还提供了 <a href="https://man.voidlinux.org/iptables-translate.8">iptables-translate(8)/ip6tables-translate(8)</a> 和 <a href="https://man.voidlinux.org/iptables-restore-translate.8">iptables-restore-translate(8)/ip6tables-restore-translate(8)</a>，它们将 <code>iptables</code> 规则转换成 <code>nftables</code> 规则。</p>
<h3 id="在启动时应用规则-1"><a class="header" href="#在启动时应用规则-1">在启动时应用规则</a></h3>
<p>要在 runit stage 1应用 nftables 规则，请安装 <code>runit-nftables</code> 软件包。这增加了一个核心服务，它恢复了<code>/etc/nftables.conf</code> 中的规则集。</p>
<h3 id="在运行时应用规则-1"><a class="header" href="#在运行时应用规则-1">在运行时应用规则</a></h3>
<p><code>nftables</code> 软件包提供了 <code>nftables</code> 服务，它使用来自 <code>/etc/nftables.conf</code> 的规则。一旦你启用了 <code>nftables</code> 服务，要加载规则，请运行:</p>
<pre><code># sv up nftables
</code></pre>
<p>要刷新规则，请运行：</p>
<pre><code># sv down nftables
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wpa_supplicant"><a class="header" href="#wpa_supplicant">wpa_supplicant</a></h1>
<p><code>wpa_supplicant</code> 软件包默认安装在基本系统上。它包括配置无线接口和处理无线安全协议的实用程序。要使用 <code>wpa_supplicant</code>，你需要启用 wpa_supplicant 服务。</p>
<p><a href="https://man.voidlinux.org/wpa_supplicant.8">wpa_supplicant(8)</a> 是一个基于 <a href="https://man.voidlinux.org/wpa_supplicant.conf.5">wpa_supplicant.conf(5)</a> 配置文件来管理无线接口的守护程序。在 <code>/usr/share/examples/wpa_supplicant/wpa_supplicant.conf</code> 中可以找到关于配置选项的广泛概述，包括例子。</p>
<p><a href="https://man.voidlinux.org/wpa_passphrase.8">wpa_passphrase(8)</a> 帮助创建用于配置文件的预共享密钥。 <a href="https://man.voidlinux.org/wpa_cli.8">wpa_cli(8)</a> 提供了一个管理 <code>wpa_supplicant</code> 守护进程的 CLI。</p>
<h2 id="wpa-psk"><a class="header" href="#wpa-psk">WPA-PSK</a></h2>
<p>To use WPA-PSK, generate a pre-shared key with
<a href="https://man.voidlinux.org/wpa_passphrase.8">wpa_passphrase(8)</a> and append the
output to the relevant <code>wpa_supplicant.conf</code> file:</p>
<p>要使用 WPA-PSK，用以下方法生成一个预共享密钥 <a href="https://man.voidlinux.org/wpa_passphrase.8">wpa_passphrase(8)</a>，并将输出结果附加到相关的 <code>wpa_supplicant.conf</code> 文件中。</p>
<pre><code># wpa_passphrase &lt;MYSSID&gt; &lt;passphrase&gt; &gt;&gt; /etc/wpa_supplicant/wpa_supplicant-&lt;device_name&gt;.conf
</code></pre>
<h2 id="wpa-eap"><a class="header" href="#wpa-eap">WPA-EAP</a></h2>
<p>WPA-EAP 经常被用于机构 (教育机构) 登录，特别是 eduroam。这不使用 PSK，但可以像这样生成一个密码哈希:</p>
<pre><code>$ echo -n &lt;passphrase&gt; | iconv -t utf16le | openssl md4
</code></pre>
<h2 id="wep"><a class="header" href="#wep">WEP</a></h2>
<p>对于 WEP 配置，将以下行添加到您的设备的 <code>wpa-supplicant.conf</code>: </p>
<pre><code>network={
    ssid=&quot;MYSSID&quot;
    key_mgmt=NONE
    wep_key0=&quot;YOUR AP WEP KEY&quot;
    wep_tx_keyidx=0
    auth_alg=SHARED
}
</code></pre>
<h3 id="wpa_supplicant-服务"><a class="header" href="#wpa_supplicant-服务">wpa_supplicant 服务</a></h3>
<p><code>wpa_supplicant</code> 服务检查 <code>/etc/sv/wpa_supplicant/conf</code> 中的下列选项：</p>
<ul>
<li><code>OPTS</code>: 要传递给服务的选项。覆盖任何其他选项。</li>
<li><code>CONF_FILE</code>: 用于配置的文件路径。 默认为 
<code>/etc/wpa_supplicant/wpa_supplicant.conf</code>。</li>
<li><code>WPA_INTERFACE</code>: 要匹配的接口。 可能包含通配符； 默认为所有接口。</li>
<li><code>DRIVER</code>: 要使用的驱动程序。请参阅 <code>wpa_supplicant -h</code> 了解可用的驱动程序。</li>
</ul>
<p>如果没有找到 <code>conf</code> 文件，服务会在 <code>/etc/wpa_supplicant</code> 中搜索以下文件：</p>
<ul>
<li><code>wpa_supplicant-&lt;interface&gt;.conf</code>: 如果找到，这些文件就会被绑定到命名的接口上。</li>
<li><code>wpa_supplicant.conf</code>: 如果找到了，这个文件就会被加载，并与所有发现的其他接口绑定。</li>
</ul>
<p>一旦你对你的配置感到满意，启用 <code>wpa_supplicant</code> 服务。</p>
<h3 id="使用-wpa_cli"><a class="header" href="#使用-wpa_cli">使用 wpa_cli</a></h3>
<p>使用 <code>wpa_cli</code> 从命令行管理 <code>wpa_supplicant</code> 时，请务必通过 <code>-i</code> 选项指定使用哪个网络接口，例如。</p>
<pre><code># wpa_cli -i wlp2s0
</code></pre>
<p>不这样做会导致各种 <code>wpa_cli</code> 命令（例如， <code>scan</code> 和 <code>scan_results</code>) 没有产生预期的输出。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iwd"><a class="header" href="#iwd">IWD</a></h1>
<p><a href="https://iwd.wiki.kernel.org/">IWD</a>（iNet Wireless Daemon）是一个 Linux 的无线守护进程，旨在取代 <a href="config/network/./wpa_supplicant.html">WPA supplicant</a>。</p>
<h2 id="安装-4"><a class="header" href="#安装-4">安装</a></h2>
<p>安装 <code>iwd</code> 软件包并启用 <code>dbus</code> 和 <code>iwd</code> 服务。 </p>
<h2 id="用法"><a class="header" href="#用法">用法</a></h2>
<p>命令行客户端 <a href="https://man.voidlinux.org/iwctl.1">iwctl(1)</a> 可以用来添加、删除和配置网络连接。命令可以作为参数传递；当运行时没有参数，它提供一个交互式会话。要列出可用的命令，可以运行 <code>iwctl help</code>，或者运行 <code>iwctl</code> 并在交互提示符下输入 <code>help</code>。</p>
<p>默认情况下，只有 root 用户和 <code>wheel</code> 组中的用户有权限操作 <code>iwctl</code>。</p>
<h2 id="配置-3"><a class="header" href="#配置-3">配置</a></h2>
<p>配置选项和例子描述如下。更多信息请查阅相关手册页面和<a href="https://iwd.wiki.kernel.org/networkconfigurationsettings">上游文件</a>)。</p>
<h3 id="守护进程配置"><a class="header" href="#守护进程配置">守护进程配置</a></h3>
<p>主配置文件位于 <code>/etc/iwd/main.conf</code> 中。如果它不存在，你可以创建它。它在 <a href="https://man.voidlinux.org/iwd.config.5">iwd.config(5)</a> 中有详细说明。</p>
<h3 id="网络配置"><a class="header" href="#网络配置">网络配置</a></h3>
<p>网络配置，包括例子，在 <a href="https://man.voidlinux.org/iwd.network.5">iwd.network(5)</a> 中有记载。IWD 存储已知网络的信息，并从位于 <code>/var/lib/iwd</code> 的网络配置文件中读取预置网络的信息；IWD 监控该目录的变化。网络配置文件由 SSID 的编码组成，后面是<code>.open</code> 、<code>.psk</code> 或 <code>.8021x</code> ，由安全类型决定。</p>
<p>作为一个例子，一个 WPA2/PSK 安全网络的基本配置文件将被称为 <code>&lt;ssid&gt;.psk</code>，它将包含纯文本密码:</p>
<pre><code>[Security]
Passphrase=&lt;password&gt;
</code></pre>
<h2 id="故障排除"><a class="header" href="#故障排除">故障排除</a></h2>
<p>默认情况下，IWD 会创建和销毁它所管理的无线接口（例如 <code>wlan0</code>）。这可能会干扰 <code>udevd</code>，它可能会试图用它的持久性网络接口名称规则来重命名接口。作为这种干扰的症状，以下信息可能被打印到你的屏幕上：</p>
<pre><code>[   39.441723] udevd[1100]: Error changing net interface name wlan0 to wlp59s0: Device or resource busy
[   39.442472] udevd[1100]: could not rename interface '3' from 'wlan0' to 'wlp59s0': Device or resource busy
</code></pre>
<p>一个简单的解决方法是在 <code>/etc/iwd/main.conf</code> 的 <code>[General]</code> 部分添加 <code>UseDefaultInterface=true</code>，以防止 IWD 以这种方式操纵网络接口。</p>
<p>另一种方法是禁止 <code>udevd</code> 使用持久的网络接口名称。 这可以通过在你的内核 <a href="config/network/../kernel.html#cmdline">cmdline</a> 中添加 <code>net.ifnames=0</code> 或者在 <code>/etc/udev/rules.d/80-net-name-slot.rules</code> 中创建一个符号链接到 <code>/dev/null</code> 来实现，以屏蔽重命名规则。这种替代方法将影响所有网络设备的命名。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networkmanager"><a class="header" href="#networkmanager">NetworkManager</a></h1>
<p><a href="https://man.voidlinux.org/NetworkManager.8">NetworkManager(8)</a> 是一个管理以太网、Wi-Fi 和移动宽带网络连接的守护程序。安装 <code>NetworkManager</code> 软件包以获得基本的 NetworkManager 实用程序。</p>
<h2 id="启动-networkmanager"><a class="header" href="#启动-networkmanager">启动 NetworkManager</a></h2>
<p>在启用 NetworkManager 守护进程之前，请<a href="config/network/../services/index.html">禁用</a>任何其他网络管理服务，如 <a href="config/network/./index.html#dhcpcd">dhcpcd</a>、<a href="config/network/./wpa_supplicant.html">wpa_supplicant</a> 或 <code>wicd</code>。这些服务都控制着网络接口的配置，并且会干扰 NetworkManager。</p>
<p>还要确保 <code>dbus</code> 服务被<a href="config/network/../services/index.html">启用</a>和运行。NetworkManager 使用 <code>dbus</code> 向客户公开网络信息和控制接口，如果没有它，将无法启动。</p>
<p>最后，启用 <code>NetworkManager</code> 服务。</p>
<h2 id="配置-networkmanager"><a class="header" href="#配置-networkmanager">配置 NetworkManager</a></h2>
<p>Users of NetworkManager must belong to the <code>network</code> group.</p>
<p>NetworkManager 的用户必须属于 <code>network</code> 用户组。</p>
<p><code>NetworkManager</code> 软件包包括一个命令行工具 <a href="https://man.voidlinux.org/nmcli.1">nmcli(1)</a> 和一个基于文本的用户界面 <a href="https://man.voidlinux.org/nmtui.1">nmtui(1)</a> ，用于控制网络设置.</p>
<p>NetworkManager 还有许多其他的前端，包括用于系统托盘的 <code>nm-applet</code>，用于 KDE Plasma 的 <code>nm-plasma</code>，以及GNOME 中的一个内置网络配置工具。</p>
<h2 id="eduroam-和-networkmanager"><a class="header" href="#eduroam-和-networkmanager">Eduroam 和 NetworkManager</a></h2>
<p>Eduroam 是一项漫游服务，在大学和其他学术机构提供国际安全互联网接入。更多信息可以在<a href="https://eduroam.org/">这里</a>找到。</p>
<h3 id="依赖关系"><a class="header" href="#依赖关系">依赖关系</a></h3>
<p>安装 <code>python3-dbus</code> 软件包</p>
<h3 id="安装-5"><a class="header" href="#安装-5">安装</a></h3>
<p>从<a href="https://cat.eduroam.org/">这里</a>为你的机构下载正确的 eduroam_cat 安装程序，并执行它。它将提供一个用户界面，指导你完成这一过程。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connman"><a class="header" href="#connman">ConnMan</a></h1>
<p><a href="https://man.voidlinux.org/connman.8">ConnMan(8)</a> 是一个管理网络连接的守护程序，它被设计得很纤细，并尽可能少地使用资源。<code>connman</code> 软件包包含运行 <code>ConnMan</code> 的基本工具。</p>
<h2 id="启动-connman"><a class="header" href="#启动-connman">启动 ConnMan</a></h2>
<p>要启用 ConnMan 守护进程，首先要<a href="config/network/../services/index.html">禁用</a>任何其他网络管理服务，如 <a href="config/network/./index.html#dhcpcd">dhcpcd</a>、<a href="config/network/./wpa_supplicant.html">wpa_supplicant</a> 或 <code>wicd</code> 。这些服务都控制着网络接口的配置，并且相互干扰。</p>
<p>最后启用 <code>connmand</code> 服务。</p>
<h2 id="配置-connman"><a class="header" href="#配置-connman">配置 ConnMan</a></h2>
<h3 id="connman-cli"><a class="header" href="#connman-cli">ConnMan CLI</a></h3>
<p>connman 软件包包括一个命令行工具，<a href="https://man.voidlinux.org/connmanctl.1">connmanctl(1)</a> ，用来控制网络设置。如果你不提供任何命令，<code>connmanctl</code> 会以交互式 shell 的形式启动。</p>
<p>使用 <code>connmanctl</code> 交互式 shell 建立与接入点的连接可能看起来如下:</p>
<pre><code># connmanctl
&gt; enable wifi
&gt; agent on
&gt; scan wifi
&gt; services
&gt; connect wifi_&lt;uniqueid&gt;
&gt; exit
</code></pre>
<h3 id="connman-前端工具"><a class="header" href="#connman-前端工具">ConnMan 前端工具</a></h3>
<p>ConnMan 还有许多其他的前端，包括用于系统托盘的 <code>connman-ui</code> 、用于 GTK 的 <code>connman-gtk</code>、用于 QT 的 <code>cmst</code> 和用于基于 ncurses 的用户界面的 <code>connman-ncurses</code>。</p>
<h2 id="防止-dns-被-connman-覆盖"><a class="header" href="#防止-dns-被-connman-覆盖">防止 DNS 被 ConnMan 覆盖</a></h2>
<p>创建 <code>/etc/sv/connmand/conf</code> 内容如下:</p>
<pre><code>OPTS=&quot;--nodnsproxy&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络文件系统"><a class="header" href="#网络文件系统">网络文件系统</a></h1>
<h2 id="nfs"><a class="header" href="#nfs">NFS</a></h2>
<h3 id="挂载-nfs-共享"><a class="header" href="#挂载-nfs-共享">挂载 NFS 共享</a></h3>
<p>要挂载一个 NFS 共享，首先要安装 <code>nfs-utils</code> 和 <code>sv-netmount</code> 软件包。</p>
<p>在挂载 NFS 共享之前，请<a href="config/./services/index.html#enabling-services">启用</a> <code>statd</code>、<code>rpcbind</code> 和 <code>netmount</code> 服务。如果服务器支持<code>nfs4</code>，<code>statd</code> 服务就没有必要了。</p>
<p>在挂载 NFS 共享之前，请启用 statd、rpcbind 和 netmount 服务。如果服务器支持nfs4，statd服务就没有必要了。</p>
<p>挂载 NFS 共享 ：</p>
<pre><code># mount -t &lt;mount_type&gt; &lt;host&gt;:/path/to/sourcedir /path/to/destdir
</code></pre>
<p><code>&lt;mount_type&gt;</code> 如果服务器支持，应该是 <code>nfs4</code>，否则就是 <code>nfs</code>。<code>&lt;host&gt;</code> 可以是服务器的主机名或IP地址。</p>
<p>安装选项可以在 <a href="https://man.voidlinux.org/mount.nfs.8">mount.nfs(8)</a> 中找到，而卸载选项可以在 <a href="https://man.voidlinux.org/umount.nfs.8">umount.nfs(8)</a> 中找到。</p>
<p>例如，将 <code>192.168.1.99</code> 的服务器上的 <code>/volume</code> 连接到你本地系统上现有的 <code>/mnt/volume</code> 目录：</p>
<pre><code># mount -t nfs 192.168.1.99:/volume /mnt/volume
</code></pre>
<p>要想在系统启动时挂载该目录，请在 <a href="https://man.voidlinux.org/fstab.5">fstab(5)</a> 中添加一个条目：</p>
<pre><code>192.168.1.99:/volume /mnt/volume nfs rw,hard 0 0
</code></pre>
<p>请参考 <a href="https://man.voidlinux.org/nfs.5">nfs(5)</a> 以了解关于可用的挂载选项的信息。</p>
<h3 id="设置服务器-nfsv4-禁用-kerberos"><a class="header" href="#设置服务器-nfsv4-禁用-kerberos">设置服务器 (NFSv4, 禁用 Kerberos)</a></h3>
<p>要运行 NFS 服务器，首先安装 <code>nfs-utils</code> 包。</p>
<p>编辑 <code>/etc/exports</code> 并添加共享卷:</p>
<pre><code>/storage/foo    *.local(rw,no_subtree_check,no_root_squash)
</code></pre>
<p>这一行将 <code>/storage/foo</code> 目录导出到本地域的任何主机上，并具有读/写权限。关于 <code>no_subtree_check</code> 和 <code>no_root_squash</code> 选项的信息，以及更广泛的可用选项，请参考 <a href="https://man.voidlinux.org/exports.5">exports(5)</a>。</p>
<p>最后<a href="config/./services/index.html#enabling-services">启用</a>  <code>rpcbind</code>, <code>statd</code>, 和 <code>nfs-server</code> 服务。</p>
<p>这将启动您的 NFS 服务器。 要检查共享是否正常工作，请使用 <a href="https://man.voidlinux.org/showmount.8">showmount(8)</a> 工具来检查 NFS 服务器状态： </p>
<pre><code># showmount -e localhost
</code></pre>
<p>你可以使用 <a href="https://man.voidlinux.org/nfs.conf.5">nfs.conf(5)</a> 来配置你的服务器</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="session-和-seat-管理"><a class="header" href="#session-和-seat-管理">Session 和 Seat 管理</a></h1>
<p>Session 和 Seat 管理不是每个设置都需要的，但它可以用来安全地创建临时的运行时目录，提供对硬件设备和 multi-seat 功能的访问，并控制系统关闭。</p>
<h2 id="d-bus"><a class="header" href="#d-bus">D-Bus</a></h2>
<p>D-Bus 是一种 IPC（进程间通信）机制，由 Linux 中的用户空间软件使用。D-Bus 可以提供一个 system bus 和/或 session bus ，后者是针对用户 session 的。</p>
<ul>
<li>要提供 system bus,你应该<a href="config/./services/index.html">启用</a> <code>dbus</code> 服务。这可能需要重新启动系统才能正常工作。 </li>
<li>要提供 session bus，你可以用 <a href="https://man.voidlinux.org/dbus-run-session.1">dbus-run-session(1)</a> 启动一个指定的程序（通常是一个窗口管理器或交互式外壳）。大多数桌面环境，如果通过一个适当的显示管理器启动，将自己启动一个 D-Bus session。</li>
</ul>
<p>请注意，有些软件假定存在 system bus，也有其他软件则假定存在 session bus。</p>
<h2 id="elogind-1"><a class="header" href="#elogind-1">elogind</a></h2>
<p><a href="https://man.voidlinux.org/elogind.8">elogind(8)</a> 管理用户登录和系统电源，是 <code>systemd-logind</code> 的独立版本。elogind 为大多数桌面环境和 Wayland 合成器提供必要的功能。它也可以成为不用 root 的 <a href="config/./graphical-session/xorg.html">Xorg</a>的机制之一。</p>
<p>请阅读 &quot;<a href="config/./power-management.html">电源管理</a>&quot; 部分，了解安装 elogind 前需要考虑的事项。</p>
<p>为了使用它的功能，请安装 <code>elogind</code> 包并确保 <a href="config/session-management.html#d-bus">系统 D-Bus</a>被启用。你可能需要退出并重新登录.</p>
<p>如果你在使用 elogind 时有任何问题，请<a href="config/./services/index.html">启用</a>其服务，因为等待 D-Bus 的激活会导致问题。</p>
<p>有一种替代的 D-Bus 配置，它利用 elogind 的功能，如 seat 检测。它需要安装 <code>dbus-elogind</code>、<code>dbus-elogind-libs</code> 和 <code>dbus-elogind-x11</code> 软件包。</p>
<h2 id="seatd"><a class="header" href="#seatd">seatd</a></h2>
<p><a href="https://man.voidlinux.org/seatd.1">seatd(1)</a>  是一个最小的 seat 管理守护程序，是 elogind 的替代品，主要用于 <a href="config/./graphical-session/wayland.html#standalone-compositors">wlroots 合成器</a>。</p>
<p>要使用它，请安装 <code>seatd</code> 软件包并启用其服务。如果你想让非 root 用户能够访问 seatd 会话，请将他们加入 <code>_seatd</code> 组。</p>
<p>请注意，与 elogind 不同，seatd 除了管理 seats 之外，不做任何事情。</p>
<h2 id="xdg_runtime_dir"><a class="header" href="#xdg_runtime_dir">XDG_RUNTIME_DIR</a></h2>
<p><code>XDG_RUNTIME_DIR</code> 是一个由 <a href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html">XDG 基本目录规范定义</a>的环境变量。它的值设置了基本目录的路径，程序应该在这个目录下存储用户特定的运行时文件。</p>
<p>安装 <a href="config/session-management.html#elogind">elogind</a> 作为你的 session 管理器来自动设置 <code>XDG_RUNTIME_DIR</code>。</p>
<p>或者，通过 shell 手动设置环境变量。请确保创建一个专门的用户目录，并将其权限设置为 <code>700</code>。一个好的默认位置是 <code>/run/user/$（id -u）</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图形-session-2"><a class="header" href="#图形-session-2">图形 Session</a></h1>
<p>为了配置一个图形 session ，你需要：</p>
<ul>
<li><a href="config/graphical-session/./graphics-drivers/index.html">显卡驱动</a></li>
<li>为你的图形 session 提供基础: <a href="config/graphical-session/./xorg.html">Xorg</a> or
<a href="config/graphical-session/./wayland.html">Wayland</a></li>
</ul>
<p>你可能还需要:</p>
<ul>
<li><a href="config/graphical-session/../session-management.html">Session 管理工具</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="显卡驱动"><a class="header" href="#显卡驱动">显卡驱动</a></h1>
<p>本节涵盖了基本的图形设置，取决于你系统的硬件配置。</p>
<h2 id="章节内容-3"><a class="header" href="#章节内容-3">章节内容</a></h2>
<ul>
<li><a href="config/graphical-session/graphics-drivers/./amd.html">AMD or ATI</a></li>
<li><a href="config/graphical-session/graphics-drivers/./intel.html">Intel</a></li>
<li><a href="config/graphical-session/graphics-drivers/./nvidia.html">NVIDIA</a></li>
<li><a href="config/graphical-session/graphics-drivers/./optimus.html">NVIDIA Optimus</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="amd-or-ati"><a class="header" href="#amd-or-ati">AMD or ATI</a></h1>
<p>AMD GPU支持需要 <code>linux-firmware-amd</code> 软件包。如果你已经安装了 <code>linux</code> 或 <code>linux-lts</code> 软件包，它将作为一个依赖项被安装。如果你安装了一个特定版本的内核包（例如 <code>linux5.4</code>），可能需要手动安装 <code>linux-firmware-amd</code> 。</p>
<h2 id="opengl"><a class="header" href="#opengl">OpenGL</a></h2>
<p>安装 Mesa DRI 软件包，<code>mesa-dri</code>。这已经包含在 <code>xorg</code> 元包中了，但在通过 <code>xorg-minimal</code> 安装 Xorg 或运行 Wayland 合成器时需要它。</p>
<h2 id="vulkan"><a class="header" href="#vulkan">Vulkan</a></h2>
<p>安装 <code>vulkan-loader</code>。然后安装Mesa AMD Vulkan驱动，<code>mesa-vulkan-radeon</code> ；或者 GPUOpen AMD Vulkan 驱动，<code>amdvlk</code>。</p>
<h2 id="xorg"><a class="header" href="#xorg">Xorg</a></h2>
<p>安装 <code>xorg</code> 元包将安装<code>xf86-video-amdgpu</code> ，对于较旧的硬件，安装 <code>xf86-video-ati</code>。如果你安装了 <code>xorg-minimal</code> ，选择这些Xorg驱动包中的一个来匹配你的硬件。<code>amdgpu</code> 驱动应该支持AMD的 &quot;Graphics Core Next 1.2 &quot;架构的显卡，大约在2012年推出。</p>
<h2 id="视频加速"><a class="header" href="#视频加速">视频加速</a></h2>
<p>请安装 <code>mesa-vaapi</code> 和 <code>mesa-vdpau</code> 软件包.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intel-1"><a class="header" href="#intel-1">Intel</a></h1>
<p>英特尔 GPU 支持需要 <code>linux-firmware-intel</code> 软件包。如果你已经安装了 <code>linux</code> 或 <code>linux-lts</code> 软件包，它将作为一个依赖项被安装。如果你安装了一个特定版本的内核包（例如，linux5.4），可能需要手动安装<code>linux-firmware-intel</code>。</p>
<h2 id="opengl-1"><a class="header" href="#opengl-1">OpenGL</a></h2>
<p>OpenGL 需要 <code>mesa-dri</code>包。这是由 <code>xorg</code> 元包提供的，但在使用 <code>xorg-minimal</code> 包或运行 Wayland 合成器时，需要手动安装。</p>
<h2 id="vulkan-1"><a class="header" href="#vulkan-1">Vulkan</a></h2>
<p>安装 Khronos Vulkan Loader 和 Mesa Intel Vulkan 驱动包，分别是 <code>vulkan-loader</code> 和 <code>mesa-vulkan-intel</code>。</p>
<h2 id="视频加速-1"><a class="header" href="#视频加速-1">视频加速</a></h2>
<p>安装 <code>intel-video-accel</code> 元包:</p>
<p>这将安装所有英特尔 VA-API 驱动，将默认使用 <code>intel-media-driver</code>，以下选择可以在运行时通过环境变量 <code>LIBVA_DRIVER_NAME</code> 覆盖。</p>
<div class="table-wrapper"><table><thead><tr><th>驱动包</th><th>支持的 GPU Gen</th><th>Explicit selection</th></tr></thead><tbody>
<tr><td><code>libva-intel-driver</code></td><td>up to Coffee Lake</td><td><code>LIBVA_DRIVER_NAME=i965</code></td></tr>
<tr><td><code>intel-media-driver</code></td><td>from Broadwell</td><td><code>LIBVA_DRIVER_NAME=iHD</code></td></tr>
</tbody></table>
</div>
<h2 id="故障排除-1"><a class="header" href="#故障排除-1">故障排除</a></h2>
<p>Void 打包的内核被配置为 <code>CONFIG_INTEL_IOMMU_DEFAULT_ON=y</code>，这可能导致其图形驱动的问题，正如<a href="https://www.kernel.org/doc/html/latest/x86/iommu.html#graphics-problems">内核文档</a>所报告的。为了解决这个问题，有必要禁用集成 GPU 的 IOMMU。这可以通过在你的<a href="config/graphical-session/graphics-drivers/../../kernel.html#cmdline">内核 cmdline</a> 中添加 <code>intel_iommu=igfx_off</code>来完成。这个问题预计会发生在 Broadwell 一代的内部 GPU 上。如果你有另一个内部 GPU，而你的问题被这个内核选项修复了，你应该提交一个 bug，向内核开发者报告这个问题。</p>
<p>对于较新的英特尔芯片组，<a href="config/graphical-session/graphics-drivers/../xorg.html#ddx">DDX</a> 驱动程序可能会干扰正确的操作。表现为图形加速不工作和一般图形不稳定。如果是这种情况，请尝试删除所有 <code>xf86-video-*</code> 软件包。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nvidia"><a class="header" href="#nvidia">NVIDIA</a></h1>
<h2 id="nouveau-开源驱动"><a class="header" href="#nouveau-开源驱动">nouveau (开源驱动)</a></h2>
<p>这是一个主要由社区开发的逆向工程驱动，由 Nvidia 提供一些文档。它往往在旧硬件上表现良好，并且大部分 Wayland 合成器可以用。</p>
<p>在写这篇文章的时候，从第二代 Maxwell（GTX 9xx）开始的显卡无法用 <code>nouveau</code> 发挥其全部潜力。这是因为 <code>linux-firmware</code> 集合中缺少重新锁定这些显卡其启动频率所需的签名固件块。</p>
<p>要在 Wayland 上使用 <code>nouveau</code>，你只需要 <code>mesa-dri</code> 包，它提供了 OpenGL 驱动。在 X11 上，你还需要一个合适的 Xorg 驱动。你可以安装 <code>xf86-video-nouveau</code> 或者使用与 Xorg 捆绑的通用模式设置驱动程序（这是基于 Tegra 的 ARM 板的唯一选择）。前者可以利用 GPU 特定的 2D 加速，这在具有专门的固定功能硬件的旧卡上主要是有用的（模式化驱动程序将通过 GLAMOR 使用 OpenGL 加速 2D）。当有疑问时，首先尝试 <code>xf86-video-nouveau</code> 是个好主意。</p>
<p>注意: 如果你使用 <code>xorg</code> 元包，<code>xf86-video-nouveau</code> 通常会默认安装。如果你使用 <code>xorg-minimal</code>，你将需要直接或通过 <code>xorg-video-drivers</code> 手动安装它。</p>
<h2 id="nvidia-专有驱动程序"><a class="header" href="#nvidia-专有驱动程序">nvidia (专有驱动程序)</a></h2>
<p>专有的驱动程序可以在<a href="config/graphical-session/graphics-drivers/../../../xbps/repositories/index.html#nonfree">非自由软件库</a>中找到。</p>
<p>检查你的显卡是否属于 <a href="https://www.nvidia.com/en-us/drivers/unix/legacy-gpu/">legacy 分支</a>。如果不是，请安装 <code>nvidia</code> 软件包。否则，你应该安装 legacy 驱动程序，即 <code>nvidia470</code> 或 <code>nvidia390</code> 。较早的传统驱动程序 <code>nvidia340</code> 已不再可用，我们鼓励用户切换到 <code>nouveau</code>。</p>
<div class="table-wrapper"><table><thead><tr><th>Brand</th><th>Type</th><th>Model</th><th>Driver Package</th></tr></thead><tbody>
<tr><td>NVIDIA</td><td>Proprietary</td><td>800+</td><td><code>nvidia</code></td></tr>
<tr><td>NVIDIA</td><td>Proprietary</td><td>600/700</td><td><code>nvidia470</code></td></tr>
<tr><td>NVIDIA</td><td>Proprietary</td><td>400/500 Series</td><td><code>nvidia390</code></td></tr>
</tbody></table>
</div>
<p>专有驱动程序通过 <a href="config/graphical-session/graphics-drivers/../../kernel.html#dynamic-kernel-module-support-dkms">DKMS</a> 整合到内核中。</p>
<p>该驱动提供更好的性能和功率处理，建议在需要性能的地方使用</p>
<h2 id="支持-32-位的驱动程序-glibc-独有"><a class="header" href="#支持-32-位的驱动程序-glibc-独有">支持 32 位的驱动程序 (glibc 独有)</a></h2>
<p>为了运行支持驱动的32位程序，你需要安装额外的软件包。</p>
<p>如果使用 <code>nouveau</code> 驱动，请安装 <code>mesa-dri-32bit</code> 软件包。</p>
<p>如果使用 <code>nvidia</code> 驱动，请安装 <code>nvidia&lt;x&gt;-libs-32bit</code> 软件包。<code>&lt;x&gt;</code> 代表传统驱动程序的版本（<code>470</code> 或 <code>390</code>），或者可以留空，代表主要驱动程序。</p>
<h2 id="从-nvidia-切换到-nouveau"><a class="header" href="#从-nvidia-切换到-nouveau">从 nvidia 切换到 nouveau</a></h2>
<h3 id="卸载-nvidia"><a class="header" href="#卸载-nvidia">卸载 nvidia</a></h3>
<p>为了切换到 <code>nouveau</code> 驱动程序，请安装 <code>nouveau</code> 驱动程序（如果尚未安装），然后根据情况删除 <code>nvidia</code>、<code>nvidia470</code> 或 <code>nvidia390</code> 包。</p>
<p>如果你使用的是过时的 <code>nvidia340</code> 驱动，你可能需要在删除 <code>nvidia340</code> 包之后再安装 <code>libglvnd</code> 包。</p>
<h3 id="保留两个驱动程序"><a class="header" href="#保留两个驱动程序">保留两个驱动程序</a></h3>
<p>可以使用 <code>nouveau</code> 驱动同时还有 <code>nvidia</code> 驱动程序。 为此，请删除 <code>nouveau</code> 在 <code>/etc/modprobe.d/nouveau_blacklist.conf</code> , <code>/usr/lib/modprobe.d/nvidia.conf</code>， 或者 <code>/usr/lib/modprobe.d/nvidia-dkms.conf</code> 的黑名单注释掉： </p>
<pre><code>#blacklist nouveau
</code></pre>
<p>对于 Xorg，通过创建包含以下内容的文件 <code>/etc/X11/xorg.conf.d/20-nouveau.conf</code>，指定它应该加载 <code>nouveau</code>驱动而不是 nvidia 驱动：</p>
<pre><code>Section &quot;Device&quot;
    Identifier &quot;Nvidia card&quot;
    Driver &quot;nouveau&quot;
EndSection
</code></pre>
<p>您可能需要重新启动系统才能使这些更改生效。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nvidia-optimus"><a class="header" href="#nvidia-optimus">NVIDIA Optimus</a></h1>
<p>NVIDIA Optimus 指的是笔记本电脑上的双图形配置，包括一个英特尔集成显卡和一个 NVIDIA 独立显卡。</p>
<p>有不同的方法来利用 NVIDIA GPU，这取决于你的硬件所支持的驱动版本。</p>
<p>为了确定要安装的正确驱动程序，只看 NVIDIA 网站上的 &quot;支持的产品&quot; 列表是不够的，因为它们不能保证能在 Optimus 配置中工作。因此，唯一的办法是尝试安装最新的 <code>nvidia</code>，重新启动，并查看内核日志。如果你的设备不被支持，你会看到这样的信息:</p>
<pre><code>NVRM: The NVIDIA GPU xxxx:xx:xx.x (PCI ID: xxxx:xxxx)
NVRM: installed in this system is not supported by the xxx.xx
NVRM: NVIDIA Linux driver release.  Please see 'Appendix
NVRM: A - Supported NVIDIA GPU Products' in this release's
NVRM: README, available on the Linux driver download page
NVRM: at www.nvidia.com.
</code></pre>
<p>这意味着你必须卸载 <code>nvidia</code> 并安装传统的 <code>nvidia390</code>。</p>
<p>Void 支持的方法的摘要，这些方法是相互排斥的。</p>
<p><a href="config/graphical-session/graphics-drivers/optimus.html#prime-render-offload">PRIME Render Offload</a></p>
<ul>
<li>适用于 <code>nvidia</code> 和 <code>nvidia470</code></li>
<li>允许在每个应用的基础上切换到英伟达 GPU。</li>
<li>更加灵活，但省电能力取决于硬件（pre-Turing 之前的设备不会完全关闭）。</li>
<li></li>
</ul>
<p>Offloading Graphics Display with RandR 1.4</p>
<ul>
<li>可在 <code>nvidia</code> , <code>nvidia470</code> 和 <code>nvidia390</code> 上使用</li>
<li>允许选择在 X session 开始时使用哪个 GPU</li>
<li>灵活性较差，但允许用户在不使用 NVIDIA GPU 时完全关闭，从而节省电力</li>
</ul>
<p><a href="config/graphical-session/graphics-drivers/optimus.html#bumblebee">Bumblebee</a></p>
<ul>
<li>可在 <code>nvidia</code> , <code>nvidia470</code> 和 <code>nvidia390</code> 上使用</li>
<li>允许在每个应用的基础上切换到英伟达 GPU</li>
<li>非官方的方法，性能不佳</li>
</ul>
<p><a href="config/graphical-session/graphics-drivers/optimus.html#nouveau-prime">Nouveau PRIME</a></p>
<ul>
<li>使用开源的驱动程序 <code>nouveau</code></li>
<li>允许在每个应用的基础上切换到英伟达GPU</li>
<li><code>nouveau</code> 是一个反向工程的驱动程序，性能很差。</li>
</ul>
<p>你可以通过在 <code>glxinfo</code> 命令的输出中搜索渲染器字符串来检查当前使用的 GPU。为此，有必要安装 <code>glxinfo</code> 软件包。对于下面的前两个方案，也可以通过检查 <code>nvidia-smi</code> 的输出来验证一个进程是否在使用 NVIDIA GPU。</p>
<h2 id="prime-render-offload"><a class="header" href="#prime-render-offload">PRIME Render Offload</a></h2>
<p>在这种方法中，在执行要在 NVIDIA GPU 上渲染的应用程序时，通过设置环境变量来完成 GPU 切换。封装脚本 <code>prime-run</code> 可从 <code>nvidia</code> 软件包中获得，可以如下所示使用。</p>
<pre><code>$ prime-run &lt;application&gt;
</code></pre>
<p>了解更多信息，请参见 NVIDIA 的
<a href="https://download.nvidia.com/XFree86/Linux-x86_64/440.44/README/primerenderoffload.html">README</a></p>
<h2 id="bumblebee"><a class="header" href="#bumblebee">Bumblebee</a></h2>
<p>启用 <code>bumblebeed</code> 服务并将用户添加到 <code>bumblebee</code> 组。这需要重新登录才能生效。</p>
<p>用 <code>optirun</code> 在 NVIDIA GPU 上运行要渲染的应用程序。</p>
<pre><code>$ optirun &lt;application&gt;
</code></pre>
<h2 id="nouveau-prime"><a class="header" href="#nouveau-prime">Nouveau PRIME</a></h2>
<p>这种方法使用开源的 <code>nouveau</code> 驱动程序。如果安装了NVIDIA驱动程序，就有必要对<a href="config/graphical-session/graphics-drivers/./nvidia.html#nvidia-%E5%88%87%E6%8D%A2%E5%88%B0-nouveau">系统进行配置以使用<code>nouveau</code></a>。</p>
<p>设置 <code>DRI_PRIME=1</code> 以在 NVIDIA GPU 上运行一个应用程序。</p>
<pre><code>$ DRI_PRIME=1 &lt;application&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xorg-1"><a class="header" href="#xorg-1">Xorg</a></h1>
<p>本节详细介绍了手动安装和配置 Xorg 显示服务器以及常见的相关服务和工具。如果你只想安装一个完整的桌面环境，建议尝试 <a href="config/graphical-session/../../installation/live-images/index.html#xfce-image">xfce 镜像</a>。</p>
<h2 id="安装-6"><a class="header" href="#安装-6">安装</a></h2>
<p>Void 提供了一个全面的 <code>xorg</code> 包，它安装了服务器和所有免费的视频驱动、输入驱动、字体和基本应用程序。这个软件包是一个安全的选择，对于大多数不需要专有视频驱动程序的系统来说应该是足够的。</p>
<p>如果你想只选择你需要的软件包，<code>xorg-minimal</code> 软件包 <em>只包含</em> 基本的 xorg 服务器。只安装 <code>xorg-minimal</code>，你可能需要安装一个字体包（如 <code>xorg-fonts</code>），一个终端模拟器（如 <code>xterm</code>），以及一个窗口管理器，以拥有一个可用的图形系统。</p>
<h2 id="显卡驱动-1"><a class="header" href="#显卡驱动-1">显卡驱动</a></h2>
<p>Void同时提供开源和专有（non-free）视频驱动。</p>
<h3 id="开源驱动"><a class="header" href="#开源驱动">开源驱动</a></h3>
<p>Xorg 可以使用两类开源的驱动程序。DDX 或 modesetting。</p>
<h4 id="ddx"><a class="header" href="#ddx">DDX</a></h4>
<p>DDX 驱动默认与 <code>xorg</code> 包一起安装，如果安装了 <code>xorg-minimal</code> 包，也可以单独安装。它们是由 <code>xf86-video-*</code> 软件包提供的。</p>
<p>对于高级配置，请参见与厂商名称相对应的手册页，如
<a href="https://man.voidlinux.org/intel.4">intel(4)</a>.</p>
<h4 id="modesetting"><a class="header" href="#modesetting">Modesetting</a></h4>
<p>Modesetting  需要 <code>mesa-dri</code> 软件包，而没有额外的供应商特定的驱动软件包。</p>
<p>如果存在 DDX 驱动，Xorg 默认为 DDX 驱动，所以在这种情况下，必须明确选择 modeetting：请看<a href="config/graphical-session/xorg.html#%E5%BC%BA%E5%88%B6%E8%AE%BE%E7%BD%AE-modesetting-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F">强制设置 modesetting 驱动程序</a>。</p>
<p>有关高级配置，请参阅 
<a href="https://man.voidlinux.org/modesetting.4">modesetting(4)</a>.</p>
<h3 id="专有驱动程序"><a class="header" href="#专有驱动程序">专有驱动程序</a></h3>
<p>Void 还提供专有的 <a href="config/graphical-session/./graphics-drivers/nvidia.html">NVIDIA 驱动程序</a>， 中可用在<a href="config/graphical-session/../../xbps/repositories/index.html#nonfree">非自由存储库</a>。 </p>
<h2 id="输入驱动"><a class="header" href="#输入驱动">输入驱动</a></h2>
<p>Xorg 有许多可用的输入驱动。如果安装了 <code>xorg-minimal</code>，而某一设备没有响应，或者表现得出乎意料，那么不同的驱动程序可能会纠正这一问题。这些驱动可以抓取从电源按钮到鼠标和键盘的一切。它们是由 <code>xf86-input-*</code> 软件包提供的。</p>
<h2 id="xorg-配置"><a class="header" href="#xorg-配置">Xorg 配置</a></h2>
<p>虽然 Xorg 通常会自动检测驱动程序，而且不需要配置，但特定键盘驱动程序的配置可能看起来像一个文件 <code>/etc/X11/xorg.conf.d/30-keyboard.conf</code> ，其内容是这样的:</p>
<pre><code>Section &quot;InputClass&quot;
  Identifier &quot;keyboard-all&quot;
  Driver &quot;evdev&quot;
  MatchIsKeyboard &quot;on&quot;
EndSection
</code></pre>
<h3 id="强制设置-modesetting-驱动程序"><a class="header" href="#强制设置-modesetting-驱动程序">强制设置 modesetting 驱动程序</a></h3>
<p>创建文件 <code>/etc/X11/xorg.conf.d/10-modesetting.conf</code> ：</p>
<pre><code>Section &quot;Device&quot;
    Identifier &quot;GPU0&quot;
    Driver &quot;modesetting&quot;
EndSection
</code></pre>
<p>并重新启动Xorg。验证配置是否实践过了：</p>
<pre><code>$ grep -m1 '(II) modeset([0-9]+):' /var/log/Xorg.0.log
</code></pre>
<p>如果有匹配的，就说明正在使用 modesetting 。</p>
<h2 id="启动-x-sessions"><a class="header" href="#启动-x-sessions">启动 X Sessions</a></h2>
<h3 id="startx"><a class="header" href="#startx">startx</a></h3>
<p><code>xinit</code> 包提供了 <a href="https://man.voidlinux.org/startx.1">startx(1)</a> 脚本作为 <a href="https://man.voidlinux.org/xinit.1">xinit(1)</a> 前端，它可以用来从控制台启动 X 会话。例如，要启动 <a href="https://man.voidlinux.org/i3.1">i3(1)</a>，编辑 <code>~/.xinitrc</code>，在最后一行包含 <code>exec /bin/i3</code>。</p>
<p>要在 X 会话中同时启动任意程序，请在 <code>~/.xinitrc</code> 中的最后一行之前添加它们。例如，要在启动 i3 之前启动<a href="https://man.voidlinux.org/pipewire.1">pipewire(1)</a> ，在最后一行之前添加 <code>pipewire &amp;</code>。</p>
<p>下面是一个启动 <code>pipewire</code> 和 <code>i3</code> 的 <code>~/.xinitrc</code> 文件:</p>
<pre><code>pipewire &amp;
exec /bin/i3
</code></pre>
<p>然后调用 <code>startx</code> 来启动 session 。</p>
<p>如果需要一个 D-Bus 会话总线，你可以<a href="config/graphical-session/../session-management.html#d-bus">手动启动一个</a>。</p>
<h3 id="显示管理器"><a class="header" href="#显示管理器">显示管理器</a></h3>
<p>显示管理器（DMs）提供了一个图形化的登录界面。Void 仓库中有许多 DM，包括 <code>gdm</code>（GNOME 的 DM）、<code>sddm</code>（KDE 的 DM）和 <code>lightdm</code>。当设置一个显示管理器时，一定要在启用前<a href="config/graphical-session/../services/index.html#testing-services">测试该服务</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wayland"><a class="header" href="#wayland">Wayland</a></h1>
<p>本节详细介绍了 Wayland 合成器以及相关服务和工具的手动安装和配置。</p>
<h2 id="安装-7"><a class="header" href="#安装-7">安装</a></h2>
<p>不像 <a href="config/graphical-session/./xorg.html">Xorg</a>, Wayland 的实现将显示服务器、窗口管理器和合成器结合在一个应用程序中。</p>
<h3 id="桌面环境"><a class="header" href="#桌面环境">桌面环境</a></h3>
<p>GNOME、KDE Plasma 和 Enlightenment 有 Wayland 会话。GNOME 默认使用其 Wayland 会话。当使用这些桌面环境时，用 GTK+ 构建的应用程序会自动选择 Wayland 后端，而 QT5 和 EFL 应用如在 KDE 或 Enlightenment 之外使用，可能需要分别<a href="config/graphical-session/wayland.html#%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">设置环境变量</a> </p>
<h3 id="混成器"><a class="header" href="#混成器">混成器</a></h3>
<p>Void Linux 目前打包了以下 Wayland 混成器:</p>
<ul>
<li>Weston：本身还是其它 Wayland 混成器开发的实现参考</li>
<li>Sway: 兼容 i3 的 Wayland 混成器，基于 wlroots</li>
<li>Wayfire 3D 混成器，受 Compiz 启发并基于 wlroots 开发</li>
<li>Hikari：基于 wlroots 并受 cwm 启发开发，在 FreeBSD 上开发很活跃，但也支持 Linux</li>
<li>Cage: 显示单个全屏应用程序（就像自助取款机的显示界面那样）</li>
<li>River：动态平铺 Wayland 混成器，受 dwm 和 bspwm 启发</li>
<li>labwc: 是一个堆叠式混成器，灵感来自　OpenBox</li>
</ul>
<h3 id="显卡驱动-2"><a class="header" href="#显卡驱动-2">显卡驱动</a></h3>
<p>GNOME 和 KDE Plasma 都有针对 Wayland 的 EGLStreams 后端，这意味着它们可以使用 NVIDIA 专有的驱动程序。其他大多数 Wayland 混成器需要实现 GBM 接口的驱动。用于这一目的的主要驱动由 <code>mesa-dri</code> 软件包提供。<a href="config/graphical-session/./graphics-drivers/index.html">图形化驱动</a>&quot; 一节有关于在不同系统中设置图形的更多细节。</p>
<h3 id="seat-management"><a class="header" href="#seat-management">Seat management</a></h3>
<p>Wayland 混成器需要某种方式来控制视频显示和访问输入设备。在 Void 系统中，这需要一个 seat manager 服务，它可以是 elogind 或 seatd。
启用它们将在<a href="config/graphical-session/../session-management.html">&quot;Session 和 Seat Management&quot;</a> 环节中解释。</p>
<h3 id="原生应用程序"><a class="header" href="#原生应用程序">原生应用程序</a></h3>
<p>基于 <a href="https://wayland.freedesktop.org/qt5.html">Qt5</a> 的应用程序需要安装 <code>qt5-wayland</code> 包，并设置环境变量<code>QT_QPA_PLATFORM=wayland-egl</code> 来启用其 Wayland 后端。一些KDE特定的应用程序也需要安装 <code>kwayland</code> 包。
基于 <a href="https://wayland.freedesktop.org/efl.html">EFL</a> 的应用程序需要设置环境变量 <code>ELM_DISPLAY=wl </code>，如果不设置，可能会有问题，因为它不能正确支持XWayland。
基于 <a href="https://libsdl.org">SDL</a> 的应用程序需要设置环境变量 <code>SDL_VIDEODRIVER=wayland</code>。
基于 <a href="https://wiki.gnome.org/Initiatives/Wayland/GTK%2B">GTK+</a> 的应用程序应该会自动使用Wayland后端。关于其他工具包的信息可以在  <a href="https://wayland.freedesktop.org/toolkits.html">Wayland 文档</a>里找到。</p>
<p>多媒体软件,如 <a href="https://man.voidlinux.org/mpv.1">mpv(1)</a>,
<a href="https://man.voidlinux.org/vlc.1">vlc(1)</a> 和 <code>imv</code> 可以在 Wayland 上原生工作。</p>
<h4 id="网页浏览器"><a class="header" href="#网页浏览器">网页浏览器</a></h4>
<p>Mozilla Firefox 带有一个 Wayland 后端，默认情况下是禁用的。要启用 Wayland 后端，可以在运行 <code>firefox</code> 之前设置环境变量 <code>MOZ_ENABLE_WAYLAND=1</code>，或者使用提供的 <code>firefox-wayland</code> 脚本。</p>
<p>基于GTK+或Qt5的浏览器，如 Midori 和 <a href="https://man.voidlinux.org/qutebrowser.1">qutebrowser(1)</a> 应该可以在Wayland上正常工作。</p>
<h4 id="在-wayland-中运行-xorg-程序"><a class="header" href="#在-wayland-中运行-xorg-程序">在 Wayland 中运行 Xorg 程序</a></h4>
<p>如果一个应用程序不支持 Wayland，它仍然可以在 Wayland 环境下使用。XWayland 是一个 X 服务器，它为大多数 Wayland 混成器弥补了这一缺陷，并作为大多数混成器的依赖项被安装。它的软件包是 <code>xorg-server-xwayland</code>。对于 Weston，应安装 <code>weston-xwayland</code>。</p>
<h2 id="配置-4"><a class="header" href="#配置-4">配置</a></h2>
<p>Wayland 库需要 <a href="config/graphical-session/../session-management.html#xdg_runtime_dir"><code>XDG_RUNTIME_DIR</code></a> 环境变量来确定 Wayland 套接字的目录</p>
<p>也有可能一些应用程序以某种方式使用 <code>XDG_SESSION_TYPE</code> 环境变量，这需要你将其设置为 <code>wayland</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字体-1"><a class="header" href="#字体-1">字体</a></h1>
<p>为了在你的图形会话中定制字体显示，您可以使用 <code>/usr/share/fontconfig/conf.avail/</code> 中提供的配置。为此，在 <code>/etc/fonts/conf.d/</code> 中创建一个指向相关 <code>.conf</code> 文件的符号链接，然后使用 <a href="https://man.voidlinux.org/xbps-reconfigure.1">xbps-reconfigure(1)</a> 来重新配置 <code>fontconfig</code> 包。</p>
<p>例如，禁用 bitmap 字体:</p>
<pre><code># ln -s /usr/share/fontconfig/conf.avail/70-no-bitmaps.conf /etc/fonts/conf.d/
# xbps-reconfigure -f fontconfig
</code></pre>
<p>使用 <a href="https://man.voidlinux.org/fc-conflist.1">fc-conflist(1)</a> 来列出哪些配置是有效的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图标"><a class="header" href="#图标">图标</a></h1>
<h2 id="gtk"><a class="header" href="#gtk">GTK</a></h2>
<p>默认情况下，基于 GTK 的应用程序会尝试使用 Adwaita 图标主题作为应用程序的图标。因此，安装 <code>gtk+3</code> 软件包也将安装 <code>adwaita-icon-theme</code> 软件包。如果你想使用不同的主题，请安装相关的软件包，然后在 <code>/etc/gtk-3.0/settings.ini</code> 或 <code>~/.config/gtk-3.0/settings.ini</code> 中指定该主题。在<a href="config/graphical-session/../../xbps/advanced-usage.html#ignoring-packages">忽略</a>软件包后，可以删除 <code>adwaita-icon-theme</code> 。</p>
<p>关于如何在中指定不同的 GTK 图标主题的信息 <code>settings.ini</code> ，请参考<a href="https://developer.gnome.org/gtk3/stable/GtkSettings.html#GtkSettings.properties">GtkSettings 文档</a>，特别是 &quot;<a href="https://developer.gnome.org/gtk3/stable/GtkSettings.html#GtkSettings--gtk-icon-theme-name">gtk-icon-theme-name</a>&quot; 属性。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gnome"><a class="header" href="#gnome">GNOME</a></h1>
<h2 id="安装前"><a class="header" href="#安装前">安装前</a></h2>
<p>GNOME 同时支持 X 和 Wayland Session。按照 &quot;<a href="config/graphical-session/./wayland.html">Wayland</a> &quot;或 &quot;<a href="config/graphical-session/./xorg.html">Xorg</a>&quot; 部分来设置你喜欢的环境。</p>
<p>安装 <code>dbus</code> 软件包，确保 <code>dbus</code> 服务被启用，并重新启动以使变化生效。</p>
<h2 id="安装-8"><a class="header" href="#安装-8">安装</a></h2>
<p>安装 <code>gnome</code> 包以获得一个 GNOME 面环境，其中包括基本的
GNOME 面和 GNOME 应用程序的一个子集。额外的应用程序可以通过
可通过 <code>gnome-apps</code> 包获得</p>
<p>一个最小的 GNOME 桌面环境可以通过安装 <code>gnome-core</code> 包来创建。然而，请注意，并不是所有的 GNOME 的功能都会存在或发挥作用。</p>
<p>如果你需要 <a href="http://www.zeroconf.org/">ZeroConf</a> 支持，请安装 <code>avahi</code> 软件包并启用 <code>avahi-daemon</code> 服务。</p>
<h2 id="启动-gnome"><a class="header" href="#启动-gnome">启动 GNOME</a></h2>
<p><code>gdm</code> 软件包为 GNOME 显示管理器，提供了 gdm <a href="config/graphical-session/../services/index.html#testing-services">服务</a>；在启用该服务之前，请对其进行测试。GDM 默认为通过 <code>mutter</code> 窗口管理器提供 Wayland 会话，但也可以选择 X 会话。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kde"><a class="header" href="#kde">KDE</a></h1>
<h2 id="安装-9"><a class="header" href="#安装-9">安装</a></h2>
<p>安装 <code>kde5</code> 包，而且可以选择， <code>kde5-baseapps</code>软件包来安装附加软件。 </p>
<p>要使用 “Networks” 小部件，请启用 <code>dbus</code> 和 <code>NetworkManager</code> 服务。 </p>
<p>安装 <code>kde5</code> 软件包的同时也安装了 <code>sddm</code> 软件包，它为简单桌面显示管理器提供了 <code>sddm</code> 服务。这个服务依赖于 <code>dbus</code> 服务的<a href="config/graphical-session/../services/index.html#testing-services">启用</a>；在启用之前要测试该服务。你将需要安装 <code>xorg-minimal</code> 包或 <code>xorg</code> 包。默认情况下，SDDM 会启动一个基于 X 的 Plasma 会话，但你可以请求一个基于 Wayland 的 Plasma 会话。</p>
<p>如果你想从 控制台 启动一个基于 X 的会话，使用 <a href="config/graphical-session/./xorg.html#startx">startx</a> 来运行 <code>startplasma-x11</code>。如果是基于 Wayland 的会话，直接运行<code>startplasma-wayland</code>。</p>
<h2 id="dolphin"><a class="header" href="#dolphin">Dolphin</a></h2>
<p>Dolphin 是 KDE 桌面环境的默认文件管理器。 自行安装 <code>dolphin</code> 包，或者可以安装作为的一部分 <code>kde5-baseapps</code> 元包。</p>
<h3 id="缩略图预览"><a class="header" href="#缩略图预览">缩略图预览</a></h3>
<p>要启用缩略图文件预览，请安装 <code>kdegraphics-thumbnailers</code> 软件包。如果你想要视频缩略图，<code>ffmpegthumbs</code> 包也是必要的。在 &quot;Control&quot; -&gt; &quot;Configure Dolphin&quot; -&gt; &quot;General&quot; -&gt;
&quot;Previews&quot; 中勾选相应的方框来启用预览。点击 Dolphin 工具栏上的 &quot; Previews &quot;后，所选文件类型的文件预览将被显示。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多媒体"><a class="header" href="#多媒体">多媒体</a></h1>
<h2 id="音频设置"><a class="header" href="#音频设置">音频设置</a></h2>
<p>要在您的 Void Linux 系统上设置音频，您必须决定是否要使用 <a href="config/media/./pulseaudio.html">PulseAudio</a> 、<a href="config/media/./pipewire.html">PipeWire</a> 或者是 <a href="config/media/./alsa.html">ALSA</a>。 </p>
<p>有些应用程序需要 PulseAudio ，特别是闭源程序，但 <a href="config/media/./pipewire.html">PipeWire</a> 提供了 PulseAudio 的直接替代。</p>
<p>如果没有启用 <a href="config/media/../session-management.html">elogind</a>，就必须在 <code>audio</code> 用户组中，以便能够访问音频设备。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alsa"><a class="header" href="#alsa">ALSA</a></h1>
<p>要使用 ALSA，请安装 <code>alsa-utils</code> 软件包，并确保你的用户是 <code>audio</code> 用户组的成员。</p>
<p><code>alsa-utils</code> 软件包提供了 <code>alsa</code> 服务。启用后，该服务在关机和启动时分别保存和恢复ALSA的状态。</p>
<p>为了允许使用需要 PulseAudio 的软件，安装 <code>apulse</code> 包。<code>apulse</code> 提供了应用程序所期望的 PulseAudio 接口的一部分，将对该接口的调用转化为对 ALSA 的调用。关于使用 <code>apulse</code> 的细节，请查阅<a href="https://github.com/i-rinat/apulse/blob/master/README.md">项目的README</a>。</p>
<h2 id="配置-5"><a class="header" href="#配置-5">配置</a></h2>
<p>默认声卡可以通过 ALSA 配置文件或内核模块选项来指定。</p>
<p>要获得关于加载声卡模块的顺序的信息：</p>
<pre><code>$ cat /proc/asound/modules
 0 snd_hda_intel
 1 snd_hda_intel
 2 snd_usb_audio
</code></pre>
<p>要将不同的卡设置为默认，请编辑 <code>/etc/asound.conf</code> 或每个用户的配置文件 <code>~/.asoundrc</code>:</p>
<pre><code>defaults.ctl.card 2;
defaults.pcm.card 2;
</code></pre>
<p>或在 <code>/etc/modprobe.d/alsa.conf</code> 中指定声卡模块顺序：</p>
<pre><code>options snd_usb_audio index=0
</code></pre>
<h2 id="dmix"><a class="header" href="#dmix">Dmix</a></h2>
<p><code>dmix</code> ALSA 插件允许从多个来源播放声音。对于不支持硬件混音的声卡，默认情况下启用 <code>dmix</code>。要为数字输出启用它，请编辑 <code>/etc/asound.conf</code>:</p>
<pre><code>pcm.dsp {
    type plug
    slave.pcm &quot;dmix&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipewire"><a class="header" href="#pipewire">PipeWire</a></h1>
<p>要使用 PipeWire，请安装 <code>pipewire</code> 软件包。</p>
<p><a href="https://man.voidlinux.org/pipewire.1">pipewire(1)</a> 应以用户身份启动。在你的 session 中用终端模拟器运行 pipewire 命令。</p>
<pre><code>$ pipewire
</code></pre>
<p>当 pipewire 按预期工作时，使用你的桌面环境或 <a href="config/media/../graphical-session/xorg.html#startx">startx</a> 的自动启动机制。<code>pipewire</code> 软件包提供了 <code>pipewire</code> 和<code>pipewire-pulse</code> 系统服务，但在典型的设置中不推荐使用。</p>
<p><code>pipewire</code> 软件包在 <code>/usr/share/applications</code> 中为 <code>pipewire</code> 和 <code>pipewire-pulse</code> 提供桌面入口文件。如果你的环境支持桌面应用<a href="https://specifications.freedesktop.org/autostart-spec/autostart-spec-latest.html">自动启动规范</a>，你可以通过符号链接桌面文件到自动启动目录来启用 <code>pipewire</code>：</p>
<pre><code># ln -s /usr/share/applications/pipewire.desktop /etc/xdg/autostart/pipewire.desktop
</code></pre>
<h2 id="session-管理"><a class="header" href="#session-管理">Session 管理</a></h2>
<p>在 PipeWire 中，会话管理器承担了媒体源的互连以及执行路由策略的责任。没有 Session 管理器，PipeWire 将无法运行。参考 <a href="https://gitlab.freedesktop.org/pipewire/media-session"><code>pipewire-media-session</code></a> 最初在 Void <code>pipewire</code> 包中提供，并配置为默认运行以满足这一要求。然而，<code>pipewire-media-session</code> 已被废弃，作者建议使用 <a href="https://pipewire.pages.freedesktop.org/wireplumber/">WirePlumber</a> 代替它。安装 <code>wireplumber</code> 软件包，以便在 PipeWire 中使用这个 session 管理器。</p>
<blockquote>
<p>如果您安装了早期版本的 Void <code>pipewire</code> 封装，确保更新您的系统以消除任何陈旧的系统配置可能会尝试启动 <code>pipewire-media-session</code>。 之前覆盖的用户要使用的系统配置 <code>wireplumber</code>， 例如,通过放置自定义 <code>pipewire.conf</code> 文件输入 <code>/etc/pipewire</code> 或者 <code>${XDG_CONFIG_HOME}/pipewire</code>， 可能希望将这些覆盖与 <code>/usr/share/pipewire/pipewire.conf</code> 由最新安装的 <code>pipewire</code> 包裹。 如果想禁用之前的覆盖 <code>pipewire-media-session</code>，删除自定义配置可能就足够了。</p>
</blockquote>
<p>有几种方法可以同时启动 <code>wireplumber</code> 和 <code>pipewire</code>。如果你的窗口管理器或桌面环境的自动启动机制被用来启动 <code>pipewire</code>，建议使用相同的机制来启动<code>wireplumber</code>。<code>wireplumber</code> 软件包包括一个 <code>wireplumber.desktop</code> 桌面文件，在这种情况下可能很有用。</p>
<blockquote>
<p>请注意，<code>wireplumber</code> 必须在 <code>pipewire</code> 可执行文件之后启动。桌面应用程序自动启动规范没有规定通过桌面入口文件启动的服务的顺序。当依靠这些文件来启动 <code>pipewire</code> 和 <code>wireplumber</code> 时，请查阅你的窗口管理器或桌面环境的文档，以确定是否可以实现服务的正确排序。</p>
</blockquote>
<p>如果对独立的 <code>pipewire</code> 和 <code>wireplumber</code> 服务进行适当排序是不可行的，可以配置 <code>pipewire</code> 来直接启动会话管理器。这可以通过运行</p>
<pre><code># mkdir -p /etc/pipewire/pipewire.conf.d
# ln -s /usr/share/examples/wireplumber/10-wireplumber.conf /etc/pipewire/pipewire.conf.d/
</code></pre>
<p>系统配置，或者，对于每个用户的配置，运行</p>
<pre><code>$ true &quot;${XDG_CONFIG_HOME:=${HOME}/.config}&quot;
$ mkdir -p &quot;${XDG_CONFIG_HOME}/pipewire/pipewire.conf.d&quot;
# ln -s /usr/share/examples/wireplumber/10-wireplumber.conf &quot;${XDG_CONFIG_HOME}/pipewire/pipewire.conf.d/&quot;
</code></pre>
<p>在这些配置中，启动 <code>pipewire</code> 应该足以建立一个使用 <code>wireplumber</code> 进行会话管理的工作的 PipeWire session。</p>
<p>在其默认配置中，WirePlumber 需要一个活跃的 D-Bus 会话。如果你的桌面环境或窗口管理器被配置为提供 D-Bus 会话以及启动 <code>pipewire</code> 和 <code>wireplumber</code>，则不需要进一步配置。希望单独启动 <code>pipewire</code> 的用户，例如在<code>.xinitrc</code> 脚本中，可能会发现有必要配置 <code>pipewire</code> 来直接启动 <code>wireplumber</code>，并将 <code>pipewire</code> 的调用包装为</p>
<pre><code>dbus-run-session pipewire
</code></pre>
<h2 id="pulseaudio-替代品"><a class="header" href="#pulseaudio-替代品">PulseAudio 替代品</a></h2>
<p>在启动 <code>pipewire-pulse</code> 之前，确保 PulseAudio 服务被<a href="config/media/../services/index.html#disabling-services">禁用</a>，并且没有其他 PulseAudio 服务实例在运行。</p>
<p>通过在终端仿真器中运行 <code>pipewire-pulse</code> 来启动 PulseAudio 服务器。</p>
<p>为了检查替换是否正常工作，使用 <a href="https://man.voidlinux.org/pactl.1">pactl(1)</a>（由 <code>pulseaudio-utils</code> 包提供）。</p>
<pre><code>$ pactl info

[...]
Server Name: PulseAudio (on PipeWire 0.3.18)
[...]
</code></pre>
<p>一旦你确认 <code>pipewire-pulse</code> 如预期般工作，建议在启动 PipeWire 的地方自动启动它。可以修改 <a href="https://man.voidlinux.org/pipewire.conf.5">pipewire.conf(5)</a> 来自动启动 PulseAudio 服务器，但不建议保持 PipeWire 配置文件不被修改，以便将来更顺利地升级。</p>
<h2 id="蓝牙音频"><a class="header" href="#蓝牙音频">蓝牙音频</a></h2>
<p>为了使蓝牙音频工作，请安装 <code>libspa-bluetooth</code> 软件包。</p>
<h2 id="alsa-集成"><a class="header" href="#alsa-集成">ALSA 集成</a></h2>
<p>安装 <code>alsa-pipewire</code> ，然后启用 PipeWire ALSA 设备并使其成为默认设备:</p>
<pre><code># mkdir -p /etc/alsa/conf.d
# ln -s /usr/share/alsa/alsa.conf.d/50-pipewire.conf /etc/alsa/conf.d
# ln -s /usr/share/alsa/alsa.conf.d/99-pipewire-default.conf /etc/alsa/conf.d
</code></pre>
<h2 id="jack-replacement"><a class="header" href="#jack-replacement">JACK replacement</a></h2>
<p>安装<code>libjack-pipewire</code>.</p>
<p>使用 <a href="https://man.voidlinux.org/pw-jack.1">pw-jack(1)</a> 来手动启动 JACK 客户端:</p>
<pre><code>$ pw-jack &lt;application&gt;
</code></pre>
<p>或者，覆盖 <code>libjack</code> 提供的库（见 <a href="https://man.voidlinux.org/ld.so.8">ld.so(8)</a>）。下面的方法将在基于glibc 的系统上工作:</p>
<pre><code># echo &quot;/usr/lib/pipewire-0.3/jack&quot; &gt; /etc/ld.so.conf.d/pipewire-jack.conf
# ldconfig
</code></pre>
<h2 id="故障"><a class="header" href="#故障">故障</a></h2>
<p>替换 Pulseaudio 需要 <a href="config/media/../session-management.html#xdg_runtime_dir"><code>XDG_RUNTIME_DIR</code></a> 环境变量才能正确工作。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pulseaudio"><a class="header" href="#pulseaudio">PulseAudio</a></h1>
<p>根据您使用的应用程序,您可能需要为 PulseAudio 提供 D-BUS session bus（例如通过 dbus-run-session）或 D-BUS system bus（通过 dbus 服务）。</p>
<p>对于直接使用 ALSA 而不支持 PulseAudio 的应用程序， <code>alsa-plugins-pulseaudio</code> 包可以使它们通过 ALSA 使用 PulseAudio。</p>
<p>PulseAudio 会在需要时自动启动。如果它没有自动启动，可以通过从终端调用 <a href="https://man.voidlinux.org/pulseaudio.1">pulseaudio(1)</a> 来手动启动它，方法如下：</p>
<pre><code>$ pulseaudio --daemonize=no --exit-idle-time=-1
</code></pre>
<p>另一方面，PulseAudio 也可能在不需要的时候被自动激活。为了进展这种行为，可以将 <a href="https://man.voidlinux.org/pulse-client.conf.5">pulse-client.conf(5)</a> 中的 <code>autospawn</code> 指令设置为 <code>no</code>。</p>
<p>有几种方法可以让 PulseAudio 访问音频设备。最简单的方法是把你的用户加入到 &quot;audio&quot; 组。另外，你可以使用一个 session 管理器，如 <code>elogind</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sndio"><a class="header" href="#sndio">sndio</a></h1>
<p>安装 <code>sndio</code> 软件包并启用 <a href="https://man.voidlinux.org/sndiod.8">sndiod(8)</a> 服务。</p>
<h2 id="配置-6"><a class="header" href="#配置-6">配置</a></h2>
<p>服务可以通过向配置文件 (<code>/etc/sv/sndiod/conf</code>) 的变量 <code>OPTS</code> 中添加 <a href="https://man.voidlinux.org/sndiod.8">sndiod(8)</a> 标志来配置。 </p>
<h3 id="默认设备"><a class="header" href="#默认设备">默认设备</a></h3>
<p><a href="https://man.voidlinux.org/sndiod.8">sndiod(8)</a> 默认使用第一个 alsa 设备。欲将另外的 alsa 设备设为默认的 <code>snd/0</code> ，向配置文件中添加标志：</p>
<pre><code># echo 'OPTS=&quot;-f rsnd/Speaker&quot;' &gt;/etc/sv/sndiod/conf
</code></pre>
<p>使用 <code>-f</code> 标志，通过 ALSA 设备索引或 ALSA 设备名称选择一个设备。</p>
<h2 id="音量控制"><a class="header" href="#音量控制">音量控制</a></h2>
<p>主控和每个应用程序的音量控制是通过硬件或软件的 MIDI 信息来控制的。</p>
<p><a href="https://man.voidlinux.org/aucatctl.1">aucatctl(1)</a> 是一个专门针对 sndio 的工具，用来向 <a href="https://man.voidlinux.org/sndiod.8">sndiod(8)</a> 守护程序发送 MID I控制信息。它可以在 <code>aucatctl</code> 软件包中找到。</p>
<h2 id="特定的应用配置"><a class="header" href="#特定的应用配置">特定的应用配置</a></h2>
<h3 id="firefox"><a class="header" href="#firefox">Firefox</a></h3>
<p>火狐浏览器在构建时支持 sndio，如果安装了 libsndio 并且有 <code>snd/0</code> 设备，那么从 71 版开始就应该可以使用。</p>
<p>以下 <code>about:config</code> 的修改对于 71 之前的版本是必须的，当使用 71 或更高版本时，应该被删除:</p>
<pre><code>media.cubeb.backend;sndio
media.cubeb.sandbox;false
security.sandbox.content.read_path_whitelist;/home/&lt;username&gt;/.sndio/cookie
security.sandbox.content.write_path_whitelist;/home/&lt;username&gt;/.sndio/cookie
</code></pre>
<h3 id="openal"><a class="header" href="#openal">OpenAL</a></h3>
<p>libopenal 支持 sndio，但默认情况下 ALSA 优先于 sndio。你可以在 <code>~/.alsoftrc</code> 中为每个用户配置这一行为，也可以在 <code>/etc/openal/alsoft.conf</code> 中通过添加以下几行来为整个系统配置：</p>
<pre><code>[general]
drivers = sndio
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="蓝牙"><a class="header" href="#蓝牙">蓝牙</a></h1>
<p>确保蓝牙控制器没有被封锁。使用 <code>rfkill</code> 检查是否有任何 blocks，并删除soft blocks。如果有 hard block，很可能有一个物理硬件开关或 BIOS 中的一个选项来启用蓝牙控制器。</p>
<pre><code>$ rfkill
ID TYPE     DEVICE      SOFT      HARD
0 wlan      phy0   unblocked unblocked
1 bluetooth hci0     blocked unblocked

# rfkill unblock bluetooth
</code></pre>
<h2 id="安装-10"><a class="header" href="#安装-10">安装</a></h2>
<p>安装 <code>bluez</code> 软件包并启用 <code>bluetoothd</code> 和 <code>dbus</code> 服务。然后，将你的用户加入 <code>bluetooth</code>用户组，重启 <code>dbus</code> 服务，或者直接重启系统。注意，重启 <code>dbus</code> 服务可能会杀死使用该服务的进程。</p>
<p>为了使用音频设备，如无线扬声器或耳机，ALSA 用户需要安装 <code>bluez-alsa</code> 软件包。<a href="config/./media/pulseaudio.html">PulseAudio</a> 用户不需要任何额外的软件。<a href="config/./media/pipewire.html">PipeWire</a> 用户需要 <code>libspa-bluetooth</code>。</p>
<h2 id="用法-1"><a class="header" href="#用法-1">用法</a></h2>
<p>使用 <code>bluetoothctl</code> 管理蓝牙连接和控制器，它提供一个命令行界面，也接受标准输入的命令。</p>
<p>查阅 <a href="https://wiki.archlinux.org/index.php/Bluetooth#Pairing">Arch Wiki</a> 有关如何配对设备的示例。 </p>
<h2 id="配置-7"><a class="header" href="#配置-7">配置</a></h2>
<p>主要配置文件是 <code>/etc/bluetooth/main.conf</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tex-live"><a class="header" href="#tex-live">TeX Live</a></h1>
<p>在 Void 中，<code>texlive-bin</code> 包提供了一个基本的 TeX 安装，包括 <code>tlmgr</code> 程序。使用 <code>tlmgr</code> 来安装 TeX 软件包和来自 CTAN 镜像的软件包集。安装 <code>gnupg</code> 包以允许 <code>tlmgr</code> 验证TeX包。</p>
<p><code>texlive-bin</code> 软件包包含最新的 TeX Live 版本；然而，早期版本，如 <code>texlive2018-bin</code>，也是可用的。</p>
<p><code>texlive</code> 包和 <code>texlive-*</code> 包也是可用的，它们通过 xbps 直接提供 TeX 包。通过这些包安装的 TeX 包不能与直接从 CTAN（通过 <code>tlmgr</code>）安装的 TeX 包交互。例如：来自 <code>texlive-pdflatex</code> 的 <code>pdflatex</code> 不能用来编译一个使用通过 <code>tlmgr</code> 安装的包的 TeX 文档；为此需要  <code>tlmgr install pdflatex</code></p>
<h2 id="配置-tex-live"><a class="header" href="#配置-tex-live">配置 TeX Live</a></h2>
<p>安装完 TeX Live 后，更新 <code>PATH</code> 值:</p>
<pre><code>$ source /etc/profile
</code></pre>
<p>检查 <code>/opt/texlive/&lt;year&gt;/bin/x86_64-linux</code> (或
<code>/opt/texlive/&lt;year&gt;/bin/i386-linux</code>) 是否在你的 <code>PATH</code> 中:</p>
<pre><code>$ echo $PATH
</code></pre>
<p>如果需要，改变全局下默认的纸张尺寸:</p>
<pre><code># tlmgr paper &lt;letter|a4&gt;
</code></pre>
<h2 id="安装更新tex软件包"><a class="header" href="#安装更新tex软件包">安装/更新TeX软件包</a></h2>
<p>为了安装所有可用的软件包，运行:</p>
<pre><code># tlmgr install scheme-full
</code></pre>
<p>要安装特定的软件包，你可以安装包括这些软件包的集合。
列出可用的集合，请运行:</p>
<pre><code>$ tlmgr info collections
</code></pre>
<p>查看一个集合所拥有的文件的列表，请运行:</p>
<pre><code>$ tlmgr info --list collection-&lt;name&gt;
</code></pre>
<p>安装这个集合，请运行:</p>
<pre><code># tlmgr install collection-&lt;name&gt;
</code></pre>
<p>要安装一个独立的软件包，首先检查该软件包是否存在:</p>
<pre><code>$ tlmgr search --global &lt;package&gt;
</code></pre>
<p>然后安装:</p>
<pre><code># tlmgr install &lt;package&gt;
</code></pre>
<p>要找到提供某个特定文件的软件包（例如某个字体），请运行:</p>
<pre><code>$ tlmgr search --file &lt;filename&gt; --global
</code></pre>
<p>删除一个包或一个集合，请运行:</p>
<pre><code># tlmgr remove &lt;package&gt;
</code></pre>
<p>更新已安装的软件包，请运行:</p>
<pre><code># tlmgr update --all
</code></pre>
<p>完整描述可参阅:</p>
<p><a href="https://www.tug.org/texlive/doc/tlmgr.html">https://www.tug.org/texlive/doc/tlmgr.html</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="更多程序"><a class="header" href="#更多程序">更多程序</a></h1>
<h2 id="编程语言"><a class="header" href="#编程语言">编程语言</a></h2>
<p>Void 仓库有许多 Python 和 Lua 软件包。如果可能的话，从 Void 仓库安装软件包，或者考虑打包你需要的库或应用程序。将你的应用程序打包可以使系统维护更容易，并能使其他 Void Linux 用户受益，所以考虑为它提出一个拉动请求。贡献说明可以在<a href="https://github.com/void-linux/void-packages/blob/master/CONTRIBUTING.md">这里</a>)找到。</p>
<p>为了使软件包更小，Void 为头文件和开发工具提供了单独的 <code>devel</code> 包。如果你通过一种语言的包管理器（如 <code>pip</code>，<code>gem</code>）安装一个库或应用程序，或从源代码编译一个库或应用程序，你可能需要安装编程语言的  <code>-devel</code> 包。这对 <code>musl libc</code> 用户来说特别重要，因为预建的二进制文件通常以  <code>glibc</code> 为目标。</p>
<div class="table-wrapper"><table><thead><tr><th>编程语言</th><th>软件包管理器</th><th>Void 软件包</th></tr></thead><tbody>
<tr><td>Python3</td><td>pip, anaconda, virtualenv, etc</td><td><code>python3-devel</code></td></tr>
<tr><td>Python2</td><td>pip, anaconda, virtualenv, etc</td><td><code>python2-devel</code></td></tr>
<tr><td>Ruby</td><td>gem</td><td><code>ruby-devel</code></td></tr>
<tr><td>lua</td><td>luarocks</td><td><code>lua-devel</code></td></tr>
</tbody></table>
</div>
<h2 id="受限制的软件"><a class="header" href="#受限制的软件">受限制的软件</a></h2>
<p>有些软件包在分发上有法律限制（例如 Discord），或者可能太大，或者有其他条件使 Void 难以分发。这些软件包有构建模板，但软件包本身没有被构建或分发。因此，它们必须在本地构建。更多信息请参见<a href="config/../xbps/repositories/restricted.html">受限制的软件包</a>的页面。</p>
<h2 id="非-x86_64-架构"><a class="header" href="#非-x86_64-架构">非 x86_64 架构</a></h2>
<p>Void 构建系统在 x86_64 服务器上运行，既用于编译也用于交叉编译软件包。然而，有些软件包（如 <code>libreoffice</code>）不支持交叉编译。这些软件包必须在运行与使用该软件包的系统相同架构和 libc 的计算机上进行本地构建。要了解如何构建软件包，请参考 <a href="https://github.com/void-linux/void-packages/blob/master/README.md">void-packages 仓库的 README 文件</a>。</p>
<h2 id="flatpak"><a class="header" href="#flatpak">Flatpak</a></h2>
<p>Flatpak 是另一种在 Linux 上安装外部专有应用程序的方法。有关在 Void Linux 上使用 Flatpak 的信息，请参见<a href="https://flatpak.org/setup/Void%20Linux/">官方Flatpak 文档</a>。</p>
<p>如果使用 Flatpak 安装的程序没有声音，<a href="config/./media/pulseaudio.html">PulseAudio</a> 的自动激活功能可能没有正常工作。在启动程序之前，请确保 PulseAudio 正在运行。</p>
<p>请注意，Flatpak 的沙箱不一定能保护你免受专利软件的任何安全和/或侵犯隐私的功能的影响。</p>
<h3 id="故障排除-2"><a class="header" href="#故障排除-2">故障排除</a></h3>
<p>一些应用程序可能无法正常运行（例如，无法访问主机系统的文件）。其中一些问题可以通过安装一个或多个 <code>xdg-desktop-portal</code>、<code>xdg-desktop-portal-gtk</code>、<code>xdg-user-dirs</code>、<code>xdg-user-dirs-gtk</code> 或 <code>xdg-utils</code> 软件包来解决。</p>
<p>一些 Flatpaks 需要 <a href="config/./session-management.html#d-bus">D-Bus</a> 和/或者 <a href="config/./media/pulseaudio.html">Pulseaudio</a>。</p>
<h2 id="appimages"><a class="header" href="#appimages">AppImages</a></h2>
<p><a href="https://appimage.org/">AppImage</a> 是一个文件，它将一个应用程序与运行它所需的一切捆绑在一起。一个 AppImage 可以通过使其可执行并运行来使用，不需要安装。AppImage 可以在沙盒中运行，如 <a href="https://firejail.wordpress.com/">firejail</a></p>
<p>在 <a href="https://appimage.github.io/">AppImageHub</a> 上可以找到一些可以使用 AppImage 的应用程序。</p>
<p>AppImages 尚不适用于 musl 安装。 </p>
<h2 id="octave-软件包"><a class="header" href="#octave-软件包">Octave 软件包</a></h2>
<p>一些 Octave 软件包需要外部依赖才能编译和运行。例如，为了构建控制包，你必须安装 <code>openblas-devel</code>、<code>libgomp-devel</code>、<code>libgfortran-devel</code>、<code>gcc-fortran</code> 和 <code>gcc</code> 包。</p>
<h2 id="matlab"><a class="header" href="#matlab">MATLAB</a></h2>
<p>要使用 MATLAB 的 help browser、live 脚本、附加安装程序和 simulink，请安装 <code>libselinux</code> 包。</p>
<h2 id="steam"><a class="header" href="#steam">Steam</a></h2>
<p>Steam 可以通过本机包安装<a href="config/../xbps/repositories/index.html#nonfree">需要启用 &quot;非自由 &quot;仓库</a>或 Flatpak 来安装。不同平台的依赖性列表和本地软件包的故障排除信息可以在其 <a href="config/./package-documentation/index.html">Void-specific文档</a> 中找到，而这部分则是关于 Flatpak 用户面临的潜在问题。</p>
<p>如果你使用不同的驱动器来存储你的游戏库，<a href="https://man.voidlinux.org/flatpak-override.1">flatpak-override(1)</a> 的 `--filesystem`` 选项可以证明是有用的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="打印"><a class="header" href="#打印">打印</a></h1>
<p>CUPS（Common Unix Printing System）是 Void Linux 上支持的连接到打印机的机制。</p>
<p>作为先决条件，安装 <code>cups</code> 软件包并启用 <code>cupsd</code> 服务。等到该服务被标记为可用。</p>
<h2 id="安装打印机驱动程序"><a class="header" href="#安装打印机驱动程序">安装打印机驱动程序</a></h2>
<p>如果打印机是通过网络访问的，并且支持 PostScript 或 PCL，仅 CUPS 就足够了。然而，额外的驱动包对于本地打印机的支持是必要的。<code>cups-filters</code> 软件包为CUPS提供驱动支持。</p>
<p>根据有关硬件的情况，可能需要额外的驱动程序。</p>
<p>一些 CUPS 驱动包含专有的或仅有的二进制扩展。这些只在非免费软件库中提供，有时只针对特定的架构。</p>
<h3 id="无驱动打印"><a class="header" href="#无驱动打印">无驱动打印</a></h3>
<p>大多数现代网络打印机都支持使用 IPP Everywhere 标准进行无驱动打印。请参阅 https://www.pwg.org/printers/ ，了解支持该标准的自我认证的打印机列表。即使某台打印机不在这个名单上，它仍有很大可能被支持。</p>
<p>请注意，无驱动打印仍然需要 <code>cups-filters</code>。</p>
<h3 id="gutenprint-驱动"><a class="header" href="#gutenprint-驱动">Gutenprint 驱动</a></h3>
<p>Gutenprint 为许多打印机提供了支持。 这些驱动程序包含在 <code>gutenprint</code> 软件包。 </p>
<h3 id="hp-驱动"><a class="header" href="#hp-驱动">HP 驱动</a></h3>
<p>惠普的打印机需要 <code>hplip</code> 软件包。</p>
<p>运行以下命令将指导你完成驱动安装过程。它所建议的默认配置选择通常是足够的。</p>
<pre><code># hp-setup -i
</code></pre>
<h3 id="brother-驱动"><a class="header" href="#brother-驱动">Brother 驱动</a></h3>
<p>对于 Brother 打印机的支持，请安装 foomatic 驱动程序，它包含在 <code>foomatic-db</code> 和 <code>foomatic-db-nonfree</code> 软件包中。对各种激光打印机型号的支持是由 <code>brother-brlaser</code> 软件包提供的。</p>
<h3 id="epson-喷墨打印机的驱动"><a class="header" href="#epson-喷墨打印机的驱动">Epson 喷墨打印机的驱动</a></h3>
<p>请安装 <code>epson-inkjet-printer-escpr</code>。</p>
<h3 id="canon-pixmamaxify-驱动"><a class="header" href="#canon-pixmamaxify-驱动">Canon PIXMA/MAXIFY 驱动</a></h3>
<p><code>cnijfilter2</code> 软件包包含了用于佳能 PIXMA 和 MAXIFY 各种型号的驱动程序。请注意，安装该驱动包<a href="config/print/../../xbps/repositories/index.html#nonfree">需要启用 &quot;非自由&quot; 软件源</a>。</p>
<h2 id="配置新打印机"><a class="header" href="#配置新打印机">配置新打印机</a></h2>
<p>CUPS 提供了一个 Web 界面和命令行工具，可用于配置打印机。 此外，还提供各种本机 GUI 选项，并且 可能更适合，具体取决于用例。 </p>
<h3 id="自动地"><a class="header" href="#自动地">自动地</a></h3>
<p>可以发现和配置支持 IPP Everywhere 的打印机 自动使用 <a href="http://www.zeroconf.org/">ZeroConf</a>。 要启用此功能， 安装 <code>avahi</code> 和 <code>nss-mdns</code> 打包并启用 <code>avahi-daemo</code>n 服务。 </p>
<h3 id="web-界面"><a class="header" href="#web-界面">Web 界面</a></h3>
<p>要使用 CUPS 网络界面配置打印机，请在浏览器中导航到 http://localhost:63 1。在 &quot;Administration&quot; 标签下，选择 &quot;Printers &gt; Add Printer&quot;。当被要求登录时，使用 <code>lpadmin</code> 用户组中的账户。</p>
<h3 id="command-line"><a class="header" href="#command-line">Command line</a></h3>
<p><a href="https://man.voidlinux.org/lpadmin.8">lpadmin(8)</a>  工具可用于使用命令行配置打印机.</p>
<h3 id="图形化界面"><a class="header" href="#图形化界面">图形化界面</a></h3>
<p><code>system-config-printer</code> 软件包提供了简单而强大的新打印机配置。安装并调用它：</p>
<pre><code># system-config-printer
</code></pre>
<p>通常情况下，这个工具需要 root 权限。然而，如果你使用 PolicyKit，你可以安装 <code>cups-pk-helper</code> 包，以允许无特权用户使用 <code>system-config-printer</code>。</p>
<p>虽然这里显示的是 <code>system-config-printer</code>，但你的桌面环境可能有一个本地的打印机对话框，可以通过查阅你的桌面环境的文档找到。</p>
<h2 id="故障排除-3"><a class="header" href="#故障排除-3">故障排除</a></h2>
<h3 id="未显示-usb-打印机"><a class="header" href="#未显示-usb-打印机">未显示 USB 打印机</a></h3>
<p>可以通过运行以下命令手动找到设备 URI： </p>
<pre><code># /usr/lib/cups/backend/usb
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="容器和虚拟化"><a class="header" href="#容器和虚拟化">容器和虚拟化</a></h1>
<p>本节描述了如何设置 Void 上可用的一些容器和虚拟机软件。</p>
<h2 id="章节部分"><a class="header" href="#章节部分">章节部分</a></h2>
<ul>
<li><a href="config/containers-and-vms/./chroot.html">Chroots and Containers</a></li>
<li><a href="config/containers-and-vms/./libvirt.html">libvirt</a></li>
<li><a href="config/containers-and-vms/./lxc.html">LXC</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="创建和使用-chroots-和容器"><a class="header" href="#创建和使用-chroots-和容器">创建和使用 chroots 和容器</a></h1>
<p>chroots 和容器的设置和使用有很多目的，包括：</p>
<ul>
<li>在 musl 上运行 glibc 软件（反之亦然） </li>
<li>在一个更受控制的环境中运行软件或沙盒环境</li>
<li>创建一个用于引导系统的 rootfs</li>
</ul>
<h2 id="创建-chroot"><a class="header" href="#创建-chroot">创建 Chroot</a></h2>
<h3 id="xvoidstrap"><a class="header" href="#xvoidstrap">xvoidstrap</a></h3>
<p><a href="https://man.voidlinux.org/xvoidstrap.1"><code>xvoidstrap(1)</code></a> (来自 <code>xtools</code>)可以用于创建 chroot。</p>
<pre><code># mkdir &lt;chroot_dir&gt;
# XBPS_ARCH=&lt;chroot_arch&gt; xvoidstrap &lt;chroot_dir&gt; base-voidstrap &lt;other_pkgs&gt;
</code></pre>
<p><code>&lt;other_pkgs&gt;</code> 只有在你想在 chroot 中预装其他软件包时才需要。</p>
<h3 id="手动方式"><a class="header" href="#手动方式">手动方式</a></h3>
<p>另外，这个过程也可以手动完成。</p>
<p>创建一个包含 chroot 的目录，然后通过 <code>base-voidstrap</code> 包在其中安装一个基础系统。</p>
<pre><code># mkdir -p &quot;&lt;chroot_dir&gt;/var/db/xbps/keys&quot;
# cp -a /var/db/xbps/keys/* &quot;&lt;chroot_dir&gt;/var/db/xbps/keys&quot;
# XBPS_ARCH=&lt;chroot_arch&gt; xbps-install -S -r &lt;chroot_dir&gt; -R &lt;repository&gt; base-voidstrap &lt;other_pkgs&gt;
</code></pre>
<p><code>&lt;repository&gt;</code> 可能因<a href="config/containers-and-vms/../../xbps/repositories/index.html#the-main-repository">架构不同而不同</a>。</p>
<p><code>&lt;other_pkgs&gt;</code> 只有在你想在 chroot 中预装其他软件包时才需要。</p>
<h2 id="chroot-使用方法"><a class="header" href="#chroot-使用方法">Chroot 使用方法</a></h2>
<h3 id="xchroot"><a class="header" href="#xchroot">xchroot</a></h3>
<p><a href="https://man.voidlinux.org/xchroot.1"><code>xchroot(1)</code></a> (来自 <code>xtools</code>）可以用来自动设置和进入 chroot。</p>
<h3 id="手动方式-1"><a class="header" href="#手动方式-1">手动方式</a></h3>
<p>另外，这个过程也可以手动完成。</p>
<p>如果需要网络访问，将 <code>/etc/resolv.conf</code> 复制到 chroot 中；<code>/etc/hosts</code> 可能也需要复制。</p>
<p>然后需要挂载几个目录，如下所示：</p>
<pre><code># mount -t proc none &lt;chroot_dir&gt;/proc
# mount -t sysfs none &lt;chroot_dir&gt;/sys
# mount --rbind /dev &lt;chroot_dir&gt;/dev
# mount --rbind /run &lt;chroot_dir&gt;/run
</code></pre>
<p>使用 <a href="https://man.voidlinux.org/chroot.1">chroot(1)</a> 切换到新的 root，然后像往常一样运行程序和做任务。一旦完成了 chroot，使用 <a href="https://man.voidlinux.org/umount.8">umount(8)</a> 卸载 chroot。如果在没有卸载的情况下对 chroot 目录进行了任何破坏性的操作，你可能需要重新启动以重新填充受影响的目录。</p>
<h3 id="替代品"><a class="header" href="#替代品">替代品</a></h3>
<h4 id="bubblewrap"><a class="header" href="#bubblewrap">Bubblewrap</a></h4>
<p><a href="https://man.voidlinux.org/bwrap.1">bwrap(1)</a> (来自 <code>bubblewrap</code> 软件包）有额外的功能，如沙箱能力，不需要root 权限。</p>
<p><code>bwrap</code> 非常灵活，可以用在很多方面，比如说:</p>
<pre><code>$ bwrap --bind &lt;chroot_dir&gt; / \
	--dev /dev \
	--proc /proc \
	--bind /sys /sys \
	--bind /run /run \
	--ro-bind /etc/resolv.conf /etc/resolv.conf \
	--ro-bind /etc/passwd /etc/passwd \
	--ro-bind /etc/group /etc/group \
	&lt;command&gt;
</code></pre>
<p>在这个例子中，你将不能添加或编辑用户或用户组。当用 Xorg 运行图形应用程序时，你可能还需要绑定挂载  <code>~/.Xauthority</code> 或其他文件或目录。</p>
<p><a href="https://man.voidlinux.org/bwrap.1">bwrap(1) manpage</a> 手册和<a href="https://wiki.archlinux.org/title/Bubblewrap#Usage_examples">Arch Wiki文章</a>中包含了更多关于 <code>bwrap</code> 使用的例子</p>
<h4 id="flatpak-1"><a class="header" href="#flatpak-1">Flatpak</a></h4>
<p><a href="config/containers-and-vms/../external-applications.html#flatpak">Flatpak</a> 是一个方便的选择，可以在 glibc 和 musl 系统上运行许多应用程序，包括图形或专有应用程序。</p>
<h4 id="应用容器"><a class="header" href="#应用容器">应用容器</a></h4>
<p>如果需要一个更加集成和完善的解决方案，Void 还提供了与 <a href="https://www.docker.com">docker</a> 和 <a href="https://man.voidlinux.org/podman.1">podman</a> 等<a href="https://github.com/void-linux/void-docker/pkgs/container/void-linux">工具一起工作的OCI容器</a>。这些容器在使用前不需要创建一个 chroot 目录。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libvirt"><a class="header" href="#libvirt">libvirt</a></h1>
<p><a href="https://libvirt.org/">libvirt</a> 是一个虚拟化管理平台的 API 和守护程序，支持 LXC、KVM、QEMU、Bhyve、Xen、VMWare 和 Hyper-V 等虚拟化技术。</p>
<p>要使用 libvirt，请安装 <code>libvirt</code> 软件包，确保已安装 <code>dbus</code> 包，并<a href="config/containers-and-vms/../services/index.html">启用</a> <code>dbus</code>、<code>libvirtd</code>、<code>virtlockd</code> 和 <code>virtlogd</code> 服务。<code>libvirtd</code> 守护程序可以在运行时通过 <a href="https://man.voidlinux.org/virt-admin.1">virt-admin(1)</a> 重新配置。</p>
<p><code>libvirt</code> 包为 libvirtd 提供了 <a href="https://man.voidlinux.org/virsh.1">virsh(1)</a> 接口。<code>virsh</code> 是一个交互式 shell 和批处理脚本工具，用于执行管理任务，包括创建、配置和运行虚拟机，以及管理网络和存储。注意，<code>virsh</code> 通常需要以 root 身份运行，如 <code>virsh</code> man 页中所述。</p>
<blockquote>
<p>由于 communications channels 原因，大多数 virsh 命令都需要 root 权限才能运行 用于与管理程序对话的通道。 以非 root 身份运行会有错误。</p>
</blockquote>
<p>但是，如果你安装了 <code>polkit</code> 和 <code>dbus</code> 包，并且启用了 <code>dbus</code> 服务，<code>libvirtd</code> 将向添加的任何用户授予必要的权限到 <code>libvirt</code> 用户组。 </p>
<p><code>virt-manager</code> 和 <code>virt-manager-tools</code> 软件包提供了 <code>virsh</code> 的一个替代方案。</p>
<p>有关 libvirt 的一般信息，请参阅 <a href="https://wiki.libvirt.org/page/Main_Page">the libvirt wiki</a> 和 <a href="https://wiki.libvirt.org/page/FAQ">the wiki's FAQ</a> 的常见问题解答 。 有关 libvirt 用法的介绍， 请参阅 <a href="https://wiki.libvirt.org/page/VM_lifecycle">the &quot;VM lifecycle&quot; page</a>。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lxc"><a class="header" href="#lxc">LXC</a></h1>
<p><a href="https://linuxcontainers.org/">Linux 容器项目</a> 包括三个子项目: <a href="https://linuxcontainers.org/lxc/introduction/">LXC</a>、<a href="https://linuxcontainers.org/lxd/introduction/">LXD</a> 和<a href="https://linuxcontainers.org/lxcfs/introduction/">LXCFS</a>。该项目还包括CGManager项目，该项目在最近的内核中已被弃用，而改用 CGroup 命名空间。</p>
<h2 id="配置-lxc"><a class="header" href="#配置-lxc">配置 LXC</a></h2>
<p>安装 <code>lxc</code> 软件包.</p>
<p>以 <code>root</code> 身份创建和运行特权容器不需要任何配置，只需使用各种 <code>lxc-*</code> 命令，如 <a href="https://man.voidlinux.org/lxc-create.1">lxc-create(1)</a>, <a href="https://man.voidlinux.org/lxc-start.1">lxc-start(1)</a>, <a href="https://man.voidlinux.org/lxc-attach.1">lxc-attach(1)</a>等。</p>
<h3 id="创建无特权的容器"><a class="header" href="#创建无特权的容器">创建无特权的容器</a></h3>
<p>用户 ID（UID）和组 ID（GID）的范围通常是 0 到 65535。非特权容器通过将每个容器内的 UID 和 GID 范围映射到主机系统不使用的范围来增强安全性。未使用的主机范围必须 <em>从属于</em> 将运行无特权容器的用户。</p>
<p>下级 UID 和 GID 分别在 <a href="https://man.voidlinux.org/subuid.5">subuid(5)</a> 和 <a href="https://man.voidlinux.org/subgid.5">subgid(5)</a> 文件中分配。</p>
<p>要创建无特权的容器，首先编辑 <code>/etc/subuid</code> 和 <code>/etc/subgid</code> 来委托范围。比如说。</p>
<pre><code>root:1000000:65536
user:2000000:65536
</code></pre>
<p>在每个冒号分隔的条目中： </p>
<ul>
<li>第一个字段是下级范围将被分配给的用户；</li>
<li>第二个字段是最小的数字 ID，定义了一个从属的范围; 和</li>
<li>第三个字段是该范围内连续 ID 的数量。</li>
</ul>
<p><a href="https://man.voidlinux.org/usermod.8">usermod(8)</a> 程序也可以用来操作 suborinated ID。</p>
<p>一般来说，连续 ID 的数量应该是 65536 的整数倍；起始值并不重要，只是为了确保文件中定义的各种范围不重叠。在这个例子中，<code>root</code> 控制的 UID（或者，从 <code>subgid</code>，GID）范围是 1000000 到 1065535，包括在内；<code>user</code> 控制的 ID 范围是 2000000 到 2065535。</p>
<p>在创建一个容器之前，拥有该容器的用户将需要一个 <a href="https://man.voidlinux.org/lxc.conf.5">lxc.conf(5)</a> 文件来指定要使用的 subuid 和 subgid 范围。对于根用户的容器，这个文件位于 <code>/etc/lxc/default.conf</code>；对于非特权用户，这个文件位于 <code>~/.config/lxc/default.conf</code>。</p>
<pre><code>lxc.idmap = u 0 1000000 65536
lxc.idmap = g 0 1000000 65536
</code></pre>
<p>孤立的 <code>u</code> 字符表示一个 UID 映射，而孤立的 <code>g</code> 表示一个 GID 映射。第一个数字值一般应始终为 0；这表示从容器内看到的 UID 或 GID 范围的开始。第二个数值是 <em>从容器外看到的</em> 相应范围的开始，可以是 <code>/etc/subuid</code> 或 <code>/etc/subgid</code> 中委托的范围内的一个任意值。最后一个值是要映射的连续ID的数量。</p>
<p>请注意，尽管外部范围的起始点是任意的，但必须注意确保起始点和数字所暗示的范围的终点不会超出委托给用户的 ID 范围。</p>
<p>如果配置的是非 root 用户，请以 root 身份编辑 <code>/etc/lxc/lxc-usernet</code>，指定一个网络设备配额。例如，允许名为 <code>user</code> 的用户创建最多 10 个连接到 <code>lxcbr0</code> 网桥的 <code>veth</code> 设备:</p>
<pre><code>user veth lxcbr0 10
</code></pre>
<p>用户现在可以使用 <code>lxc-*</code> 工具创建和使用无特权的容器。要创建一个简单的名为 <code>mycontainer</code> 的 Void 容器，使用类似的命令:</p>
<pre><code>lxc-create -n mycontainer -t download -- \
	--dist voidlinux --release current --arch amd64
</code></pre>
<p>您可以用其他架构代替 <code>amd64</code>，也可以在命令末尾添加 <code>--variant musl</code> 来指定一个 musl 镜像。可用的容器列表见<a href="http://images.linuxcontainers.org">LXC镜像服务器</a>。</p>
<p>默认情况下，系统容器的配置和挂载点存储在 <code>/var/lib/lxc</code>，而用户容器的配置和挂载点则存储在 <code>~/.local/share/lxc</code> 。这两个值都可以通过在 <a href="https://man.voidlinux.org/lxc.system.conf.5">lxc.system.conf(5)</a> 文件中设置 <code>lxc.lxcpath</code> 来修改。特权用户可以在 <code>/etc/lxc/lxc.conf</code> 中定义的系统<code>lxc.lxcpath</code> 中启动非特权容器；普通用户可以在 <code>~/.config/lxc/lxc.conf</code> 中定义的个人 <code>lxc.lxcpath</code> 中启动非特权容器。</p>
<p>默认情况下，所有容器将共享相同的下级 UID 和 GID 地图。这是允许的，但这意味着攻击者如果在一个容器中获得了高等级的访问权限，并能以某种方式突破该容器，就会对其他容器有类似的访问权限。为了将容器相互隔离，在你创建每个容器之前，改变 <code>default.conf</code> 中的 <code>lxc.idmap</code> 范围，使其指向一个唯一的范围。试图修复用错误的地图创建的容器的权限是可能的，但很不方便。</p>
<h2 id="lxd"><a class="header" href="#lxd">LXD</a></h2>
<p>LXD 提供了 LXC 的 <code>lxc-*</code> 工具的替代接口。然而，它不需要上一节中描述的配置。</p>
<p>安装 <code>lxd</code> 软件包，并<a href="config/containers-and-vms/../services/index.html#enabling-services">启用</a> <code>lxd</code> 服务。</p>
<p>LXD 用户必须属于 <code>lxd</code> 用户组。</p>
<p>使用 <code>lxc</code> 命令来管理实例，如<a href="https://linuxcontainers.org/lxd/getting-started-cli/#lxd-client">这里</a>所述。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gnupg"><a class="header" href="#gnupg">GnuPG</a></h1>
<p>Void 同时提供了GnuPG legacy 版（作为 <code>gnupg1</code> ）和 GnuPG 稳定版（作为 <code>gnupg</code>）。</p>
<h2 id="智能卡"><a class="header" href="#智能卡">智能卡</a></h2>
<p>对于用 GnuPG 使用 Yubikeys 等智能卡，有两个后端可以通过 GnuPG 与它们进行通信：GnuPG 的 scdaemon 的内部 CCID 驱动，或 PC/SC 驱动。</p>
<h2 id="带有内部-ccid-驱动的-scdaemon"><a class="header" href="#带有内部-ccid-驱动的-scdaemon">带有内部 CCID 驱动的 scdaemon</a></h2>
<p>默认情况下，scdaemon（在 GnuPG 中使用智能卡时需要）使用其内部的 CCID 驱动。为了让它工作，你的智能卡需要是<a href="https://github.com/void-linux/void-packages/blob/master/srcpkgs/gnupg/files/60-scdaemon.rules">这里</a>的 udev 规则中的智能卡之一，并且你需要使用 elogind 或成为 plugdev 组的成员。如果这两个条件都满足，而且你没有运行 pcscd，<code>gpg --card-status</code> 应该能成功地打印你当前的卡的状态。</p>
<h2 id="带有-pcscd-后端的-scdaemon"><a class="header" href="#带有-pcscd-后端的-scdaemon">带有 pcscd 后端的 scdaemon</a></h2>
<p>如果你因为其他原因需要使用 pcscd，运行 <code>echo disable-ccid &gt;&gt; ~/.gnupg/scdaemon.conf</code>。现在，假设你的 pcscd 设置工作正常，<code>gpg --card-status</code> 应该会打印你的卡片状态。</p>
<h1 id="openpgp-card-tools"><a class="header" href="#openpgp-card-tools">OpenPGP card tools</a></h1>
<p>作为 GnuPG 和智能卡的替代品，Void 还提供了 <code>openpgp-card-tools</code>，这是一个基于Rust的工具，不依赖 GnuPG。它需要使用 <code>pcscd</code> 来与智能卡交互，所以如果你想与 GnuPG 并行使用它，你需要配置 <code>scdaemon</code> 来使用 pcscd 后台，如上文 &quot;带有 pcscd 后端的 scdaemon&quot; 所述。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xbps-软件包管理器"><a class="header" href="#xbps-软件包管理器">XBPS 软件包管理器</a></h1>
<p>X Binary Package System（XBPS）是一个快速的软件包管理器，它是从头开始设计和实现。XBPS 由 Void Linux 团队管理，它的原始代码库在 https://github.com/void-linux/xbps</p>
<p>大多数通用包管理是使用以下命令完成的： </p>
<ul>
<li><a href="https://man.voidlinux.org/xbps-query.1">xbps-query(1)</a> 搜索并显示本地安装的软件包的信息，如果与 <code>-R</code> 标志一起使用，则显示存储库中的软件包。</li>
<li><a href="https://man.voidlinux.org/xbps-install.1">xbps-install(1)</a> 安装和更新软件包，并同步存储库的索引。</li>
<li><a href="https://man.voidlinux.org/xbps-remove.1">xbps-remove(1)</a> 可以删除已安装的软件包， 也可以删除孤立的软件包和缓存的软件包文件。</li>
<li><a href="https://man.voidlinux.org/xbps-reconfigure.1">xbps-reconfigure(1)</a> 运行已安装包的配置，可用于重新配置更改配置文件后的某些软件包。 后者通常需要 <code>--force</code> 标志。 </li>
<li><a href="https://man.voidlinux.org/xbps-alternatives.1">xbps-alternatives(1)</a> 列出或设置已安装软件包所提供的替代品。替代品允许多个软件包通过其他冲突的应用提供共同的功能。，否则会有冲突的软件包，它通过从共同的路径创建符号链接到包的特定版本，以建立符号链接，由用户选择。</li>
<li><a href="https://man.voidlinux.org/xbps-pkgdb.1">xbps-pkgdb(1)</a> 可以报告和修复包数据库中的问题，并对其进行修改。</li>
<li><a href="https://man.voidlinux.org/xbps-rindex.1">xbps-rindex(1)</a> 管理本地的二进制包库。</li>
</ul>
<p>大多数问题可以通过查阅<a href="https://man.voidlinux.org/xbps.d.5">xbps.d(5)</a> 的man page来找到解决方法。</p>
<p>学习如何从源代码构建软件包，参阅<a href="https://github.com/void-linux/void-packages/blob/master/README.md">the README for thevoid-packages repository</a>.</p>
<h2 id="更新系统"><a class="header" href="#更新系统">更新系统</a></h2>
<p>和大多数系统一样，保持 Void 版本最新十分重要。使用
<a href="https://man.voidlinux.org/xbps-install.1">xbps-install(1)</a> 更新系统：</p>
<pre><code># xbps-install -Su
</code></pre>
<p>XBPS必须使用一个单独的事务来更新自己。如果你的更新包括 <code>xbps</code> 包，你需要第二次运行上述命令来应用其余的更新。</p>
<h3 id="重启服务"><a class="header" href="#重启服务">重启服务</a></h3>
<p>当服务被更新时，XBPS不会重新启动服务。这项任务留给了用户自己，所以他们可以安排时间，确保备份，并且通常在更新时，用户应该在电脑前进行维护。</p>
<p>要找到运行与磁盘上不同版本的进程，请使用 <code>xtools</code> 包提供的 <code>xcheckrestart</code> 工具：</p>
<pre><code>$ xcheckrestart
11339 /opt/google/chrome/chrome (deleted) (google-chrome)
</code></pre>
<p><code>xcheckrestart</code> 将输出PID、可执行文件的路径、被启动的路径的状态（几乎都是 <code>deleted</code> ）和进程名称。
被启动的路径（几乎总是 <code>deleted</code> ）和进程名称。
<code>xcheckrestart</code>可以而且应该以非特权用户的身份运行。</p>
<h3 id="更新后的内核崩溃问题"><a class="header" href="#更新后的内核崩溃问题">更新后的内核崩溃问题</a></h3>
<p>如果你在更新后出现了内核崩溃，很可能是你的系统在 <code>/boot</code> 中的空间用完了。请参考 &quot;<a href="xbps/../config/kernel.html#removing-old-kernels">Removing old kernels</a>&quot; 以获得更多信息。</p>
<h2 id="寻找文件和软件包"><a class="header" href="#寻找文件和软件包">寻找文件和软件包</a></h2>
<p>查找可用软件包，使用 <a href="https://man.voidlinux.org/xbps-query.1">xbps-query(1)</a> :</p>
<pre><code>$ xbps-query -Rs &lt;search_pattern&gt;
</code></pre>
<p><code>-R</code> 标志指定了应搜索的存储库。如果没有它， <code>-s</code> 会搜索本地安装的软件包。</p>
<p>如果你在安装一个软件包后找不到你期望找到的文件或程序包，你可以使用 <a href="https://man.voidlinux.org/xbps-query.1">xbps-query(1)</a> 列出该软件包所提供的文件。</p>
<pre><code>$ xbps-query -f &lt;package_name&gt;
</code></pre>
<p><code>xtools</code> 这一软件包包含了 <a href="https://man.voidlinux.org/xlocate.1">xlocate(1)</a> 工具、 <code>xlocate</code> 的工作原理与
<a href="https://man.voidlinux.org/locate.1">locate(1)</a> ，但对于Void软件源中的文件：</p>
<pre><code>$ xlocate -S
Fetching objects: 11688, done.
From https://repo-default.voidlinux.org/xlocate/xlocate
 + e122c3634...a2659176f master     -&gt; master  (forced update)
$ xlocate xlocate
xtools-0.59_1   /usr/bin/xlocate
xtools-0.59_1   /usr/share/man/man1/xlocate.1 -&gt; /usr/share/man/man1/xtools.1
</code></pre>
<p>也可以使用 <a href="https://man.voidlinux.org/xbps-query.1">xbps-query(1)</a> 来查找文件，尽管
这是很不可取的。</p>
<pre><code>$ xbps-query -Ro /usr/bin/xlocate
xtools-0.46_1: /usr/bin/xlocate (regular file)
</code></pre>
<p>这需要 <code>xbps-query</code> 下载每个软件包的部分内容来寻找文件。 <code>xlocate</code> 则是查询本地缓存的所有文件的索引，所以不需要网络，所以不需要网络访问。</p>
<p>要获得所有已安装软件包的列表，不包括其版本，运行：</p>
<pre><code>$ xbps-query -l | awk '{ print $2 }' | xargs -n1 xbps-uhelper getpkgname
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高级用法"><a class="header" href="#高级用法">高级用法</a></h1>
<h2 id="降级"><a class="header" href="#降级">降级</a></h2>
<p>XBPS 允许你将一个软件包降级到一个特定的软件包版本。</p>
<h3 id="通过-xdowngrade"><a class="header" href="#通过-xdowngrade">通过 xdowngrade</a></h3>
<p>最简单的降级方法是使用 <code>xtools</code> 软件包中的 <code>xdowngrade</code>，指定你想降级的软件包版本：</p>
<pre><code># xdowngrade /var/cache/xbps/pkg-1.0_1.xbps
</code></pre>
<h3 id="通过-xbps"><a class="header" href="#通过-xbps">通过 XBPS</a></h3>
<p>XBPS 可用于降级到不再可用的软件包版本 在存储库索引中。</p>
<p>如果该软件包的版本以前已经安装过，它将在 <code>/var/cache/xbps/</code> 中可用。如果没有，它将需要从其他地方获得；在这个例子中，将假定软件包的版本已经被添加到 <code>/var/cache/xbps/</code>。</p>
<p>首先将包版本添加到本地存储库： </p>
<pre><code># xbps-rindex -a /var/cache/xbps/pkg-1.0_1.xbps
</code></pre>
<p>然后降级 <code>xbps-install</code>: </p>
<pre><code># xbps-install -R /var/cache/xbps/ -f pkg-1.0_1
</code></pre>
<p>为了强制降级/重新安装一个已经安装的软件包，<code>-f</code> 标志是必要的。</p>
<h2 id="保留当前的软件包"><a class="header" href="#保留当前的软件包">保留当前的软件包</a></h2>
<p>要防止软件包在系统更新时被更新， 请使用 <a href="https://man.voidlinux.org/xbps-pkgdb.1">xbps-pkgdb(1)</a>：</p>
<pre><code># xbps-pkgdb -m hold &lt;package&gt;
</code></pre>
<p>可以通过以下方式删除保留： </p>
<pre><code># xbps-pkgdb -m unhold &lt;package&gt;
</code></pre>
<h2 id="储存库锁定的软件包"><a class="header" href="#储存库锁定的软件包">储存库锁定的软件包</a></h2>
<p>如果你使用 <code>xbps-src</code> 从一个定制的模板或定制的构建选项来构建和安装一个软件包，你可能希望防止系统更新用一个非定制的版本来替换该软件包。为了确保一个软件包只从安装它的同一个仓库更新，你可以通过 <a href="https://man.voidlinux.org/xbps-pkgdb.1">xbps-pkgdb(1)</a> <strong>重新锁定</strong>它：</p>
<pre><code># xbps-pkgdb -m repolock &lt;package&gt;
</code></pre>
<p>撤销锁定：</p>
<pre><code># xbps-pkgdb -m repounlock &lt;package&gt;
</code></pre>
<h2 id="忽略软件包"><a class="header" href="#忽略软件包">忽略软件包</a></h2>
<p>有时，你可能希望删除一个由另一个软件包提供功能的软件包，但由于依赖关系的问题，你将无法这样做。例如， 你可能希望使用 <a href="https://man.voidlinux.org/doas.1">doas(1)</a> 而不是 <a href="https://man.voidlinux.org/sudo.8">sudo(8)</a>， 但由于 <code>sudo</code> 软件包是对 <code>base-system</code> 软件包的依赖， 因此无法删除它。要删除它，你需要<em>忽略</em> <code>sudo</code> 包。</p>
<p>要忽略一个软件包， 请在 <a href="https://man.voidlinux.org/xbps.d.5">xbps.d(5)</a> 配置文件中添加一个适当的 ignorepkg 项。例如:</p>
<pre><code>ignorepkg=sudo
</code></pre>
<p>然后你将能够使用 <a href="https://man.voidlinux.org/xbps-remove.1">xbps-remove(1)</a> 删除 <code>sudo</code> 软件包。</p>
<h2 id="虚拟软件包"><a class="header" href="#虚拟软件包">虚拟软件包</a></h2>
<p>虚拟包可以通过 <a href="https://man.voidlinux.org/xbps.d.5">xbps.d(5)</a> <code>virtualpkg</code> 项来创建。任何对虚拟包的请求都会被解析为真实的包。例如，要创建一个 <code>linux</code> 虚拟包，它将被解析为 <code>linux5.6</code> 包，创建一个 <code>xbps.d</code> 配置文件，其内容如下：</p>
<pre><code>virtualpkg=linux:linux5.6
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="软件源"><a class="header" href="#软件源">软件源</a></h1>
<p>软件源是 XBPS 软件包系统的核心。软件源可以是本地或远程的。一个存储库包含二进制包文件，可能有签名，还有一个名为 <code>$ARCH-repodata</code> 的数据文件（例如 <code>x86_64-repodata</code>），也可能有签名。</p>
<p>注意，虽然本地软件源不需要签名，但远程软件源 <strong>必须</strong> 签名。</p>
<h2 id="主软件源"><a class="header" href="#主软件源">主软件源</a></h2>
<p>主软件源与基本<a href="xbps/repositories/./mirrors/index.html">镜像 URL</a> 相关的位置是：</p>
<ul>
<li>glibc: <code>/current</code></li>
<li>musl: <code>/current/musl</code></li>
<li>aarch64 和 aarch64-musl: <code>/current/aarch64</code></li>
</ul>
<h2 id="子软件源"><a class="header" href="#子软件源">子软件源</a></h2>
<p>除了安装时启用的主软件源外，Void 还提供了其他由 Void 项目维护的官方软件源库，但在默认情况下没有启用：</p>
<ul>
<li>nonfree: 包含具有非自由许可证的软件包</li>
<li>multilib: 包含用于64位系统的32位库（glibc 独有）。</li>
<li>multilib/nonfree: 包含非自由的 multilib 软件包</li>
<li>debug: 包含软件包调试的 symbols</li>
</ul>
<p>这些软件源可以通过安装相关软件包来启用。这些软件包只在 <code>/usr/share/xbps.d</code> 中安装一个资源库配置文件。</p>
<h3 id="nonfree"><a class="header" href="#nonfree">nonfree</a></h3>
<p>Void 有一个 <code>nonfree</code> 仓库，用于存放非自由许可证的软件包。它可以通过安装 <code>void-repo-nonfree</code> 包来启用。</p>
<p>软件包会因为一些原因而出现在 <code>nonfree</code> 软件源中：</p>
<ul>
<li>非自由许可的软件，有发布的源代码。</li>
<li>只作为可重新分发的二进制软件包发布的软件。</li>
<li>专利技术，可能有也可能没有（其他方面）开放的实施。</li>
</ul>
<h3 id="multilib"><a class="header" href="#multilib">multilib</a></h3>
<p><code>multilib</code> 源提供32位软件包作为64位系统的兼容层。它可以通过安装 <code>void-repo-multilib</code> 包来启用。</p>
<p>这些存储库只适用于运行 <code>glibc</code> C库的 <code>x86_64</code> 系统。</p>
<h3 id="multilibnonfree"><a class="header" href="#multilibnonfree">multilib/nonfree</a></h3>
<p><code>multilib/nonfree</code> 软件源提供了额外的 32 位软件包，这些软件包具有非自由许可证。它可以通过安装 <code>void-repo-multilib-nonfree</code> 包来启用。</p>
<h3 id="debug"><a class="header" href="#debug">debug</a></h3>
<p>Void Linux 软件包没有调试 symbols。如果你想对软件进行调试或查看核心转储，你将需要调试 symbols。这些软件包包含在调试软件源中。它可以通过安装 <code>void-repo-debug</code> 包来启用。</p>
<p>Once enabled, symbols may be obtained for <code>&lt;package&gt;</code> by installing
<code>&lt;package&gt;-dbg</code>.</p>
<p>一旦启用，可以通过安装 <code>&lt;package&gt;-dbg</code> 来获得 <code>&lt;package&gt;</code> 的 symbols.</p>
<h4 id="查看调试的依赖关系"><a class="header" href="#查看调试的依赖关系">查看调试的依赖关系</a></h4>
<p><code>xtools</code> 软件包包含 <a href="https://man.voidlinux.org/xtools.1">xdbg(1)</a> 工具，用来检索一个软件包的调试包列表，包括依赖关系：</p>
<pre><code>$ xdbg bash
bash-dbg
glibc-dbg
# xbps-install -S $(xdbg bash)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="镜像源"><a class="header" href="#镜像源">镜像源</a></h1>
<p>Void Linux 在几个地理区域都有镜像供你使用。一个新的安装将默认使用欧洲的主镜像，但你也可以 <a href="xbps/repositories/mirrors/./changing.html">选择一个不同的镜像</a></p>
<h2 id="一级镜像"><a class="header" href="#一级镜像">一级镜像</a></h2>
<p>第 1 级镜像由 Void Linux 基础设施团队维护。这些镜像直接从构建主站同步，并且总是有最新的软件包。</p>
<p>默认情况下，XBPS 将联系 <a href="https://repo-default.voidlinux.org">https://repo-default.voidlinux.org</a> ，它可以映射到任何一级镜像。</p>
<!-- Order alphabetically by: (1) Region, (2) Country, (3) City/State/Province/etc, (4) URL -->
<div class="table-wrapper"><table><thead><tr><th>Repository</th><th>Region</th><th>Location</th></tr></thead><tbody>
<tr><td><a href="https://repo-fastly.voidlinux.org/">https://repo-fastly.voidlinux.org/</a></td><td>Global</td><td>Fastly Global CDN</td></tr>
<tr><td><a href="https://repo-fi.voidlinux.org/">https://repo-fi.voidlinux.org/</a></td><td>Europe</td><td>Helsinki, Finland</td></tr>
<tr><td><a href="https://repo-de.voidlinux.org/">https://repo-de.voidlinux.org/</a></td><td>Europe</td><td>Frankfurt, Germany</td></tr>
<tr><td><a href="https://mirrors.servercentral.com/voidlinux/">https://mirrors.servercentral.com/voidlinux/</a></td><td>North America</td><td>Chicago, USA</td></tr>
</tbody></table>
</div>
<h2 id="二级镜像"><a class="header" href="#二级镜像">二级镜像</a></h2>
<p>在可能的情况下，第2级镜像从附近的第1级镜像同步。这些镜像不是由 Void 管理的，也不保证软件包的新度和完整性,也不要求它们同步每个可用的架构或子库。</p>
<h3 id="全球镜像"><a class="header" href="#全球镜像">全球镜像</a></h3>
<!-- Order alphabetically by: (1) Region, (2) Country, (3) City/State/Province/etc, (4) URL -->
<div class="table-wrapper"><table><thead><tr><th>Repository</th><th>Region</th><th>Location</th></tr></thead><tbody>
<tr><td><a href="https://mirror.ps.kz/voidlinux/">https://mirror.ps.kz/voidlinux/</a></td><td>Asia</td><td>Almaty, Kazakhstan</td></tr>
<tr><td><a href="https://mirror.nju.edu.cn/voidlinux/">https://mirror.nju.edu.cn/voidlinux/</a></td><td>Asia</td><td>China</td></tr>
<tr><td><a href="https://mirrors.bfsu.edu.cn/voidlinux/">https://mirrors.bfsu.edu.cn/voidlinux/</a></td><td>Asia</td><td>Beijing, China</td></tr>
<tr><td><a href="https://mirrors.cnnic.cn/voidlinux/">https://mirrors.cnnic.cn/voidlinux/</a></td><td>Asia</td><td>Beijing, China</td></tr>
<tr><td><a href="https://mirrors.tuna.tsinghua.edu.cn/voidlinux/">https://mirrors.tuna.tsinghua.edu.cn/voidlinux/</a></td><td>Asia</td><td>Beijing, China</td></tr>
<tr><td><a href="https://mirror.sjtu.edu.cn/voidlinux/">https://mirror.sjtu.edu.cn/voidlinux/</a></td><td>Asia</td><td>Shanghai, China</td></tr>
<tr><td><a href="https://void.webconverger.org/">https://void.webconverger.org/</a></td><td>Asia</td><td>Singapore</td></tr>
<tr><td><a href="http://ftp.dk.xemacs.org/voidlinux/">http://ftp.dk.xemacs.org/voidlinux/</a></td><td>Europe</td><td>Denmark</td></tr>
<tr><td><a href="https://mirrors.dotsrc.org/voidlinux/">https://mirrors.dotsrc.org/voidlinux/</a></td><td>Europe</td><td>Denmark</td></tr>
<tr><td><a href="https://quantum-mirror.hu/mirrors/pub/voidlinux/">https://quantum-mirror.hu/mirrors/pub/voidlinux/</a></td><td>Europe</td><td>Hungary</td></tr>
<tr><td><a href="https://voidlinux.mirror.garr.it/">https://voidlinux.mirror.garr.it/</a></td><td>Europe</td><td>Italy</td></tr>
<tr><td><a href="https://void.cijber.net/">https://void.cijber.net/</a></td><td>Europe</td><td>Amsterdam, Netherlands</td></tr>
<tr><td><a href="https://void.sakamoto.pl/">https://void.sakamoto.pl/</a></td><td>Europe</td><td>Warsaw, Poland</td></tr>
<tr><td><a href="http://ftp.debian.ru/mirrors/voidlinux/">http://ftp.debian.ru/mirrors/voidlinux/</a></td><td>Europe</td><td>Russia</td></tr>
<tr><td><a href="https://mirror.yandex.ru/mirrors/voidlinux/">https://mirror.yandex.ru/mirrors/voidlinux/</a></td><td>Europe</td><td>Russia</td></tr>
<tr><td><a href="https://ftp.lysator.liu.se/pub/voidlinux/">https://ftp.lysator.liu.se/pub/voidlinux/</a></td><td>Europe</td><td>Sweden</td></tr>
<tr><td><a href="https://mirror.accum.se/mirror/voidlinux/">https://mirror.accum.se/mirror/voidlinux/</a></td><td>Europe</td><td>Sweden</td></tr>
<tr><td><a href="https://mirror.puzzle.ch/voidlinux/">https://mirror.puzzle.ch/voidlinux/</a></td><td>Europe</td><td>Bern, Switzerland</td></tr>
<tr><td><a href="https://mirror.vofr.net/voidlinux/">https://mirror.vofr.net/voidlinux/</a></td><td>North America</td><td>California, USA</td></tr>
<tr><td><a href="https://mirror2.sandyriver.net/pub/voidlinux/">https://mirror2.sandyriver.net/pub/voidlinux/</a></td><td>North America</td><td>Kentucky, USA</td></tr>
<tr><td><a href="https://mirror.clarkson.edu/voidlinux/">https://mirror.clarkson.edu/voidlinux/</a></td><td>North America</td><td>New York, USA</td></tr>
<tr><td><a href="https://mirror.aarnet.edu.au/pub/voidlinux/">https://mirror.aarnet.edu.au/pub/voidlinux/</a></td><td>Oceania</td><td>Canberra, Australia</td></tr>
<tr><td><a href="https://ftp.swin.edu.au/voidlinux/">https://ftp.swin.edu.au/voidlinux/</a></td><td>Oceania</td><td>Melbourne, Australia</td></tr>
<tr><td><a href="https://voidlinux.com.br/repo/">https://voidlinux.com.br/repo/</a></td><td>South America</td><td>Ouro Preto, Brazil</td></tr>
<tr><td><a href="http://void.chililinux.com/voidlinux/">http://void.chililinux.com/voidlinux/</a></td><td>South America</td><td>Pimenta Bueno, Brazil</td></tr>
</tbody></table>
</div>
<h2 id="tor-镜像"><a class="header" href="#tor-镜像">Tor 镜像</a></h2>
<p>Void Linux 也在 Tor 网络上做了镜像。更多信息请参见使用 <a href="xbps/repositories/mirrors/./tor.html">Tor 镜像</a>。</p>
<h2 id="创建镜像"><a class="header" href="#创建镜像">创建镜像</a></h2>
<p>如果你想建立一个镜像，并且确信你能保持它的合理更新，请遵循许多关于用 <a href="https://man.voidlinux.org/rsync.1">rsync(1)</a>,做镜像的指南之一，然后向 <a href="https://github.com/void-linux/void-docs">void-docs 仓库</a> 提交一个请求，将你的镜像添加到本页的相应镜像表中。</p>
<p>一个完整的镜像需要大约 1TB 的存储空间。也可以只镜像部分软件库。不包括调试包是减少一级镜像负载的一种方法，对用户的影响很小。</p>
<p>请记住，我们为所有从一级镜像发出的数据支付带宽。您可以尊重这一点，只有当您的镜像的使用情况能够抵消镜像同步所消耗的网络吞吐量时，才会进行镜像。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="更换镜像"><a class="header" href="#更换镜像">更换镜像</a></h1>
<p>每个软件库都有一个文件定义了所使用的镜像的 URL 。对于官方软件库，这些文件由软件包管理器安装在 <code>/usr/share/xbps.d</code> 中，但如果在 <code>/etc/xbps.d</code> 中发现重复的文件，就会使用这些值来代替。</p>
<h2 id="xmirror"><a class="header" href="#xmirror">xmirror</a></h2>
<p>为了方便修改当前选择的镜像，可以使用 <a href="https://man.voidlinux.org/xmirror.1">xmirror(1)</a>（来自 <code>xmirror</code> 软件包）。这个工具会处理所有更新所选镜像的步骤。</p>
<h2 id="手动方式-2"><a class="header" href="#手动方式-2">手动方式</a></h2>
<p>另外，这也可以手动完成：</p>
<p>为了干净利落地修改镜像URL，把所有版本库的配置文件复制到 <code>/etc/xbps.d</code>，并修改每个复制的版本库文件中的 URL。</p>
<pre><code># mkdir -p /etc/xbps.d
# cp /usr/share/xbps.d/*-repository-*.conf /etc/xbps.d/
# sed -i 's|https://repo-default.voidlinux.org|&lt;repository&gt;|g' /etc/xbps.d/*-repository-*.conf
</code></pre>
<p>在更改 URL 后，你必须将 xbps 与新的镜像同步：</p>
<pre><code># xbps-install -S
</code></pre>
<p>您应该在同步时看到新的存储库 URL。 您也可以使用 <code>xbps-query</code> 验证存储库 URL，但只有在它们被验证之后同步： </p>
<pre><code>$ xbps-query -L
 9970 https://repo-default.voidlinux.org/current (RSA signed)
   27 https://repo-default.voidlinux.org/current/multilib/nonfree (RSA signed)
 4230 https://repo-default.voidlinux.org/current/multilib (RSA signed)
   47 https://repo-default.voidlinux.org/current/nonfree (RSA signed)
 5368 https://repo-default.voidlinux.org/current/debug (RSA signed)
</code></pre>
<p>请记住，之后添加的存储库也需要改变，否则它们将使用默认的镜像。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-tor-镜像"><a class="header" href="#使用-tor-镜像">使用 Tor 镜像</a></h1>
<p>Tor 是一个匿名软件，它通过世界各地的计算机弹出流量。它可以提供对互联网上常规网站的访问，或访问只有在网络上才有的隐藏网站。</p>
<p>下列 Void Linux 镜像在 Tor 网络上可用：</p>
<div class="table-wrapper"><table><thead><tr><th>Repository</th><th>Location</th></tr></thead><tbody>
<tr><td><a href="http://lysator7eknrfl47rlyxvgeamrv7ucefgrrlhk7rouv3sna25asetwid.onion/pub/voidlinux/">http://lysator7eknrfl47rlyxvgeamrv7ucefgrrlhk7rouv3sna25asetwid.onion/pub/voidlinux/</a></td><td>EU: Sweden</td></tr>
</tbody></table>
</div>
<h2 id="使用-tor-的-xbps"><a class="header" href="#使用-tor-的-xbps">使用 Tor 的 XBPS</a></h2>
<p>XBPS 可以使用 Tor 连接到镜像。这些镜像可以是正常的镜像，通过出口中继，或者，为了潜在的更大的匿名性，可以是网络上隐藏的服务器镜像。</p>
<p>XBPS 遵循 <code>SOCKS_PROXY</code> 环境变量，这使得它很容易通过 Tor 使用。</p>
<h3 id="安装-tor"><a class="header" href="#安装-tor">安装 Tor</a></h3>
<p>Tor包含在 <code>tor</code> 软件包中。</p>
<p>在安装了Tor之后，你可以以你自己的用户身份启动它：</p>
<pre><code>$ tor
</code></pre>
<p>或启用其系统服务。</p>
<p>默认情况下，Tor 将作为一个客户端，在本地主机的 TCP 端口 9050 上打开一个 SOCKS5 代理。</p>
<h3 id="使-xbps-通过-socks-代理连接"><a class="header" href="#使-xbps-通过-socks-代理连接">使 XBPS 通过 SOCKS 代理连接</a></h3>
<p>XBPS 读取 <code>SOCKS_PROXY</code> 环境变量并将使用其中指定的任何代理。通过简单地将该变量设置为由 Tor 客户端打开的代理的地址和端口，所有 XBPS 的连接将通过Tor网络进行。</p>
<p>一个通过 Tor 升级系统的例子：</p>
<pre><code># export SOCKS_PROXY=&quot;socks5://127.0.0.1:9050&quot;
# xbps-install -Su
</code></pre>
<h3 id="使用一个隐藏的服务器镜像"><a class="header" href="#使用一个隐藏的服务器镜像">使用一个隐藏的服务器镜像</a></h3>
<p>为了使用一个隐藏的服务器镜像，默认的镜像需要用指向 <code>.onion</code>-addresses 的配置文件来覆盖，这些地址在 Tor 网络内部使用。XBPS 允许在 <code>/etc/xbps.d</code> 下重写存储库地址。</p>
<p>将你的软件源文件从 <code>/usr/share/xbps.d</code> 复制到 <code>/etc/xbps.d</code>，并用洋葱服务器的地址替换（以 Lysator 的洋葱为例）：</p>
<pre><code># mkdir -p /etc/xbps.d
# cp /usr/share/xbps.d/*-repository-*.conf /etc/xbps.d/
# sed -i 's|https://repo-default.voidlinux.org|http://lysator7eknrfl47rlyxvgeamrv7ucefgrrlhk7rouv3sna25asetwid.onion/pub/voidlinux|g' /etc/xbps.d/*-repository-*.conf
</code></pre>
<p>Tor 提供分层的端对端加密，因此不需要 HTTPS。</p>
<p>当安装软件包时，如果像前面的例子那样设置了 <code>SOCKS_PROXY</code>，XBPS 应该表明它正在从覆盖中指定的洋葱地址同步存储库：</p>
<pre><code># xbps-install -S
[*] Updating `http://lysator7eknrfl47rlyxvgeamrv7ucefgrrlhk7rouv3sna25asetwid.onion/pub/voidlinux/current/aarch64/nonfree/aarch64-repodata' ...
aarch64-repodata: 4030B [avg rate: 54KB/s]
[*] Updating `http://lysator7eknrfl47rlyxvgeamrv7ucefgrrlhk7rouv3sna25asetwid.onion/pub/voidlinux/current/aarch64/aarch64-repodata' ...
aarch64-repodata: 1441KB [avg rate: 773KB/s]
</code></pre>
<h3 id="安全方面的的考虑"><a class="header" href="#安全方面的的考虑">安全方面的的考虑</a></h3>
<p>如果你使用 onion，建议在你的环境中自动设置 <code>SOCKS_PROXY</code>。如果缺少该设置，对隐藏服务器名称的 DNS 查询将泄露给配置的 DNS 服务器。</p>
<p>要自动设置环境变量，请将其添加到文件
<code>/etc/profile.d</code>:</p>
<pre><code># cat - &lt;&lt;EOF &gt; /etc/profile.d/socksproxy.sh
#!/bin/sh
export SOCKS_PROXY=&quot;socks5://127.0.0.1:9050&quot;
EOF
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="受限制的软件包"><a class="header" href="#受限制的软件包">受限制的软件包</a></h1>
<p>Void 提供了一些官方维护的软件包，但没有分发。这些包被标记为有限制性的，必须从它们的 <a href="https://github.com/void-linux/void-packages">void-packages</a> 模板本地构建。</p>
<p>软件包可以被上游作者或 Void 限制发布。Void 保留限制任何软件包发布的权利，原因不限，最常见的是体积庞大。另一个常见的原因是限制性许可，不允许第三方重新分发源代码或二进制包。</p>
<h2 id="手动构建"><a class="header" href="#手动构建">手动构建</a></h2>
<p>你可以使用 <a href="https://github.com/void-linux/void-packages">void-packages</a> 仓库中的 <code>xbps-src</code> 来从模板构建受限制的包。关于从模板构建软件包的说明，请参考 <a href="https://github.com/void-linux/void-packages">void-packages</a> 文档，特别是 <a href="https://github.com/void-linux/void-packages#quick-start">&quot;Quick start&quot;
section</a> 部分。</p>
<p>记住，必须通过在 <code>xbps-src</code> 配置中设置 <code>XBPS_ALLOW_RESTRICTED=yes</code> 来明确启用受限软件包的构建（在版本库的<code>etc/conf</code> 文件中）。</p>
<h2 id="自动构建"><a class="header" href="#自动构建">自动构建</a></h2>
<p>还有一个工具，<a href="https://github.com/the-maldridge/xbps-mini-builder">xbps-mini-builder</a>，它可以自动建立一个软件包列表的过程。这个脚本可以被定期调用，并且只在软件包的模板发生变化时才重新构建。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义软件源"><a class="header" href="#自定义软件源">自定义软件源</a></h1>
<p>Void 支持用户创建的本地和远程软件源。 这只是推荐用于提供个人创建的自定义包或来自另一个值得信赖的来源。 Void 项目不支持 <strong>任何</strong> 第三方软件源 - 第三方软件包的使用构成非常严重的安全问题，并有可能严重损坏您的系统。 </p>
<h2 id="添加自定义软件源"><a class="header" href="#添加自定义软件源">添加自定义软件源</a></h2>
<p>要添加自定义软件源，请在中 <code>/etc/xbps.d</code> 创建一个文件 ，内容为：</p>
<pre><code>repository=&lt;URL&gt;
</code></pre>
<p>其中 <code>&lt;URL&gt;</code> 是一个本地目录或一个指向远程软件源的 URL。</p>
<p>例如，要定义一个远程软件源：</p>
<pre><code># echo 'repository=http://my.domain.com/repo' &gt; /etc/xbps.d/my-remote-repo.conf
</code></pre>
<p><a href="https://man.voidlinux.org/xbps-install.1">xbps-install(1)</a> 拒绝安装来自远程软件源的软件包，如果它们没有被<a href="xbps/repositories/./signing.html">签名</a>。</p>
<p>要定义本地软件源： </p>
<pre><code># echo 'repository=/path/to/repo' &gt; /etc/xbps.d/my-local-repo.conf
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="把软件源签名"><a class="header" href="#把软件源签名">把软件源签名</a></h1>
<p>对远程软件源 <strong>必须</strong> 进行签名。 本地存储库不需要签名。</p>
<p><a href="https://man.voidlinux.org/xbps-rindex.1">xbps-rindex(1)</a> 工具被用来签名软件源。</p>
<p>用于签名软件包的私钥需要是一个 PEM 编码的 RSA 密钥。该密钥可以用 <a href="https://man.voidlinux.org/ssh-keygen.1">ssh-keygen(1)</a> 或 <a href="https://man.voidlinux.org/openssl.1">openssl(1)</a> 来生成：</p>
<pre><code>$ ssh-keygen -t rsa -m PEM -f private.pem
</code></pre>
<pre><code>$ openssl genrsa -out private.pem
</code></pre>
<p>一旦密钥生成，私钥的公开部分就必须被添加到软件源元数据中。这个步骤只需要一次。</p>
<pre><code>$ xbps-rindex --privkey private.pem --sign --signedby &quot;I'm Groot&quot; /path/to/repository/dir
</code></pre>
<p>然后用以下命令签名一个或多个软件包:</p>
<pre><code>$ xbps-rindex --privkey private.pem --sign-pkg /path/to/repository/dir/*.xbps
</code></pre>
<p>请注意，未来的软件包将不会被自动签名。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xbps-的故障排除"><a class="header" href="#xbps-的故障排除">XBPS 的故障排除</a></h1>
<p>有时，软件包管理器会进入一个奇怪的地方，没有帮助就不能自我修复。本节记录了重要的修复和使用 XBPS 时可能出错的事情。</p>
<h2 id="部分内容"><a class="header" href="#部分内容">部分内容</a></h2>
<ul>
<li><a href="xbps/troubleshooting/./common-issues.html">常见问题</a></li>
<li><a href="xbps/troubleshooting/./static.html">Static XBPS</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常见问题"><a class="header" href="#常见问题">常见问题</a></h1>
<h2 id="验证-rsa-密钥"><a class="header" href="#验证-rsa-密钥">验证 RSA 密钥</a></h2>
<p>如果 Void RSA 密钥已经改变，<a href="https://man.voidlinux.org/xbps-install.1">xbps-install(1)</a> 将报告新的密钥指纹，并要求你确认：</p>
<pre><code>&lt;repository&gt; repository has been RSA signed by &quot;Void Linux&quot;
Fingerprint: &lt;rsa_fingerprint&gt;
Do you want to import this public key? [Y/n]
</code></pre>
<p>为了验证密钥，确保 <code>&lt;rsa_fingerprint&gt;</code> 与 <a href="https://github.com/void-linux/void-packages/tree/master/common/repo-keys">void-packages</a> 和  <a href="https://github.com/void-linux/void-mklive/tree/master/keys">void-mklive</a> 中的一个指纹相匹配。</p>
<h2 id="更新或安装软件包时出现错误"><a class="header" href="#更新或安装软件包时出现错误">更新或安装软件包时出现错误</a></h2>
<p>如果在更新或安装新软件包时有任何错误，确保你使用的是最新版本的软件源索引。使用 <code>-S</code> 选项运行 <a href="https://man.voidlinux.org/xbps-install.1">xbps-install(1)</a> 可以保证这一点。</p>
<h3 id="operation-not-permitted"><a class="header" href="#operation-not-permitted">&quot;Operation not permitted&quot;</a></h3>
<p>&quot;Operation not permitted&quot; 的错误，例如：</p>
<pre><code>ERROR: [reposync] failed to fetch file https://repo-default.voidlinux.org/current/nonfree/x86_64-repodata': Operation not permitted
</code></pre>
<p>可能是由于你的系统的日期和/或时间不正确造成的。确保你的 <a href="xbps/troubleshooting/../../config/date-time.html">日期和时间</a>  是正确的。</p>
<h3 id="not-found"><a class="header" href="#not-found">&quot;Not Found&quot;</a></h3>
<p>&quot;Not Found&quot; 的错误，例如：</p>
<pre><code>ERROR: [reposync] failed to fetch file `https://repo-default.voidlinux.org/current/musl/x86_64-repodata': Not Found
</code></pre>
<p>通常意味着你的 XBPS 配置对你的系统来说指向了错误的存储库。确认你的 <a href="https://man.voidlinux.org/xbps.d.5">xbps.d(5)</a> 文件指向了<a href="xbps/troubleshooting/../repositories/index.html">正确的软件源</a>。</p>
<h3 id="shlib-错误"><a class="header" href="#shlib-错误">shlib 错误</a></h3>
<p>&quot;unresolvable shlib&quot; 的错误, 例如:</p>
<pre><code>libllvm8-8.0.1_2: broken, unresolvable shlib `libffi.so.6'
</code></pre>
<p>可能是由于过期或无主的软件包造成的。要检查过时的软件包，只需尝试<a href="xbps/troubleshooting/../index.html#updating">更新你的系统</a>。另一方面，&quot;孤立&quot; 包已经从 Void repos 中删除，但仍然安装在你的系统上；它们可以通过运行带有 <code>-o</code> 选项的 <a href="https://man.voidlinux.org/xbps-remove.1">xbps-remove(1)</a> 来删除。</p>
<p>如果你得到一个错误信息说：</p>
<pre><code>Transaction aborted due to unresolved shlibs
</code></pre>
<p>软件源处于暂存状态，这可能是由于大型构建而发生的。解决的办法是等待构建完成。你可以在 <a href="https://build.voidlinux.org/waterfall">Buildbot's Waterfall
Display</a> 中查看构建的进度。</p>
<h3 id="repodata-错误"><a class="header" href="#repodata-错误">repodata 错误</a></h3>
<p>在 2020 年 3 月，用于软件源数据（ repodata ）的压缩格式从 gzip 改为 zstd。 如果 XBPS 没有更新到 <code>0.54</code> 版本（2019 年 6 月发布）或更新版本，就不可能用它来更新系统。不幸的是，这种情况没有错误信息，但可以通过运行带有 <code>-Sd</code> 标志的 <code>xbps-install</code> 来检测。这个错误的调试信息显示如下。</p>
<pre><code>[DEBUG] [repo] `//var/db/xbps/https___repo-default_voidlinux_org_current/x86_64-repodata' failed to open repodata archive Invalid or incomplete multibyte or wide character
</code></pre>
<p>在这种情况下，有必要遵循 <a href="xbps/troubleshooting/./static.html">xbps-static</a> 中的步骤。</p>
<h2 id="残疾系统"><a class="header" href="#残疾系统">残疾系统</a></h2>
<p>如果你的系统由于某种原因出现故障，无法进行更新或安装软件包，使用<a href="xbps/troubleshooting/./static.html">静态链接版本的 xbps</a>来更新和安装软件包可以帮助你避免重新安装整个系统。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-xbps"><a class="header" href="#static-xbps">Static XBPS</a></h1>
<p>在极少数情况下，有可能破坏系统，使 XBPS 不能再运行。这通常发生在试图对 libc 做不支持的事情时，但也可能发生在更新包含一个损坏的 glibc 归档文件或其他未能完全解压和配置的情况下。</p>
<p>另一个可能出现的问题是在 XBPS <code>0.54</code>（2019 年 6 月发布）之前的版本的系统。这些系统将无法使用常规的更新程序从官方软件源中进行更新，这是因为用于软件源数据的压缩格式在 2020 年 3 月发生了变化。</p>
<p>在这些情况下，有可能用一个单独的、静态编译的 XBPS 副本来恢复你的系统。</p>
<h2 id="获取-static-xbps"><a class="header" href="#获取-static-xbps">获取 static XBPS</a></h2>
<p>XBPS 的静态编译版本可以在所有镜像的 <code>static/</code> 目录中找到。下面的链接指向欧洲的主镜像上的静态副本。</p>
<p><a href="https://repo-default.voidlinux.org/static">https://repo-default.voidlinux.org/static</a></p>
<p>下载并解压最新版本，或与你系统中的破损副本相匹配的版本（优先选择最新副本）。</p>
<h2 id="使用-static-xbps"><a class="header" href="#使用-static-xbps">使用 static XBPS</a></h2>
<p>静态组中的工具与大多数系统中的普通工具是相同的。唯一的区别是，这些工具是静态链接到 musl C 库的，并且应该在没有其他工具的系统上工作。在那些不能再启动的系统上，建议使用 Void 安装介质进行 chroot，并从那里使用静态工具，因为即使是 shell 也不可能在这些系统上正确工作。当使用 static XBPS 与 glibc 安装时，环境变量 <code>XBPS_ARCH</code> 需要被设置。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="贡献"><a class="header" href="#贡献">贡献</a></h1>
<p>运行一个发行版，不仅仅是写代码。</p>
<p>要为Void软件包库做贡献，首先要阅读 void-packages GitHub 仓库中的 <a href="https://github.com/void-linux/void-packages/blob/master/CONTRIBUTING.md">CONTRIBUTING</a> 文档。</p>
<p>要为本手册做出贡献，请阅读 void-docs 仓库中的 <a href="https://github.com/void-linux/void-docs/blob/master/CONTRIBUTING.md">CONTRIBUTING</a>。</p>
<p>如果你有任何问题，欢迎通过 IRC 在 irc.libera.chat 的 #voidlinux 中提问，或者在 <a href="https://reddit.com/r/voidlinux">the voidlinux subreddit</a> 中提问。</p>
<h2 id="使用情况统计"><a class="header" href="#使用情况统计">使用情况统计</a></h2>
<p>如果你想提供使用报告，<a href="https://github.com/the-maldridge/popcorn">PopCorn</a>  程序会向 Void 项目报告安装统计数据。这些统计数据是 opt-in --PopCorn 在任何 Void 系统上都<em>没有</em>安装或默认启用。此外， PopCorn 要求在您的系统上不封锁 8001 端口。</p>
<p><em>PopCorn</em> 只报告哪些软件包被安装，它们的版本，以及主机 CPU 架构（<code>xuname</code> 的输出）。这并不报告哪些服务被启用，或任何其他个人信息。单个系统通过一个随机的（客户生成的）UUID 被持续跟踪，以确保每个系统在每个 24 小时的采样期只被计算一次。</p>
<p>收集的数据 <em>PopCorn</em> 可在以下位置查看
<a href="http://popcorn.voidlinux.org">http://popcorn.voidlinux.org</a></p>
<h3 id="设置-popcorn"><a class="header" href="#设置-popcorn">设置 PopCorn</a></h3>
<p>首先，安装 <code>PopCorn</code> 软件包。然后，启用 <code>popcorn</code> 服务，它将尝试每天报告一次统计数据。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为-void-docs-做贡献"><a class="header" href="#为-void-docs-做贡献">为 void-docs 做贡献</a></h1>
<p>本手册的源代码托管在 GitHub 上的 <a href="https://github.com/void-linux/void-docs">void-docs</a> 仓库。如果你想做出贡献，请阅读<a href="contributing/void-docs/../../about/about-this-handbook.html">本手册的目的</a>，遵循我们的<a href="https://github.com/void-linux/void-docs/blob/master/CONTRIBUTING.md#style-guide">风格指南</a>，并<a href="https://github.com/void-linux/void-docs/blob/master/CONTRIBUTING.md#submitting-changes">提交一个拉动请求</a>。</p>

				</main>

				<nav id="nav-wide-wrapper" aria-label="Page navigation">

				</nav>
			</div>
		</div>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="book.js" type="text/javascript" charset="utf-8"></script>
    </body>
</html>
